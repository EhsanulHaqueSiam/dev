#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------
# Restore SSH keys from external SSD (age-encrypted backup)
#
# Decrypts an age-encrypted tarball from the SSD back to ~/.ssh/
# Restores correct permissions (600 for private keys, 644 for public)
#
# Usage:
#   ./ssh-restore                             — restore from latest backup
#   ./ssh-restore --list                      — list available backups
#   ./ssh-restore --from <filename>           — restore specific backup
#   ./ssh-restore --dry                       — preview without restoring
# -----------------------------------------------------------------------

SSD="/run/media/siam/TRANSCEND"
SSH_BACKUP_DIR="$SSD/ssh-keys"
SSH_DIR="$HOME/.ssh"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

log()  { echo -e "${GREEN}[ssh-restore]${NC} $1"; }
warn() { echo -e "${YELLOW}[ssh-restore]${NC} $1"; }
err()  { echo -e "${RED}[ssh-restore]${NC} $1"; }
info() { echo -e "${BLUE}[ssh-restore]${NC} $1"; }

# -----------------------------------------------------------------------
# Parse arguments
# -----------------------------------------------------------------------
dry_run=0
list_mode=0
from_file=""

while [[ $# -gt 0 ]]; do
	case "$1" in
		--dry)  dry_run=1 ;;
		--list) list_mode=1 ;;
		--from) shift; from_file="${1:?--from requires a filename}" ;;
		*)      err "unknown flag: $1"; exit 1 ;;
	esac
	shift
done

# -----------------------------------------------------------------------
# Check dependencies
# -----------------------------------------------------------------------
if ! command -v age &>/dev/null; then
	warn "age not found — installing..."
	if command -v yay &>/dev/null; then
		yay -S --noconfirm --needed age
	elif command -v pacman &>/dev/null; then
		sudo pacman -S --noconfirm --needed age
	else
		err "install age manually: https://github.com/FiloSottile/age"
		exit 1
	fi
fi

# -----------------------------------------------------------------------
# Check SSD
# -----------------------------------------------------------------------
if ! mountpoint -q "$SSD" 2>/dev/null; then
	err "SSD not mounted at $SSD"
	exit 1
fi

if [[ ! -d "$SSH_BACKUP_DIR" ]]; then
	err "no SSH backup directory found at $SSH_BACKUP_DIR"
	exit 1
fi

# -----------------------------------------------------------------------
# Find backups
# -----------------------------------------------------------------------
mapfile -t backups < <(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort)

if [[ ${#backups[@]} -eq 0 ]]; then
	err "no SSH backups found in $SSH_BACKUP_DIR"
	exit 1
fi

# -----------------------------------------------------------------------
# List mode
# -----------------------------------------------------------------------
if [[ $list_mode -eq 1 ]]; then
	log "SSH key backups on SSD:"
	echo ""
	for b in "${backups[@]}"; do
		size=$(du -sh "$b" 2>/dev/null | cut -f1)
		echo -e "  ${BOLD}$(basename "$b")${NC}  $size"
	done
	echo ""
	log "usage: ./ssh-restore                    (restore latest)"
	log "       ./ssh-restore --from <filename>  (restore specific)"
	exit 0
fi

# -----------------------------------------------------------------------
# Select backup to restore
# -----------------------------------------------------------------------
if [[ -n "$from_file" ]]; then
	backup_file="$SSH_BACKUP_DIR/$from_file"
	if [[ ! -f "$backup_file" ]]; then
		err "backup not found: $backup_file"
		err "available:"
		for b in "${backups[@]}"; do
			echo "  $(basename "$b")"
		done
		exit 1
	fi
else
	# Use latest
	backup_file="${backups[-1]}"
fi

backup_name=$(basename "$backup_file")
backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)

echo ""
log "restoring from: $backup_name ($backup_size)"

# -----------------------------------------------------------------------
# Dry run
# -----------------------------------------------------------------------
if [[ $dry_run -eq 1 ]]; then
	echo ""
	warn "=== DRY RUN ==="
	warn "would decrypt: $backup_file"
	warn "would restore to: $SSH_DIR"
	warn "would fix permissions (600 private, 644 public, 700 dir)"
	if [[ -d "$SSH_DIR" ]]; then
		warn "existing ~/.ssh/ would be backed up first"
	fi
	warn "no changes made"
	exit 0
fi

# -----------------------------------------------------------------------
# Confirm
# -----------------------------------------------------------------------
echo ""
if [[ -d "$SSH_DIR" ]]; then
	warn "existing SSH keys found at $SSH_DIR"
	warn "they will be backed up to ~/.ssh.bak before overwriting"
fi
warn "source: $backup_file"
warn "target: $SSH_DIR"
echo ""
echo -n "type 'yes' to continue: "
read -r confirm
if [[ "$confirm" != "yes" ]]; then
	log "aborted"
	exit 0
fi
echo ""

# -----------------------------------------------------------------------
# Backup existing SSH directory
# -----------------------------------------------------------------------
if [[ -d "$SSH_DIR" ]]; then
	backup_existing="$HOME/.ssh.bak.$(date +%Y%m%d-%H%M%S)"
	log "backing up existing SSH keys to $backup_existing"
	cp -r "$SSH_DIR" "$backup_existing"
	chmod 700 "$backup_existing"
fi

# -----------------------------------------------------------------------
# Decrypt and restore
# -----------------------------------------------------------------------
log "decrypting SSH keys..."
echo ""

# Create temp directory for extraction
tmpdir=$(mktemp -d)
trap 'rm -rf "$tmpdir"' EXIT

# Decrypt and extract
age -d "$backup_file" | tar -C "$tmpdir" -xf -

if [[ ! -d "$tmpdir/.ssh" ]]; then
	err "decryption failed or archive is corrupted"
	exit 1
fi

# Copy to home (merge, don't delete existing)
mkdir -p "$SSH_DIR"
cp -r "$tmpdir/.ssh/"* "$SSH_DIR/" 2>/dev/null || true
cp -r "$tmpdir/.ssh/".[!.]* "$SSH_DIR/" 2>/dev/null || true

# -----------------------------------------------------------------------
# Fix permissions (critical — SSH refuses keys with wrong perms)
# -----------------------------------------------------------------------
log "fixing permissions..."

chmod 700 "$SSH_DIR"

for f in "$SSH_DIR"/*; do
	[[ -e "$f" ]] || continue
	name=$(basename "$f")
	case "$name" in
		*.pub|known_hosts|known_hosts.old|authorized_keys)
			chmod 644 "$f"
			;;
		config)
			chmod 600 "$f"
			;;
		*)
			# Private keys and everything else: 600
			chmod 600 "$f"
			;;
	esac
done

# -----------------------------------------------------------------------
# Verify
# -----------------------------------------------------------------------
echo ""
echo -e "${GREEN}================================${NC}"
log "SSH restore complete"
echo -e "${GREEN}================================${NC}"
echo ""

log "restored keys:"
for f in "$SSH_DIR"/*; do
	[[ -e "$f" ]] || continue
	name=$(basename "$f")
	perms=$(stat -c '%a' "$f")

	case "$name" in
		id_*|*.pem)
			if [[ "$name" == *.pub ]]; then
				info "  $name  ($perms)  [public key]"
			else
				info "  $name  ($perms)  [private key]"
			fi
			;;
		config)       info "  $name  ($perms)  [ssh config]" ;;
		known_hosts)  info "  $name  ($perms)  [known hosts]" ;;
		*)            info "  $name  ($perms)" ;;
	esac
done

echo ""
log "test with: ssh -T git@github.com"

if [[ -n "${backup_existing:-}" ]]; then
	echo ""
	warn "old SSH keys backed up at: $backup_existing"
	warn "delete when confirmed working: rm -rf $backup_existing"
fi
