#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------
# Interactive TUI for dev environment management
# Requires: gum (charmbracelet/gum)
# -----------------------------------------------------------------------

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"

if [ -z "${DEV_ENV:-}" ]; then
	DEV_ENV="$script_dir"
fi

SSD="/run/media/siam/TRANSCEND"
BACKUP_ROOT="$SSD/backups"
SOURCES=(Personal)

# -----------------------------------------------------------------------
# Check dependencies — auto-install gum if missing
# -----------------------------------------------------------------------
if ! command -v gum &>/dev/null; then
	echo "gum is required for the TUI but not installed."
	if command -v paru &>/dev/null; then
		echo "Installing gum..."
		paru -S --noconfirm --needed gum
	elif command -v pacman &>/dev/null; then
		echo "Installing gum..."
		sudo pacman -S --noconfirm --needed gum
	else
		echo "Install gum manually: https://github.com/charmbracelet/gum"
		exit 1
	fi
fi

# -----------------------------------------------------------------------
# Theme
# -----------------------------------------------------------------------
export GUM_CHOOSE_CURSOR_FOREGROUND="212"
export GUM_CHOOSE_SELECTED_FOREGROUND="212"
export GUM_CHOOSE_HEADER_FOREGROUND="240"
export GUM_CONFIRM_PROMPT_FOREGROUND="212"

# -----------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------
header() {
	echo ""
	gum style \
		--foreground 212 --bold \
		--border double --border-foreground 240 \
		--padding "0 2" --margin "0 0" \
		"$1"
	echo ""
}

divider() {
	gum style --foreground 240 "$(printf '%.0s─' {1..50})"
}

info() {
	gum style --foreground 39 "  $1"
}

success() {
	gum style --foreground 78 "  $1"
}

warn() {
	gum style --foreground 214 "  $1"
}

error() {
	gum style --foreground 196 "  $1"
}

pause() {
	echo ""
	gum style --foreground 240 "  Press any key to continue..."
	read -rsn1
}

# -----------------------------------------------------------------------
# SSD status helper
# -----------------------------------------------------------------------
ssd_status() {
	if mountpoint -q "$SSD" 2>/dev/null; then
		local fs used total free pct
		fs=$(df -Th "$SSD" | awk 'NR==2 {print $2}')
		total=$(df -h "$SSD" | awk 'NR==2 {print $2}')
		used=$(df -h "$SSD" | awk 'NR==2 {print $3}')
		free=$(df -h "$SSD" | awk 'NR==2 {print $4}')
		pct=$(df "$SSD" | awk 'NR==2 {print $5}')
		echo "mounted  $fs  ${used}/${total} (${pct})  ${free} free"
	else
		echo "not mounted"
	fi
}

backup_list() {
	find "$BACKUP_ROOT" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | sort
}

latest_backup() {
	backup_list | tail -1
}

# -----------------------------------------------------------------------
# Main menu
# -----------------------------------------------------------------------
main_menu() {
	while true; do
		clear
		header "Dev Environment"

		local ssd_info
		ssd_info=$(ssd_status)
		info "SSD: $ssd_info"
		echo ""

		local choice
		choice=$(gum choose \
			--header "What would you like to do?" \
			--height 11 \
			"Install Tools" \
			"Deploy Configs" \
			"Backup to SSD" \
			"Restore from SSD" \
			"SSH Keys" \
			"Status" \
			"Quit" \
		) || return 0

		case "$choice" in
			"Install Tools")  menu_install ;;
			"Deploy Configs") menu_deploy ;;
			"Backup to SSD")  menu_backup ;;
			"Restore from SSD") menu_restore ;;
			"SSH Keys")       menu_ssh ;;
			"Status")         menu_status ;;
			"Quit")           return 0 ;;
		esac
	done
}

# -----------------------------------------------------------------------
# Install Tools
# -----------------------------------------------------------------------
tool_installed() {
	local tool="$1"
	case "$tool" in
		age)          command -v age &>/dev/null ;;
		atuin)        command -v atuin &>/dev/null ;;
		bat)          command -v bat &>/dev/null ;;
		bun)          command -v bun &>/dev/null ;;
		discord)      command -v discord &>/dev/null || pacman -Qi discord &>/dev/null ;;
		expressvpn)   command -v expressvpn &>/dev/null ;;
		eza)          command -v eza &>/dev/null ;;
		fnm)          command -v fnm &>/dev/null ;;
		gcalcli)      command -v gcalcli &>/dev/null ;;
		gemini)       command -v gemini &>/dev/null ;;
		ghostty)      command -v ghostty &>/dev/null ;;
		go)           command -v go &>/dev/null ;;
		gum)          command -v gum &>/dev/null ;;
		miniconda)    command -v conda &>/dev/null ;;
		neovim)       command -v nvim &>/dev/null ;;
		node)         command -v node &>/dev/null ;;
		nvidiaDriver) pacman -Qi nvidia &>/dev/null 2>&1 ;;
		ollama)       command -v ollama &>/dev/null ;;
		omarchy)      [[ -d "$HOME/.omarchy" ]] 2>/dev/null ;;
		python)       command -v python3 &>/dev/null ;;
		rust)         command -v rustc &>/dev/null ;;
		starship)     command -v starship &>/dev/null ;;
		ticktick)     command -v ticktick &>/dev/null || flatpak list 2>/dev/null | grep -qi ticktick ;;
		tldr)         command -v tldr &>/dev/null ;;
		tmux)         command -v tmux &>/dev/null ;;
		uv)           command -v uv &>/dev/null ;;
		xh)           command -v xh &>/dev/null ;;
		yazi)         command -v yazi &>/dev/null ;;
		zsh)          command -v zsh &>/dev/null ;;
		*)            command -v "$tool" &>/dev/null ;;
	esac
}

tool_version() {
	local tool="$1"
	case "$tool" in
		bun)       bun --version 2>/dev/null ;;
		go)        go version 2>/dev/null | awk '{print $3}' | sed 's/go//' ;;
		node)      node --version 2>/dev/null | sed 's/v//' ;;
		nvim|neovim) nvim --version 2>/dev/null | head -1 | awk '{print $2}' | sed 's/v//' ;;
		python)    python3 --version 2>/dev/null | awk '{print $2}' ;;
		rust)      rustc --version 2>/dev/null | awk '{print $2}' ;;
		tmux)      tmux -V 2>/dev/null | awk '{print $2}' ;;
		zsh)       zsh --version 2>/dev/null | awk '{print $2}' ;;
		gum)       gum --version 2>/dev/null | awk '{print $3}' ;;
		bat)       bat --version 2>/dev/null | awk '{print $2}' ;;
		eza)       eza --version 2>/dev/null | awk 'NR==2 {print $1}' | sed 's/v//' ;;
		starship)  starship --version 2>/dev/null | head -1 | awk '{print $2}' ;;
		uv)        uv --version 2>/dev/null | awk '{print $2}' ;;
		xh)        xh --version 2>/dev/null | head -1 | awk '{print $2}' ;;
		yazi)      yazi --version 2>/dev/null | awk '{print $2}' ;;
		age)       age --version 2>/dev/null | awk '{print $2}' | sed 's/v//' ;;
		atuin)     atuin --version 2>/dev/null | awk '{print $2}' ;;
		fnm)       fnm --version 2>/dev/null | sed 's/fnm //' ;;
		ollama)    ollama --version 2>/dev/null | awk '{print $NF}' ;;
		ghostty)   ghostty --version 2>/dev/null | head -1 | awk '{print $2}' ;;
		*)         echo "" ;;
	esac
}

menu_install() {
	clear
	header "Install Tools"

	# Gather tool info
	local tools=() installed_count=0 total_count=0
	for s in "$DEV_ENV"/runs/*; do
		[[ -x "$s" ]] || continue
		tools+=("$(basename "$s")")
		total_count=$(( total_count + 1 ))
	done

	if [[ ${#tools[@]} -eq 0 ]]; then
		error "No tools found in runs/"
		pause
		return
	fi

	# Show tool status overview
	local installed_list=() missing_list=()
	for t in "${tools[@]}"; do
		if tool_installed "$t"; then
			local ver
			ver=$(tool_version "$t")
			installed_count=$(( installed_count + 1 ))
			if [[ -n "$ver" ]]; then
				installed_list+=("$t ($ver)")
			else
				installed_list+=("$t")
			fi
		else
			missing_list+=("$t")
		fi
	done

	gum style --foreground 240 "  Tools: $installed_count/$total_count installed"
	echo ""

	if [[ ${#missing_list[@]} -gt 0 ]]; then
		gum style --foreground 214 "  Not installed:"
		for t in "${missing_list[@]}"; do
			gum style --foreground 214 "    - $t"
		done
		echo ""
	fi

	local choice
	choice=$(gum choose \
		--header "Select mode:" \
		--height 8 \
		"Install All" \
		"Install Missing Only" \
		"Select Tools" \
		"View Installed" \
		"Dry Run (preview)" \
		"Back" \
	) || return 0

	case "$choice" in
		"Install All")
			echo ""
			if gum confirm "Install/update all $total_count tools?"; then
				echo ""
				"$DEV_ENV/run"
			fi
			pause
			;;
		"Install Missing Only")
			do_install_missing "${missing_list[@]}"
			;;
		"Select Tools")
			select_and_install "${tools[@]}"
			;;
		"View Installed")
			do_view_installed "${installed_list[@]}"
			;;
		"Dry Run (preview)")
			echo ""
			"$DEV_ENV/run" --dry
			pause
			;;
		"Back") return 0 ;;
	esac
}

do_install_missing() {
	local missing=("$@")

	if [[ ${#missing[@]} -eq 0 ]]; then
		echo ""
		success "All tools already installed!"
		pause
		return
	fi

	echo ""
	gum style --foreground 214 "Missing tools to install:"
	for t in "${missing[@]}"; do
		info "  $t"
	done
	echo ""

	if gum confirm "Install ${#missing[@]} missing tool(s)?"; then
		echo ""
		for tool in "${missing[@]}"; do
			gum style --foreground 39 --bold "--- $tool ---"
			"$DEV_ENV/run" "$tool" || true
			echo ""
		done
		success "Done!"
	else
		warn "Cancelled"
	fi
	pause
}

select_and_install() {
	local tools=("$@")

	# Build labels with installed status
	local labels=()
	for t in "${tools[@]}"; do
		if tool_installed "$t"; then
			local ver
			ver=$(tool_version "$t")
			if [[ -n "$ver" ]]; then
				labels+=("$t  ✓ $ver")
			else
				labels+=("$t  ✓")
			fi
		else
			labels+=("$t  ✗ not installed")
		fi
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--no-limit \
		--header "Select tools (space to toggle, enter to confirm):" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	# Extract tool names (first word before spaces)
	local tool_names=()
	while read -r line; do
		tool_names+=("$(echo "$line" | awk '{print $1}')")
	done <<< "$selected"

	echo ""
	gum style --foreground 78 "Selected:"
	for t in "${tool_names[@]}"; do
		info "  $t"
	done
	echo ""

	if gum confirm "Install ${#tool_names[@]} selected tool(s)?"; then
		echo ""
		for tool in "${tool_names[@]}"; do
			gum style --foreground 39 --bold "--- $tool ---"
			"$DEV_ENV/run" "$tool" || true
			echo ""
		done
		success "Done!"
	else
		warn "Cancelled"
	fi
	pause
}

do_view_installed() {
	local installed=("$@")

	clear
	header "Installed Tools"

	if [[ ${#installed[@]} -eq 0 ]]; then
		warn "No tools installed"
		pause
		return
	fi

	gum style --foreground 240 "  ${#installed[@]} tools installed:"
	echo ""
	for t in "${installed[@]}"; do
		success "✓ $t"
	done
	pause
}

# -----------------------------------------------------------------------
# Deploy Configs
# -----------------------------------------------------------------------
config_status() {
	# Returns: "linked" | "not_linked" | "conflict" | "missing"
	local src="$1" dest="$2"
	if [[ ! -e "$src" && ! -d "$src" ]]; then
		echo "missing"
	elif [[ -L "$dest" ]] && [[ "$(readlink -f "$dest")" == "$(readlink -f "$src")" ]]; then
		echo "linked"
	elif [[ -e "$dest" || -L "$dest" ]]; then
		echo "conflict"
	else
		echo "not_linked"
	fi
}

gather_configs() {
	# Outputs lines: type|name|src|dest|status
	local xdg="${XDG_CONFIG_HOME:-$HOME/.config}"

	# .config/ directories
	for dir in "$DEV_ENV"/env/.config/*/; do
		[[ -d "$dir" ]] || continue
		local name
		name=$(basename "$dir")
		local src="$DEV_ENV/env/.config/$name"
		local dest="$xdg/$name"
		local st
		st=$(config_status "$src" "$dest")
		echo "config|$name|$src|$dest|$st"
	done

	# .config/ standalone files (e.g. starship.toml)
	for file in "$DEV_ENV"/env/.config/*; do
		[[ -f "$file" ]] || continue
		local name
		name=$(basename "$file")
		local src="$file"
		local dest="$xdg/$name"
		local st
		st=$(config_status "$src" "$dest")
		echo "config|$name|$src|$dest|$st"
	done

	# .local/ files
	if [[ -d "$DEV_ENV/env/.local" ]]; then
		for dir in "$DEV_ENV"/env/.local/*/; do
			[[ -d "$dir" ]] || continue
			local dirname
			dirname=$(basename "$dir")
			for item in "$dir"*; do
				[[ -e "$item" ]] || continue
				local fname
				fname=$(basename "$item")
				local src="$item"
				local dest="$HOME/.local/$dirname/$fname"
				local st
				st=$(config_status "$src" "$dest")
				echo "local|.local/$dirname/$fname|$src|$dest|$st"
			done
		done
	fi

	# Home dotfiles (auto-detect any dotfile in env/)
	for file in "$DEV_ENV"/env/.*; do
		[[ -f "$file" ]] || continue
		local name
		name=$(basename "$file")
		[[ "$name" == "." || "$name" == ".." ]] && continue
		local src="$file"
		local dest="$HOME/$name"
		local st
		st=$(config_status "$src" "$dest")
		echo "dotfile|$name|$src|$dest|$st"
	done
}

menu_deploy() {
	clear
	header "Deploy Configs"

	# Gather config status
	local configs=()
	local linked_count=0 not_linked_count=0 conflict_count=0 total_count=0
	while IFS='|' read -r type name src dest status; do
		configs+=("$type|$name|$src|$dest|$status")
		total_count=$(( total_count + 1 ))
		case "$status" in
			linked)     linked_count=$(( linked_count + 1 )) ;;
			not_linked) not_linked_count=$(( not_linked_count + 1 )) ;;
			conflict)   conflict_count=$(( conflict_count + 1 )) ;;
		esac
	done < <(gather_configs)

	gum style --foreground 240 "  Configs: $linked_count/$total_count linked"
	if [[ $not_linked_count -gt 0 ]]; then
		gum style --foreground 214 "  Not linked: $not_linked_count"
	fi
	if [[ $conflict_count -gt 0 ]]; then
		gum style --foreground 196 "  Conflicts: $conflict_count (local file exists, not symlinked)"
	fi
	echo ""

	local choice
	choice=$(gum choose \
		--header "Select mode:" \
		--height 8 \
		"Deploy All Configs" \
		"Deploy Unlinked Only" \
		"Select Configs" \
		"View Status" \
		"Dry Run (preview)" \
		"Back" \
	) || return 0

	case "$choice" in
		"Deploy All Configs")
			echo ""
			if gum confirm "Deploy all $total_count configs?"; then
				echo ""
				"$DEV_ENV/dev-env"
			fi
			pause
			;;
		"Deploy Unlinked Only")
			do_deploy_unlinked "${configs[@]}"
			;;
		"Select Configs")
			do_deploy_select "${configs[@]}"
			;;
		"View Status")
			do_view_config_status "${configs[@]}"
			;;
		"Dry Run (preview)")
			echo ""
			"$DEV_ENV/dev-env" --dry
			pause
			;;
		"Back") return 0 ;;
	esac
}

deploy_single_config() {
	local type="$1" name="$2" src="$3" dest="$4"
	local xdg="${XDG_CONFIG_HOME:-$HOME/.config}"

	case "$type" in
		config)
			# Symlink directory or standalone file in .config/
			if [[ -e "$dest" || -L "$dest" ]]; then
				if [[ ! -L "$dest" ]]; then
					local backup_dir="$HOME/.config-backup/$(date +%Y%m%d-%H%M%S)"
					mkdir -p "$backup_dir"
					cp -r "$dest" "$backup_dir/$(basename "$dest")"
					info "  backed up: $dest"
				fi
				rm -rf "$dest"
			fi
			mkdir -p "$(dirname "$dest")"
			ln -sf "$src" "$dest"
			success "  linked: $name -> $dest"
			;;
		local)
			# Symlink individual file
			mkdir -p "$(dirname "$dest")"
			if [[ -e "$dest" || -L "$dest" ]]; then
				if [[ ! -L "$dest" ]]; then
					local backup_dir="$HOME/.config-backup/$(date +%Y%m%d-%H%M%S)"
					mkdir -p "$backup_dir"
					cp "$dest" "$backup_dir/$(basename "$dest")"
					info "  backed up: $dest"
				fi
				rm -f "$dest"
			fi
			ln -sf "$src" "$dest"
			success "  linked: $name -> $dest"
			;;
		dotfile)
			# Symlink home dotfile
			if [[ -e "$dest" || -L "$dest" ]]; then
				if [[ ! -L "$dest" ]]; then
					local backup_dir="$HOME/.config-backup/$(date +%Y%m%d-%H%M%S)"
					mkdir -p "$backup_dir"
					cp "$dest" "$backup_dir/$(basename "$dest")"
					info "  backed up: $dest"
				fi
				rm -f "$dest"
			fi
			ln -sf "$src" "$dest"
			success "  linked: $name -> $dest"
			;;
	esac
}

do_deploy_unlinked() {
	local configs=("$@")
	local unlinked=()

	for entry in "${configs[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"
		if [[ "$status" == "not_linked" || "$status" == "conflict" ]]; then
			unlinked+=("$entry")
		fi
	done

	if [[ ${#unlinked[@]} -eq 0 ]]; then
		echo ""
		success "All configs already linked!"
		pause
		return
	fi

	echo ""
	gum style --foreground 214 "Configs to deploy:"
	for entry in "${unlinked[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"
		if [[ "$status" == "conflict" ]]; then
			gum style --foreground 196 "  $name  (will backup existing)"
		else
			info "  $name"
		fi
	done
	echo ""

	if gum confirm "Deploy ${#unlinked[@]} config(s)?"; then
		echo ""
		for entry in "${unlinked[@]}"; do
			IFS='|' read -r type name src dest status <<< "$entry"
			deploy_single_config "$type" "$name" "$src" "$dest"
		done
		echo ""
		success "Done!"
	else
		warn "Cancelled"
	fi
	pause
}

do_deploy_select() {
	local configs=("$@")

	# Build labels with status
	local labels=()
	for entry in "${configs[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"
		case "$status" in
			linked)     labels+=("$name  ✓ linked") ;;
			not_linked) labels+=("$name  ✗ not linked") ;;
			conflict)   labels+=("$name  ⚠ conflict") ;;
			missing)    labels+=("$name  ? missing source") ;;
		esac
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--no-limit \
		--header "Select configs (space to toggle, enter to confirm):" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	# Match selected labels back to config entries
	local to_deploy=()
	while read -r line; do
		local sel_name
		sel_name=$(echo "$line" | awk '{print $1}')
		for entry in "${configs[@]}"; do
			IFS='|' read -r type name src dest status <<< "$entry"
			if [[ "$name" == "$sel_name" ]]; then
				to_deploy+=("$entry")
				break
			fi
		done
	done <<< "$selected"

	echo ""
	gum style --foreground 78 "Selected:"
	for entry in "${to_deploy[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"
		info "  $name"
	done
	echo ""

	if gum confirm "Deploy ${#to_deploy[@]} config(s)?"; then
		echo ""
		for entry in "${to_deploy[@]}"; do
			IFS='|' read -r type name src dest status <<< "$entry"
			deploy_single_config "$type" "$name" "$src" "$dest"
		done
		echo ""
		success "Done!"
	else
		warn "Cancelled"
	fi
	pause
}

do_view_config_status() {
	local configs=("$@")

	clear
	header "Config Status"

	local prev_type=""
	for entry in "${configs[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"

		# Section headers
		if [[ "$type" != "$prev_type" ]]; then
			echo ""
			case "$type" in
				config)  gum style --foreground 212 --bold "  .config/ directories" ;;
				local)   gum style --foreground 212 --bold "  .local/ files" ;;
				dotfile) gum style --foreground 212 --bold "  Home dotfiles" ;;
			esac
			prev_type="$type"
		fi

		case "$status" in
			linked)     success "  ✓ $name" ;;
			not_linked) warn "  ✗ $name  (not deployed)" ;;
			conflict)   error "  ⚠ $name  (local file exists, not symlinked)" ;;
			missing)    gum style --foreground 240 "  ? $name  (source missing)" ;;
		esac
	done

	pause
}

# -----------------------------------------------------------------------
# Backup
# -----------------------------------------------------------------------
menu_backup() {
	if ! mountpoint -q "$SSD" 2>/dev/null; then
		clear
		header "Backup"
		error "SSD not mounted at $SSD"
		pause
		return
	fi

	clear
	header "Backup to SSD"
	info "SSD: $(ssd_status)"

	# Show existing backups
	local backups
	mapfile -t backups < <(backup_list)
	if [[ ${#backups[@]} -gt 0 ]]; then
		echo ""
		gum style --foreground 240 "  Existing backups:"
		for b in "${backups[@]}"; do
			local size
			size=$(du -sh "$b" 2>/dev/null | cut -f1)
			info "  $(basename "$b")  $size"
		done
	fi

	echo ""

	local choice
	choice=$(gum choose \
		--header "Backup mode:" \
		--height 8 \
		"Full Backup (new snapshot)" \
		"Select Projects" \
		"Update Subfolder (in latest)" \
		"Dry Run (preview)" \
		"Configure" \
		"Back" \
	) || return 0

	case "$choice" in
		"Full Backup (new snapshot)")
			do_backup_full
			;;
		"Select Projects")
			do_backup_select
			;;
		"Update Subfolder (in latest)")
			do_backup_subfolder
			;;
		"Dry Run (preview)")
			echo ""
			"$DEV_ENV/backup" --dry
			pause
			;;
		"Configure")
			do_backup_configure
			;;
		"Back") return 0 ;;
	esac
}

do_backup_full() {
	echo ""
	if gum confirm "Run full backup of all sources?"; then
		echo ""
		"$DEV_ENV/backup"
		pause
	fi
}

do_backup_select() {
	# List available project directories in each source
	local projects=()
	for src in "${SOURCES[@]}"; do
		local src_path="$HOME/$src"
		[[ -d "$src_path" ]] || continue
		for d in "$src_path"/*/; do
			[[ -d "$d" ]] || continue
			local name
			name=$(basename "$d")
			# Skip common excludes
			[[ "$name" == ".git" || "$name" == "node_modules" || "$name" == ".cache" ]] && continue
			[[ "$name" == ".ror" || "$name" == ".playwright-mcp" ]] && continue
			projects+=("$src/$name")
		done
	done

	if [[ ${#projects[@]} -eq 0 ]]; then
		error "No projects found"
		pause
		return
	fi

	echo ""
	local selected
	selected=$(printf '%s\n' "${projects[@]}" | gum choose \
		--no-limit \
		--header "Select projects to backup (space to toggle):" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	gum style --foreground 78 "Selected for backup:"
	echo "$selected" | while read -r p; do
		info "  $p"
	done
	echo ""

	if gum confirm "Backup selected projects?"; then
		echo ""
		echo "$selected" | while read -r proj; do
			"$DEV_ENV/backup" "$proj"
		done
		pause
	fi
}

do_backup_subfolder() {
	local latest
	latest=$(latest_backup)
	if [[ -z "$latest" ]]; then
		error "No existing backup found — run a full backup first"
		pause
		return
	fi

	info "Will update: $(basename "$latest")"
	echo ""

	# List subfolders available for update
	local subfolders=()
	for src in "${SOURCES[@]}"; do
		local src_path="$HOME/$src"
		[[ -d "$src_path" ]] || continue
		for d in "$src_path"/*/; do
			[[ -d "$d" ]] || continue
			local name
			name=$(basename "$d")
			[[ "$name" == ".git" || "$name" == "node_modules" || "$name" == ".cache" ]] && continue
			[[ "$name" == ".ror" || "$name" == ".playwright-mcp" ]] && continue
			subfolders+=("$src/$name")
		done
	done

	local selected
	selected=$(printf '%s\n' "${subfolders[@]}" | gum choose \
		--no-limit \
		--header "Select subfolders to update in latest backup:" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	gum style --foreground 78 "Will update in $(basename "$latest"):"
	echo "$selected" | while read -r s; do
		info "  $s"
	done
	echo ""

	if gum confirm "Update selected subfolders?"; then
		echo ""
		echo "$selected" | while read -r sub; do
			"$DEV_ENV/backup" "$sub"
		done
		pause
	fi
}

do_backup_configure() {
	echo ""
	gum style --foreground 240 "  Current defaults are set in the backup script."
	gum style --foreground 240 "  You can override per-run with flags:"
	echo ""
	info "--keep N    retention count (default: 2)"
	info "--jobs N    parallel workers (default: 4)"
	echo ""
	info "Example: ./backup --keep 5 --jobs 8"
	pause
}

# -----------------------------------------------------------------------
# Restore
# -----------------------------------------------------------------------
menu_restore() {
	if ! mountpoint -q "$SSD" 2>/dev/null; then
		clear
		header "Restore"
		error "SSD not mounted at $SSD"
		pause
		return
	fi

	clear
	header "Restore from SSD"

	local backups
	mapfile -t backups < <(backup_list)

	if [[ ${#backups[@]} -eq 0 ]]; then
		warn "No backups found on SSD"
		pause
		return
	fi

	# Show available backups
	gum style --foreground 240 "  Available backups:"
	for b in "${backups[@]}"; do
		local size contents
		size=$(du -sh "$b" 2>/dev/null | cut -f1)
		contents=$(ls -1 "$b" 2>/dev/null | tr '\n' ', ' | sed 's/,$//')
		info "$(basename "$b")  $size  [$contents]"
	done
	echo ""

	local choice
	choice=$(gum choose \
		--header "Restore mode:" \
		--height 8 \
		"Restore All from Latest" \
		"Restore Specific Projects" \
		"Restore Subfolder" \
		"Choose Backup Version" \
		"Dry Run (preview)" \
		"Back" \
	) || return 0

	case "$choice" in
		"Restore All from Latest")
			do_restore_latest
			;;
		"Restore Specific Projects")
			do_restore_select_projects
			;;
		"Restore Subfolder")
			do_restore_subfolder
			;;
		"Choose Backup Version")
			do_restore_from_specific
			;;
		"Dry Run (preview)")
			do_restore_dry
			;;
		"Back") return 0 ;;
	esac
}

do_restore_latest() {
	local latest
	latest=$(latest_backup)
	[[ -z "$latest" ]] && { error "No backup found"; pause; return; }

	local size
	size=$(du -sh "$latest" 2>/dev/null | cut -f1)

	echo ""
	warn "Restoring from: $(basename "$latest") ($size)"
	warn "This will overwrite files in your home directory"
	warn "Mode: safe merge (won't delete local files)"
	echo ""

	# List what's in the backup
	local targets=()
	for d in "$latest"/*/; do
		[[ -d "$d" ]] && targets+=("$(basename "$d")")
	done

	info "Contains: ${targets[*]}"
	echo ""

	if gum confirm "Restore all from latest backup?"; then
		echo ""
		for t in "${targets[@]}"; do
			echo "yes" | "$DEV_ENV/restore" "$t"
		done
		pause
	fi
}

do_restore_select_projects() {
	local latest
	latest=$(latest_backup)
	[[ -z "$latest" ]] && { error "No backup found"; pause; return; }

	# List available projects in backup
	local projects=()
	for d in "$latest"/*/; do
		[[ -d "$d" ]] && projects+=("$(basename "$d")")
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${projects[@]}" | gum choose \
		--no-limit \
		--header "Select projects to restore from $(basename "$latest"):" \
		--height 15 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	warn "Will restore from: $(basename "$latest")"
	echo "$selected" | while read -r p; do
		info "  $p"
	done
	echo ""

	if gum confirm "Restore selected projects?"; then
		echo ""
		echo "$selected" | while read -r proj; do
			echo "yes" | "$DEV_ENV/restore" "$proj"
		done
		pause
	fi
}

do_restore_subfolder() {
	local latest
	latest=$(latest_backup)
	[[ -z "$latest" ]] && { error "No backup found"; pause; return; }

	# Build list of subfolders in backup
	local subfolders=()
	for src_dir in "$latest"/*/; do
		[[ -d "$src_dir" ]] || continue
		local src_name
		src_name=$(basename "$src_dir")
		for sub_dir in "$src_dir"/*/; do
			[[ -d "$sub_dir" ]] || continue
			subfolders+=("$src_name/$(basename "$sub_dir")")
		done
	done

	if [[ ${#subfolders[@]} -eq 0 ]]; then
		error "No subfolders found in backup"
		pause
		return
	fi

	echo ""
	local selected
	selected=$(printf '%s\n' "${subfolders[@]}" | gum choose \
		--no-limit \
		--header "Select subfolders to restore from $(basename "$latest"):" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	warn "Will restore subfolders from: $(basename "$latest")"
	echo "$selected" | while read -r s; do
		info "  $s"
	done
	echo ""

	if gum confirm "Restore selected subfolders?"; then
		echo ""
		echo "$selected" | while read -r sub; do
			echo "yes" | "$DEV_ENV/restore" "$sub"
		done
		pause
	fi
}

do_restore_from_specific() {
	local backups
	mapfile -t backups < <(backup_list)

	# Build selection list with sizes
	local labels=()
	for b in "${backups[@]}"; do
		local size
		size=$(du -sh "$b" 2>/dev/null | cut -f1)
		labels+=("$(basename "$b")  ($size)")
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--header "Choose backup:" \
		--height 10 \
	) || return 0

	# Extract timestamp from selection
	local ts
	ts=$(echo "$selected" | awk '{print $1}')

	local backup_dir="$BACKUP_ROOT/$ts"
	if [[ ! -d "$backup_dir" ]]; then
		error "Backup not found: $ts"
		pause
		return
	fi

	# List projects in that backup
	local projects=()
	for d in "$backup_dir"/*/; do
		[[ -d "$d" ]] && projects+=("$(basename "$d")")
	done

	local proj_selected
	proj_selected=$(printf '%s\n' "${projects[@]}" | gum choose \
		--no-limit \
		--header "Select projects to restore from $ts:" \
		--height 15 \
	) || return 0

	if [[ -z "$proj_selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	warn "Restoring from: $ts"
	echo "$proj_selected" | while read -r p; do
		info "  $p"
	done
	echo ""

	if gum confirm "Restore selected?"; then
		echo ""
		echo "$proj_selected" | while read -r proj; do
			echo "yes" | "$DEV_ENV/restore" --from "$ts" "$proj"
		done
		pause
	fi
}

do_restore_dry() {
	local latest
	latest=$(latest_backup)
	[[ -z "$latest" ]] && { error "No backup found"; pause; return; }

	# List projects in backup
	local projects=()
	for d in "$latest"/*/; do
		[[ -d "$d" ]] && projects+=("$(basename "$d")")
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${projects[@]}" | gum choose \
		--header "Select project for dry run preview:" \
		--height 10 \
	) || return 0

	echo ""
	"$DEV_ENV/restore" --dry "$selected"
	pause
}

# -----------------------------------------------------------------------
# SSH Keys
# -----------------------------------------------------------------------
SSH_BACKUP_DIR="$SSD/ssh-keys"

menu_ssh() {
	clear
	header "SSH Keys"

	# Show current SSH key status
	if [[ -d "$HOME/.ssh" ]]; then
		local key_count=0
		for f in "$HOME/.ssh"/id_*; do
			[[ -f "$f" && "$f" != *.pub ]] && key_count=$(( key_count + 1 ))
		done
		info "Local: $key_count private key(s) in ~/.ssh/"
	else
		warn "Local: no ~/.ssh/ directory"
	fi

	# Show SSD backup status
	if mountpoint -q "$SSD" 2>/dev/null && [[ -d "$SSH_BACKUP_DIR" ]]; then
		local backup_count
		backup_count=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
		if [[ $backup_count -gt 0 ]]; then
			local latest_backup_name
			latest_backup_name=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | tail -1 | xargs basename)
			info "SSD: $backup_count backup(s), latest: $latest_backup_name"
		else
			warn "SSD: no SSH backups"
		fi
	elif mountpoint -q "$SSD" 2>/dev/null; then
		warn "SSD: no SSH backups yet"
	else
		error "SSD: not mounted"
	fi

	echo ""

	local choice
	choice=$(gum choose \
		--header "SSH key management:" \
		--height 8 \
		"Backup SSH Keys" \
		"Restore SSH Keys" \
		"List Backups" \
		"View Local Keys" \
		"Dry Run (preview)" \
		"Back" \
	) || return 0

	case "$choice" in
		"Backup SSH Keys")
			do_ssh_backup
			;;
		"Restore SSH Keys")
			do_ssh_restore
			;;
		"List Backups")
			echo ""
			"$DEV_ENV/ssh-backup" --list
			pause
			;;
		"View Local Keys")
			do_ssh_view
			;;
		"Dry Run (preview)")
			echo ""
			"$DEV_ENV/ssh-backup" --dry
			pause
			;;
		"Back") return 0 ;;
	esac
}

do_ssh_backup() {
	if ! mountpoint -q "$SSD" 2>/dev/null; then
		error "SSD not mounted"
		pause
		return
	fi

	if [[ ! -d "$HOME/.ssh" ]]; then
		error "No ~/.ssh/ directory found"
		pause
		return
	fi

	echo ""
	warn "This will encrypt your SSH keys with a passphrase"
	warn "and save the encrypted backup to the SSD"
	echo ""

	if gum confirm "Backup SSH keys to SSD?"; then
		echo ""
		"$DEV_ENV/ssh-backup"
		pause
	fi
}

do_ssh_restore() {
	if ! mountpoint -q "$SSD" 2>/dev/null; then
		error "SSD not mounted"
		pause
		return
	fi

	if [[ ! -d "$SSH_BACKUP_DIR" ]]; then
		error "No SSH backups found on SSD"
		pause
		return
	fi

	# List available backups for selection
	local backups=()
	local labels=()
	mapfile -t backups < <(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort)

	if [[ ${#backups[@]} -eq 0 ]]; then
		error "No SSH backups found"
		pause
		return
	fi

	for b in "${backups[@]}"; do
		local size
		size=$(du -sh "$b" 2>/dev/null | cut -f1)
		labels+=("$(basename "$b")  ($size)")
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--header "Select backup to restore:" \
		--height 10 \
	) || return 0

	local filename
	filename=$(echo "$selected" | awk '{print $1}')

	echo ""
	warn "Will restore SSH keys from: $filename"
	warn "Existing keys will be backed up to ~/.ssh.bak.*"
	echo ""

	if gum confirm "Restore SSH keys?"; then
		echo ""
		echo "yes" | "$DEV_ENV/ssh-restore" --from "$filename"
		pause
	fi
}

do_ssh_view() {
	clear
	header "Local SSH Keys"

	if [[ ! -d "$HOME/.ssh" ]]; then
		warn "No ~/.ssh/ directory"
		pause
		return
	fi

	for f in "$HOME/.ssh"/*; do
		[[ -e "$f" ]] || continue
		local name perms size
		name=$(basename "$f")
		perms=$(stat -c '%a' "$f")
		size=$(du -sh "$f" 2>/dev/null | cut -f1)

		case "$name" in
			id_*|*.pem)
				if [[ "$name" == *.pub ]]; then
					success "  $name  ($perms)  $size  [public key]"
				else
					info "  $name  ($perms)  $size  [private key]"
				fi
				;;
			config)       info "  $name  ($perms)  $size  [ssh config]" ;;
			known_hosts)  info "  $name  ($perms)  $size  [known hosts]" ;;
			known_hosts.old) gum style --foreground 240 "  $name  ($perms)  $size" ;;
			*)            info "  $name  ($perms)  $size" ;;
		esac
	done

	pause
}

# -----------------------------------------------------------------------
# Status
# -----------------------------------------------------------------------
menu_status() {
	clear
	header "System Status"

	# SSD
	divider
	gum style --foreground 212 --bold "  SSD"
	if mountpoint -q "$SSD" 2>/dev/null; then
		local fs total used free pct
		fs=$(df -Th "$SSD" | awk 'NR==2 {print $2}')
		total=$(df -h "$SSD" | awk 'NR==2 {print $2}')
		used=$(df -h "$SSD" | awk 'NR==2 {print $3}')
		free=$(df -h "$SSD" | awk 'NR==2 {print $4}')
		pct=$(df "$SSD" | awk 'NR==2 {print $5}')
		info "Mount:       $SSD"
		info "Filesystem:  $fs"
		info "Size:        $total"
		info "Used:        $used ($pct)"
		info "Free:        $free"
	else
		error "Not mounted"
	fi

	echo ""

	# Backups
	divider
	gum style --foreground 212 --bold "  Backups"
	if mountpoint -q "$SSD" 2>/dev/null; then
		local backups
		mapfile -t backups < <(backup_list)
		if [[ ${#backups[@]} -gt 0 ]]; then
			info "Count: ${#backups[@]}"
			for b in "${backups[@]}"; do
				local size contents
				size=$(du -sh "$b" 2>/dev/null | cut -f1)
				contents=$(ls -1 "$b" 2>/dev/null | tr '\n' ', ' | sed 's/,$//')
				info "  $(basename "$b")  $size  [$contents]"
			done
		else
			warn "No backups found"
		fi
	else
		warn "SSD not mounted"
	fi

	echo ""

	# System
	divider
	gum style --foreground 212 --bold "  System"
	info "CPU:    $(lscpu | grep 'Model name' | sed 's/.*: *//')"
	info "Cores:  $(nproc) threads"
	info "rsync:  $(rsync --version | head -1 | awk '{print $3}')"
	info "gum:    $(gum --version 2>&1 | awk '{print $NF}')"

	echo ""

	# Dev repo
	divider
	gum style --foreground 212 --bold "  Dev Repo"
	info "Path: $DEV_ENV"
	local git_status
	git_status=$(cd "$DEV_ENV" && git status --porcelain 2>/dev/null | wc -l)
	if [[ "$git_status" -eq 0 ]]; then
		success "Clean (no uncommitted changes)"
	else
		warn "$git_status uncommitted change(s)"
	fi
	local branch
	branch=$(cd "$DEV_ENV" && git branch --show-current 2>/dev/null)
	info "Branch: $branch"

	echo ""

	# Tools
	divider
	gum style --foreground 212 --bold "  Installed Tools"
	local tool_count
	tool_count=$(find "$DEV_ENV/runs" -mindepth 1 -maxdepth 1 -executable 2>/dev/null | wc -l)
	info "$tool_count tool scripts in runs/"

	pause
}

# -----------------------------------------------------------------------
# Entry point
# -----------------------------------------------------------------------
main_menu
