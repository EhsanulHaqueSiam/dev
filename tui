#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------
# Interactive TUI for dev environment management
# Requires: gum (charmbracelet/gum)
# -----------------------------------------------------------------------

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"

if [ -z "${DEV_ENV:-}" ]; then
	DEV_ENV="$script_dir"
fi

source "$script_dir/lib/config.sh"

# -----------------------------------------------------------------------
# Check dependencies — auto-install gum if missing
# -----------------------------------------------------------------------
if ! command -v gum &>/dev/null; then
	echo "gum is required for the TUI but not installed."
	if command -v yay &>/dev/null; then
		echo "Installing gum..."
		yay -S --noconfirm --needed gum
	elif command -v pacman &>/dev/null; then
		echo "Installing gum..."
		sudo pacman -S --noconfirm --needed gum
	else
		echo "Install gum manually: https://github.com/charmbracelet/gum"
		exit 1
	fi
fi

# -----------------------------------------------------------------------
# Theme
# -----------------------------------------------------------------------
export GUM_CHOOSE_CURSOR_FOREGROUND="212"
export GUM_CHOOSE_SELECTED_FOREGROUND="212"
export GUM_CHOOSE_HEADER_FOREGROUND="240"
export GUM_CONFIRM_PROMPT_FOREGROUND="212"

# -----------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------
header() {
	echo ""
	gum style \
		--foreground 212 --bold \
		--border double --border-foreground 240 \
		--padding "0 2" --margin "0 0" \
		"$1"
	echo ""
}

divider() {
	gum style --foreground 240 "$(printf '%.0s─' {1..50})"
}

info() {
	gum style --foreground 39 "  $1"
}

success() {
	gum style --foreground 78 "  $1"
}

warn() {
	gum style --foreground 214 "  $1"
}

error() {
	gum style --foreground 196 "  $1"
}

pause() {
	echo ""
	gum style --foreground 240 "  Press any key to continue..."
	read -rsn1
}

# -----------------------------------------------------------------------
# SSD status helper
# -----------------------------------------------------------------------
ssd_status() {
	if mountpoint -q "$SSD" 2>/dev/null; then
		local fs used total free pct
		fs=$(df -Th "$SSD" | awk 'NR==2 {print $2}')
		total=$(df -h "$SSD" | awk 'NR==2 {print $2}')
		used=$(df -h "$SSD" | awk 'NR==2 {print $3}')
		free=$(df -h "$SSD" | awk 'NR==2 {print $4}')
		pct=$(df "$SSD" | awk 'NR==2 {print $5}')
		echo "mounted  $fs  ${used}/${total} (${pct})  ${free} free"
	else
		echo "not mounted"
	fi
}

backup_list() {
	find "$BACKUP_ROOT" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | sort
}

latest_backup() {
	backup_list | tail -1
}

# -----------------------------------------------------------------------
# Main menu
# -----------------------------------------------------------------------
main_menu() {
	while true; do
		clear
		header "Dev Environment"

		local ssd_info
		ssd_info=$(ssd_status)
		info "SSD: $ssd_info"
		echo ""

		local choice
		choice=$(gum choose \
			--header "What would you like to do?" \
			--height 12 \
			"Install Tools" \
			"Deploy Configs" \
			"Backup to SSD" \
			"Restore from SSD" \
			"Secrets" \
			"Status" \
			"Settings" \
			"Quit" \
		) || continue

		case "$choice" in
			"Install Tools")  menu_install ;;
			"Deploy Configs") menu_deploy ;;
			"Backup to SSD")  menu_backup ;;
			"Restore from SSD") menu_restore ;;
			"Secrets")        menu_secrets ;;
			"Status")         menu_status ;;
			"Settings")       menu_settings ;;
			"Quit")           return 0 ;;
		esac
	done
}

# -----------------------------------------------------------------------
# Install Tools
# -----------------------------------------------------------------------
tool_installed() {
	local tool="$1"
	case "$tool" in
		age)          command -v age &>/dev/null ;;
		atuin)        command -v atuin &>/dev/null ;;
		bat)          command -v bat &>/dev/null ;;
		bitwarden-cli) command -v bw &>/dev/null ;;
		bun)          command -v bun &>/dev/null ;;
		discord)      command -v discord &>/dev/null || pacman -Qi discord &>/dev/null ;;
		expressvpn)   command -v expressvpn &>/dev/null ;;
		eza)          command -v eza &>/dev/null ;;
		fnm)          command -v fnm &>/dev/null ;;
		gcalcli)      command -v gcalcli &>/dev/null ;;
		gemini)       command -v gemini &>/dev/null ;;
		ghostty)      command -v ghostty &>/dev/null ;;
		go)           command -v go &>/dev/null ;;
		gum)          command -v gum &>/dev/null ;;
		miniconda)    command -v conda &>/dev/null ;;
		neovim)       command -v nvim &>/dev/null ;;
		node)         command -v node &>/dev/null ;;
		nvidiaDriver) pacman -Qi nvidia &>/dev/null 2>&1 ;;
		ollama)       command -v ollama &>/dev/null ;;
		omarchy)      [[ -d "$HOME/.omarchy" ]] 2>/dev/null ;;
		python)       command -v python3 &>/dev/null ;;
		rust)         command -v rustc &>/dev/null ;;
		starship)     command -v starship &>/dev/null ;;
		ticktick)     command -v ticktick &>/dev/null || flatpak list 2>/dev/null | grep -qi ticktick ;;
		tldr)         command -v tldr &>/dev/null ;;
		tmux)         command -v tmux &>/dev/null ;;
		uv)           command -v uv &>/dev/null ;;
		xh)           command -v xh &>/dev/null ;;
		yazi)         command -v yazi &>/dev/null ;;
		zsh)          command -v zsh &>/dev/null ;;
		*)            command -v "$tool" &>/dev/null ;;
	esac
}

tool_version() {
	local tool="$1"
	case "$tool" in
		bun)       bun --version 2>/dev/null ;;
		go)        go version 2>/dev/null | awk '{print $3}' | sed 's/go//' ;;
		node)      node --version 2>/dev/null | sed 's/v//' ;;
		nvim|neovim) nvim --version 2>/dev/null | head -1 | awk '{print $2}' | sed 's/v//' ;;
		python)    python3 --version 2>/dev/null | awk '{print $2}' ;;
		rust)      rustc --version 2>/dev/null | awk '{print $2}' ;;
		tmux)      tmux -V 2>/dev/null | awk '{print $2}' ;;
		zsh)       zsh --version 2>/dev/null | awk '{print $2}' ;;
		gum)       gum --version 2>/dev/null | awk '{print $3}' ;;
		bat)       bat --version 2>/dev/null | awk '{print $2}' ;;
		bitwarden-cli) bw --version 2>/dev/null ;;
		eza)       eza --version 2>/dev/null | awk 'NR==2 {print $1}' | sed 's/v//' ;;
		starship)  starship --version 2>/dev/null | head -1 | awk '{print $2}' ;;
		uv)        uv --version 2>/dev/null | awk '{print $2}' ;;
		xh)        xh --version 2>/dev/null | head -1 | awk '{print $2}' ;;
		yazi)      yazi --version 2>/dev/null | awk '{print $2}' ;;
		age)       age --version 2>/dev/null | awk '{print $2}' | sed 's/v//' ;;
		atuin)     atuin --version 2>/dev/null | awk '{print $2}' ;;
		fnm)       fnm --version 2>/dev/null | sed 's/fnm //' ;;
		ollama)    ollama --version 2>/dev/null | awk '{print $NF}' ;;
		ghostty)   ghostty --version 2>/dev/null | head -1 | awk '{print $2}' ;;
		*)         echo "" ;;
	esac
}

menu_install() {
	while true; do
		clear
		header "Install Tools"

		# Gather tool info
		local tools=() installed_count=0 total_count=0
		shopt -s nullglob
		for s in "$DEV_ENV"/runs/*; do
			[[ -x "$s" ]] || continue
			tools+=("$(basename "$s")")
			total_count=$(( total_count + 1 ))
		done
		shopt -u nullglob

		if [[ ${#tools[@]} -eq 0 ]]; then
			error "No tools found in runs/"
			pause
			return
		fi

		# Show tool status overview
		local installed_list=() missing_list=()
		for t in "${tools[@]}"; do
			if tool_installed "$t"; then
				local ver
				ver=$(tool_version "$t")
				installed_count=$(( installed_count + 1 ))
				if [[ -n "$ver" ]]; then
					installed_list+=("$t ($ver)")
				else
					installed_list+=("$t")
				fi
			else
				missing_list+=("$t")
			fi
		done

		gum style --foreground 240 "  Tools: $installed_count/$total_count installed"
		echo ""

		if [[ ${#missing_list[@]} -gt 0 ]]; then
			gum style --foreground 214 "  Not installed:"
			for t in "${missing_list[@]}"; do
				gum style --foreground 214 "    - $t"
			done
			echo ""
		fi

		local choice
		choice=$(gum choose \
			--header "Select mode:" \
			--height 8 \
			"Install All" \
			"Install Missing Only" \
			"Select Tools" \
			"View Installed" \
			"Dry Run (preview)" \
			"Back" \
		) || return 0

		case "$choice" in
			"Install All")
				echo ""
				if gum confirm "Install/update all $total_count tools?"; then
					echo ""
					"$DEV_ENV/run"
				fi
				pause
				;;
			"Install Missing Only")
				do_install_missing "${missing_list[@]}"
				;;
			"Select Tools")
				select_and_install "${tools[@]}"
				;;
			"View Installed")
				do_view_installed "${installed_list[@]}"
				;;
			"Dry Run (preview)")
				echo ""
				"$DEV_ENV/run" --dry
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

do_install_missing() {
	local missing=("$@")

	if [[ ${#missing[@]} -eq 0 ]]; then
		echo ""
		success "All tools already installed!"
		pause
		return
	fi

	echo ""
	gum style --foreground 214 "Missing tools to install:"
	for t in "${missing[@]}"; do
		info "  $t"
	done
	echo ""

	if gum confirm "Install ${#missing[@]} missing tool(s)?"; then
		echo ""
		for tool in "${missing[@]}"; do
			gum style --foreground 39 --bold "--- $tool ---"
			"$DEV_ENV/run" "$tool" || true
			echo ""
		done
		success "Done!"
	else
		warn "Cancelled"
	fi
	pause
}

select_and_install() {
	local tools=("$@")

	# Build labels with installed status
	local labels=()
	for t in "${tools[@]}"; do
		if tool_installed "$t"; then
			local ver
			ver=$(tool_version "$t")
			if [[ -n "$ver" ]]; then
				labels+=("$t  ✓ $ver")
			else
				labels+=("$t  ✓")
			fi
		else
			labels+=("$t  ✗ not installed")
		fi
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--no-limit \
		--header "Select tools (space to toggle, enter to confirm):" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	# Extract tool names (first word before spaces)
	local tool_names=()
	while read -r line; do
		tool_names+=("$(echo "$line" | awk '{print $1}')")
	done <<< "$selected"

	echo ""
	gum style --foreground 78 "Selected:"
	for t in "${tool_names[@]}"; do
		info "  $t"
	done
	echo ""

	if gum confirm "Install ${#tool_names[@]} selected tool(s)?"; then
		echo ""
		for tool in "${tool_names[@]}"; do
			gum style --foreground 39 --bold "--- $tool ---"
			"$DEV_ENV/run" "$tool" || true
			echo ""
		done
		success "Done!"
	else
		warn "Cancelled"
	fi
	pause
}

do_view_installed() {
	local installed=("$@")

	clear
	header "Installed Tools"

	if [[ ${#installed[@]} -eq 0 ]]; then
		warn "No tools installed"
		pause
		return
	fi

	gum style --foreground 240 "  ${#installed[@]} tools installed:"
	echo ""
	for t in "${installed[@]}"; do
		success "✓ $t"
	done
	pause
}

# -----------------------------------------------------------------------
# Deploy Configs
# -----------------------------------------------------------------------
config_status() {
	# Returns: "deployed" | "not_deployed" | "missing"
	local src="$1" dest="$2"
	if [[ ! -e "$src" && ! -d "$src" ]]; then
		echo "missing"
	elif [[ -e "$dest" ]]; then
		echo "deployed"
	else
		echo "not_deployed"
	fi
}

gather_configs() {
	# Outputs lines: type|name|src|dest|status
	local xdg="${XDG_CONFIG_HOME:-$HOME/.config}"

	# .config/ directories
	for dir in "$DEV_ENV"/env/.config/*/; do
		[[ -d "$dir" ]] || continue
		local name
		name=$(basename "$dir")
		local src="$DEV_ENV/env/.config/$name"
		local dest="$xdg/$name"
		local st
		st=$(config_status "$src" "$dest")
		echo "config|$name|$src|$dest|$st"
	done

	# .config/ standalone files (e.g. starship.toml)
	for file in "$DEV_ENV"/env/.config/*; do
		[[ -f "$file" ]] || continue
		local name
		name=$(basename "$file")
		local src="$file"
		local dest="$xdg/$name"
		local st
		st=$(config_status "$src" "$dest")
		echo "config|$name|$src|$dest|$st"
	done

	# .local/ files
	if [[ -d "$DEV_ENV/env/.local" ]]; then
		for dir in "$DEV_ENV"/env/.local/*/; do
			[[ -d "$dir" ]] || continue
			local dirname
			dirname=$(basename "$dir")
			for item in "$dir"*; do
				[[ -e "$item" ]] || continue
				local fname
				fname=$(basename "$item")
				local src="$item"
				local dest="$HOME/.local/$dirname/$fname"
				local st
				st=$(config_status "$src" "$dest")
				echo "local|.local/$dirname/$fname|$src|$dest|$st"
			done
		done
	fi

	# Home dotfiles (auto-detect any dotfile in env/)
	for file in "$DEV_ENV"/env/.*; do
		[[ -f "$file" ]] || continue
		local name
		name=$(basename "$file")
		[[ "$name" == "." || "$name" == ".." ]] && continue
		local src="$file"
		local dest="$HOME/$name"
		local st
		st=$(config_status "$src" "$dest")
		echo "dotfile|$name|$src|$dest|$st"
	done
}

menu_deploy() {
	while true; do
		clear
		header "Deploy Configs"

		# Gather config status
		local configs=()
		local deployed_count=0 not_deployed_count=0 total_count=0
		while IFS='|' read -r type name src dest status; do
			configs+=("$type|$name|$src|$dest|$status")
			total_count=$(( total_count + 1 ))
			case "$status" in
				deployed)     deployed_count=$(( deployed_count + 1 )) ;;
				not_deployed) not_deployed_count=$(( not_deployed_count + 1 )) ;;
			esac
		done < <(gather_configs)

		gum style --foreground 240 "  Configs: $deployed_count/$total_count deployed"
		if [[ $not_deployed_count -gt 0 ]]; then
			gum style --foreground 214 "  Not deployed: $not_deployed_count"
		fi
		echo ""

		local choice
		choice=$(gum choose \
			--header "Select mode:" \
			--height 10 \
			"Deploy All Configs" \
			"Deploy Missing Only" \
			"Select Configs" \
			"Capture Config" \
			"Update All (re-capture)" \
			"View Status" \
			"Dry Run (preview)" \
			"Back" \
		) || return 0

		case "$choice" in
			"Deploy All Configs")
				echo ""
				if gum confirm "Deploy all $total_count configs?"; then
					echo ""
					"$DEV_ENV/dev-env"
				fi
				pause
				;;
			"Deploy Missing Only")
				do_deploy_unlinked "${configs[@]}"
				;;
			"Select Configs")
				do_deploy_select "${configs[@]}"
				;;
			"Capture Config")
				local cap_path
				cap_path=$(gum input \
					--header "Path to capture (e.g. ~/.config/ghostty):" \
					--placeholder "~/.config/something" \
				) || continue
				if [[ -n "$cap_path" ]]; then
					echo ""
					"$DEV_ENV/dev-env" capture "$cap_path"
					pause
				fi
				;;
			"Update All (re-capture)")
				echo ""
				"$DEV_ENV/dev-env" update
				pause
				;;
			"View Status")
				do_view_config_status "${configs[@]}"
				;;
			"Dry Run (preview)")
				echo ""
				"$DEV_ENV/dev-env" --dry
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

deploy_single_config() {
	local type="$1" name="$2" src="$3" dest="$4"

	# Backup existing before replacing
	if [[ -e "$dest" ]]; then
		local backup_dir="$HOME/.config-backup/$(date +%Y%m%d-%H%M%S)"
		mkdir -p "$backup_dir"
		cp -r "$dest" "$backup_dir/$(basename "$dest")"
		info "  backed up: $dest"
		rm -rf "$dest"
	fi

	mkdir -p "$(dirname "$dest")"
	cp -r "$src" "$dest"
	success "  deployed: $name -> $dest"
}

do_deploy_unlinked() {
	local configs=("$@")
	local undeployed=()

	for entry in "${configs[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"
		if [[ "$status" == "not_deployed" ]]; then
			undeployed+=("$entry")
		fi
	done

	if [[ ${#undeployed[@]} -eq 0 ]]; then
		echo ""
		success "All configs already deployed!"
		pause
		return
	fi

	echo ""
	gum style --foreground 214 "Configs to deploy:"
	for entry in "${undeployed[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"
		info "  $name"
	done
	echo ""

	if gum confirm "Deploy ${#undeployed[@]} config(s)?"; then
		echo ""
		for entry in "${undeployed[@]}"; do
			IFS='|' read -r type name src dest status <<< "$entry"
			deploy_single_config "$type" "$name" "$src" "$dest"
		done
		echo ""
		success "Done!"
	else
		warn "Cancelled"
	fi
	pause
}

do_deploy_select() {
	local configs=("$@")

	# Build labels with status
	local labels=()
	for entry in "${configs[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"
		case "$status" in
			deployed)     labels+=("$name  ✓ deployed") ;;
			not_deployed) labels+=("$name  ✗ not deployed") ;;
			missing)      labels+=("$name  ? missing source") ;;
		esac
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--no-limit \
		--header "Select configs (space to toggle, enter to confirm):" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	# Match selected labels back to config entries
	local to_deploy=()
	while read -r line; do
		local sel_name
		sel_name=$(echo "$line" | awk '{print $1}')
		for entry in "${configs[@]}"; do
			IFS='|' read -r type name src dest status <<< "$entry"
			if [[ "$name" == "$sel_name" ]]; then
				to_deploy+=("$entry")
				break
			fi
		done
	done <<< "$selected"

	echo ""
	gum style --foreground 78 "Selected:"
	for entry in "${to_deploy[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"
		info "  $name"
	done
	echo ""

	if gum confirm "Deploy ${#to_deploy[@]} config(s)?"; then
		echo ""
		for entry in "${to_deploy[@]}"; do
			IFS='|' read -r type name src dest status <<< "$entry"
			deploy_single_config "$type" "$name" "$src" "$dest"
		done
		echo ""
		success "Done!"
	else
		warn "Cancelled"
	fi
	pause
}

do_view_config_status() {
	local configs=("$@")

	clear
	header "Config Status"

	local prev_type=""
	for entry in "${configs[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"

		# Section headers
		if [[ "$type" != "$prev_type" ]]; then
			echo ""
			case "$type" in
				config)  gum style --foreground 212 --bold "  .config/ directories" ;;
				local)   gum style --foreground 212 --bold "  .local/ files" ;;
				dotfile) gum style --foreground 212 --bold "  Home dotfiles" ;;
			esac
			prev_type="$type"
		fi

		case "$status" in
			deployed)     success "  ✓ $name" ;;
			not_deployed) warn "  ✗ $name  (not deployed)" ;;
			missing)      gum style --foreground 240 "  ? $name  (source missing)" ;;
		esac
	done

	pause
}

# -----------------------------------------------------------------------
# Backup
# -----------------------------------------------------------------------
menu_backup() {
	while true; do
		if ! check_ssd; then
			clear
			header "Backup"
			error "SSD not mounted at $SSD"
			if gum confirm "Change SSD path?"; then
				local new_ssd
				new_ssd=$(gum input --header "Enter SSD mount path:" --value "$SSD") || { return 0; }
				if [[ -n "$new_ssd" ]] && mountpoint -q "$new_ssd" 2>/dev/null; then
					save_config "SSD_PATH" "$new_ssd"
					load_config
					success "SSD path updated to $SSD"
				else
					error "Path not mounted: $new_ssd"
					pause
					continue
				fi
			else
				return 0
			fi
		fi

		clear
		header "Backup to SSD"
		info "SSD: $(ssd_status)"

		# Show existing backups
		local backups
		mapfile -t backups < <(backup_list)
		if [[ ${#backups[@]} -gt 0 ]]; then
			echo ""
			gum style --foreground 240 "  Existing backups:"
			for b in "${backups[@]}"; do
				local size
				size=$(du -sh "$b" 2>/dev/null | cut -f1)
				info "  $(basename "$b")  $size"
			done
		fi

		echo ""

		local choice
		choice=$(gum choose \
			--header "Backup mode:" \
			--height 8 \
			"Full Backup (new snapshot)" \
			"Select Projects" \
			"Update Subfolder (in latest)" \
			"Dry Run (preview)" \
			"Configure" \
			"Back" \
		) || return 0

		case "$choice" in
			"Full Backup (new snapshot)")
				do_backup_full
				;;
			"Select Projects")
				do_backup_select
				;;
			"Update Subfolder (in latest)")
				do_backup_subfolder
				;;
			"Dry Run (preview)")
				echo ""
				"$DEV_ENV/backup" --dry
				pause
				;;
			"Configure")
				do_backup_configure
				;;
			"Back") return 0 ;;
		esac
	done
}

do_backup_full() {
	echo ""
	if gum confirm "Run full backup of all sources?"; then
		echo ""
		"$DEV_ENV/backup"
		pause
	fi
}

do_backup_select() {
	# List available project directories in each source
	local projects=()
	for src in "${SOURCES[@]}"; do
		local src_path="$HOME/$src"
		[[ -d "$src_path" ]] || continue
		for d in "$src_path"/*/; do
			[[ -d "$d" ]] || continue
			local name
			name=$(basename "$d")
			# Skip common excludes
			[[ "$name" == ".git" || "$name" == "node_modules" || "$name" == ".cache" ]] && continue
			[[ "$name" == ".ror" || "$name" == ".playwright-mcp" ]] && continue
			projects+=("$src/$name")
		done
	done

	if [[ ${#projects[@]} -eq 0 ]]; then
		error "No projects found"
		pause
		return
	fi

	echo ""
	local selected
	selected=$(printf '%s\n' "${projects[@]}" | gum choose \
		--no-limit \
		--header "Select projects to backup (space to toggle):" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	gum style --foreground 78 "Selected for backup:"
	echo "$selected" | while read -r p; do
		info "  $p"
	done
	echo ""

	if gum confirm "Backup selected projects?"; then
		echo ""
		echo "$selected" | while read -r proj; do
			"$DEV_ENV/backup" "$proj"
		done
		pause
	fi
}

do_backup_subfolder() {
	local latest
	latest=$(latest_backup)
	if [[ -z "$latest" ]]; then
		error "No existing backup found — run a full backup first"
		pause
		return
	fi

	info "Will update: $(basename "$latest")"
	echo ""

	# List subfolders available for update
	local subfolders=()
	for src in "${SOURCES[@]}"; do
		local src_path="$HOME/$src"
		[[ -d "$src_path" ]] || continue
		for d in "$src_path"/*/; do
			[[ -d "$d" ]] || continue
			local name
			name=$(basename "$d")
			[[ "$name" == ".git" || "$name" == "node_modules" || "$name" == ".cache" ]] && continue
			[[ "$name" == ".ror" || "$name" == ".playwright-mcp" ]] && continue
			subfolders+=("$src/$name")
		done
	done

	local selected
	selected=$(printf '%s\n' "${subfolders[@]}" | gum choose \
		--no-limit \
		--header "Select subfolders to update in latest backup:" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	gum style --foreground 78 "Will update in $(basename "$latest"):"
	echo "$selected" | while read -r s; do
		info "  $s"
	done
	echo ""

	if gum confirm "Update selected subfolders?"; then
		echo ""
		echo "$selected" | while read -r sub; do
			"$DEV_ENV/backup" "$sub"
		done
		pause
	fi
}

do_backup_configure() {
	echo ""
	gum style --foreground 240 "  Current defaults are set in the backup script."
	gum style --foreground 240 "  You can override per-run with flags:"
	echo ""
	info "--keep N    retention count (default: 2)"
	info "--jobs N    parallel workers (default: 4)"
	echo ""
	info "Example: ./backup --keep 5 --jobs 8"
	pause
}

# -----------------------------------------------------------------------
# Restore
# -----------------------------------------------------------------------
menu_restore() {
	while true; do
		if ! check_ssd; then
			clear
			header "Restore"
			error "SSD not mounted at $SSD"
			if gum confirm "Change SSD path?"; then
				local new_ssd
				new_ssd=$(gum input --header "Enter SSD mount path:" --value "$SSD") || { return 0; }
				if [[ -n "$new_ssd" ]] && mountpoint -q "$new_ssd" 2>/dev/null; then
					save_config "SSD_PATH" "$new_ssd"
					load_config
					success "SSD path updated to $SSD"
				else
					error "Path not mounted: $new_ssd"
					pause
					continue
				fi
			else
				return 0
			fi
		fi

		clear
		header "Restore from SSD"

		local backups
		mapfile -t backups < <(backup_list)

		if [[ ${#backups[@]} -eq 0 ]]; then
			warn "No backups found on SSD"
			pause
			return
		fi

		# Show available backups
		gum style --foreground 240 "  Available backups:"
		for b in "${backups[@]}"; do
			local size contents
			size=$(du -sh "$b" 2>/dev/null | cut -f1)
			contents=$(ls -1 "$b" 2>/dev/null | tr '\n' ', ' | sed 's/,$//')
			info "$(basename "$b")  $size  [$contents]"
		done
		echo ""

		local choice
		choice=$(gum choose \
			--header "Restore mode:" \
			--height 8 \
			"Restore All from Latest" \
			"Restore Specific Projects" \
			"Restore Subfolder" \
			"Choose Backup Version" \
			"Dry Run (preview)" \
			"Back" \
		) || return 0

		case "$choice" in
			"Restore All from Latest")
				do_restore_latest
				;;
			"Restore Specific Projects")
				do_restore_select_projects
				;;
			"Restore Subfolder")
				do_restore_subfolder
				;;
			"Choose Backup Version")
				do_restore_from_specific
				;;
			"Dry Run (preview)")
				do_restore_dry
				;;
			"Back") return 0 ;;
		esac
	done
}

do_restore_latest() {
	local latest
	latest=$(latest_backup)
	[[ -z "$latest" ]] && { error "No backup found"; pause; return; }

	local size
	size=$(du -sh "$latest" 2>/dev/null | cut -f1)

	echo ""
	warn "Restoring from: $(basename "$latest") ($size)"
	warn "This will overwrite files in your home directory"
	warn "Mode: safe merge (won't delete local files)"
	echo ""

	# List what's in the backup
	local targets=()
	for d in "$latest"/*/; do
		[[ -d "$d" ]] && targets+=("$(basename "$d")")
	done

	info "Contains: ${targets[*]}"
	echo ""

	if gum confirm "Restore all from latest backup?"; then
		echo ""
		for t in "${targets[@]}"; do
			echo "yes" | "$DEV_ENV/restore" "$t"
		done
		pause
	fi
}

do_restore_select_projects() {
	local latest
	latest=$(latest_backup)
	[[ -z "$latest" ]] && { error "No backup found"; pause; return; }

	# List available projects in backup
	local projects=()
	for d in "$latest"/*/; do
		[[ -d "$d" ]] && projects+=("$(basename "$d")")
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${projects[@]}" | gum choose \
		--no-limit \
		--header "Select projects to restore from $(basename "$latest"):" \
		--height 15 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	warn "Will restore from: $(basename "$latest")"
	echo "$selected" | while read -r p; do
		info "  $p"
	done
	echo ""

	if gum confirm "Restore selected projects?"; then
		echo ""
		echo "$selected" | while read -r proj; do
			echo "yes" | "$DEV_ENV/restore" "$proj"
		done
		pause
	fi
}

do_restore_subfolder() {
	local latest
	latest=$(latest_backup)
	[[ -z "$latest" ]] && { error "No backup found"; pause; return; }

	# Build list of subfolders in backup
	local subfolders=()
	for src_dir in "$latest"/*/; do
		[[ -d "$src_dir" ]] || continue
		local src_name
		src_name=$(basename "$src_dir")
		for sub_dir in "$src_dir"/*/; do
			[[ -d "$sub_dir" ]] || continue
			subfolders+=("$src_name/$(basename "$sub_dir")")
		done
	done

	if [[ ${#subfolders[@]} -eq 0 ]]; then
		error "No subfolders found in backup"
		pause
		return
	fi

	echo ""
	local selected
	selected=$(printf '%s\n' "${subfolders[@]}" | gum choose \
		--no-limit \
		--header "Select subfolders to restore from $(basename "$latest"):" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	warn "Will restore subfolders from: $(basename "$latest")"
	echo "$selected" | while read -r s; do
		info "  $s"
	done
	echo ""

	if gum confirm "Restore selected subfolders?"; then
		echo ""
		echo "$selected" | while read -r sub; do
			echo "yes" | "$DEV_ENV/restore" "$sub"
		done
		pause
	fi
}

do_restore_from_specific() {
	local backups
	mapfile -t backups < <(backup_list)

	# Build selection list with sizes
	local labels=()
	for b in "${backups[@]}"; do
		local size
		size=$(du -sh "$b" 2>/dev/null | cut -f1)
		labels+=("$(basename "$b")  ($size)")
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--header "Choose backup:" \
		--height 10 \
	) || return 0

	# Extract timestamp from selection
	local ts
	ts=$(echo "$selected" | awk '{print $1}')

	local backup_dir="$BACKUP_ROOT/$ts"
	if [[ ! -d "$backup_dir" ]]; then
		error "Backup not found: $ts"
		pause
		return
	fi

	# List projects in that backup
	local projects=()
	for d in "$backup_dir"/*/; do
		[[ -d "$d" ]] && projects+=("$(basename "$d")")
	done

	local proj_selected
	proj_selected=$(printf '%s\n' "${projects[@]}" | gum choose \
		--no-limit \
		--header "Select projects to restore from $ts:" \
		--height 15 \
	) || return 0

	if [[ -z "$proj_selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	warn "Restoring from: $ts"
	echo "$proj_selected" | while read -r p; do
		info "  $p"
	done
	echo ""

	if gum confirm "Restore selected?"; then
		echo ""
		echo "$proj_selected" | while read -r proj; do
			echo "yes" | "$DEV_ENV/restore" --from "$ts" "$proj"
		done
		pause
	fi
}

do_restore_dry() {
	local latest
	latest=$(latest_backup)
	[[ -z "$latest" ]] && { error "No backup found"; pause; return; }

	# List projects in backup
	local projects=()
	for d in "$latest"/*/; do
		[[ -d "$d" ]] && projects+=("$(basename "$d")")
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${projects[@]}" | gum choose \
		--header "Select project for dry run preview:" \
		--height 10 \
	) || return 0

	echo ""
	"$DEV_ENV/restore" --dry "$selected"
	pause
}

# -----------------------------------------------------------------------
# Secrets (SSH Keys + .env files — age SSD + Bitwarden)
# -----------------------------------------------------------------------

menu_secrets() {
	while true; do
		clear
		header "Secrets"

		# SSH key status
		if [[ -d "$HOME/.ssh" ]]; then
			local key_count=0
			for f in "$HOME/.ssh"/id_*; do
				[[ -f "$f" && "$f" != *.pub ]] && key_count=$(( key_count + 1 ))
			done
			info "SSH: $key_count private key(s) in ~/.ssh/"
		else
			warn "SSH: no ~/.ssh/ directory"
		fi

		# SSD backup status
		if check_ssd; then
			local ssh_count=0 env_count=0
			[[ -d "$SSH_BACKUP_DIR" ]] && ssh_count=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			[[ -d "$ENV_BACKUP_DIR" ]] && env_count=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "SSD: $ssh_count SSH backup(s), $env_count env backup(s)"
		else
			error "SSD: not mounted"
		fi

		# Bitwarden status
		if command -v bw &>/dev/null; then
			local bw_status
			bw_status=$(bw status 2>/dev/null | jq -r '.status' 2>/dev/null || echo "unknown")
			info "Bitwarden: $bw_status"
		else
			gum style --foreground 240 "  Bitwarden: not installed"
		fi

		echo ""

		local choice
		choice=$(gum choose \
			--header "Secrets management:" \
			--height 9 \
			"SSH Keys" \
			"Env Files" \
			"List All Secrets" \
			"View Local SSH Keys" \
			"Back" \
		) || return 0

		case "$choice" in
			"SSH Keys")        menu_secrets_ssh ;;
			"Env Files")       menu_secrets_env ;;
			"List All Secrets")
				echo ""
				"$DEV_ENV/secrets" --list
				pause
				;;
			"View Local SSH Keys") do_ssh_view ;;
			"Back") return 0 ;;
		esac
	done
}

menu_secrets_ssh() {
	while true; do
		clear
		header "SSH Keys"

		# Show current status
		if [[ -d "$HOME/.ssh" ]]; then
			local key_count=0
			for f in "$HOME/.ssh"/id_*; do
				[[ -f "$f" && "$f" != *.pub ]] && key_count=$(( key_count + 1 ))
			done
			info "Local: $key_count private key(s)"
		else
			warn "Local: no ~/.ssh/ directory"
		fi

		if check_ssd && [[ -d "$SSH_BACKUP_DIR" ]]; then
			local ssh_count
			ssh_count=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "SSD: $ssh_count age-encrypted backup(s)"
		fi

		if command -v bw &>/dev/null; then
			info "Bitwarden: available"
		fi

		echo ""

		local choice
		choice=$(gum choose \
			--header "SSH key operations:" \
			--height 10 \
			"Backup to SSD (age)" \
			"Backup to Bitwarden" \
			"Restore from SSD (age)" \
			"Restore from Bitwarden" \
			"Setup SSH on Remote Server" \
			"Dry Run (SSD)" \
			"Back" \
		) || return 0

		case "$choice" in
			"Backup to SSD (age)")
				echo ""
				if gum confirm "Encrypt SSH keys and save to SSD?"; then
					echo ""
					"$DEV_ENV/secrets" ssh backup
				fi
				pause
				;;
			"Backup to Bitwarden")
				echo ""
				if gum confirm "Store SSH keys in Bitwarden vault?"; then
					echo ""
					"$DEV_ENV/secrets" ssh backup --bw
				fi
				pause
				;;
			"Restore from SSD (age)")
				do_ssh_restore_age
				;;
			"Restore from Bitwarden")
				echo ""
				if gum confirm "Restore SSH keys from Bitwarden?"; then
					echo ""
					"$DEV_ENV/secrets" ssh restore --bw
				fi
				pause
				;;
			"Setup SSH on Remote Server")
				do_ssh_setup_guide
				;;
			"Dry Run (SSD)")
				echo ""
				"$DEV_ENV/secrets" ssh backup --dry
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

do_ssh_setup_guide() {
	while true; do
		clear
		header "Setup SSH on Remote Server"

		# Detect available keys
		local keys=()
		for f in "$HOME/.ssh"/id_*.pub; do
			[[ -f "$f" ]] && keys+=("$f")
		done

		if [[ ${#keys[@]} -gt 0 ]]; then
			info "Found ${#keys[@]} public key(s):"
			for k in "${keys[@]}"; do
				gum style --foreground 78 "  $(basename "$k")"
			done
		else
			warn "No SSH keys found in ~/.ssh/"
		fi
		echo ""

		local choice
		choice=$(gum choose \
			--header "What would you like to do?" \
			--height 8 \
			"Copy key to server (ssh-copy-id)" \
			"Test connection" \
			"View reference guide" \
			"Back" \
		) || return 0

		case "$choice" in
			"Copy key to server (ssh-copy-id)")
				if [[ ${#keys[@]} -eq 0 ]]; then
					error "No public keys found. Generate one first:"
					gum style --foreground 78 "  ssh-keygen -t ed25519"
					pause
					continue
				fi

				# Pick key if multiple
				local selected_key
				if [[ ${#keys[@]} -eq 1 ]]; then
					selected_key="${keys[0]}"
				else
					selected_key=$(printf '%s\n' "${keys[@]}" | xargs -I{} basename {} | gum choose --header "Select public key:") || continue
					selected_key="$HOME/.ssh/$selected_key"
				fi

				# Get user@host
				local remote
				remote=$(gum input \
					--header "Enter user@host (e.g. deploy@192.168.1.100):" \
					--placeholder "user@server" \
				) || continue

				if [[ -z "$remote" ]]; then
					error "No remote specified"
					pause
					continue
				fi

				echo ""
				info "Copying $(basename "$selected_key") → $remote"
				echo ""
				ssh-copy-id -i "$selected_key" "$remote"
				echo ""
				success "Done! Test with: ssh $remote"
				pause
				;;
			"Test connection")
				local remote
				remote=$(gum input \
					--header "Enter connection to test (e.g. user@server or git@github.com):" \
					--placeholder "user@server" \
				) || continue

				if [[ -z "$remote" ]]; then
					continue
				fi

				echo ""
				info "Testing connection to $remote..."
				echo ""
				if [[ "$remote" == *"github.com"* ]]; then
					ssh -T "$remote" 2>&1 || true
				else
					ssh -o ConnectTimeout=5 "$remote" echo "Connection successful" 2>&1 || true
				fi
				pause
				;;
			"View reference guide")
				clear
				header "SSH Reference Guide"

				gum style --foreground 212 --bold "  Generate a new key:"
				gum style --foreground 78 "  ssh-keygen -t ed25519 -C \"your_email@example.com\""
				echo ""

				divider

				gum style --foreground 212 --bold "  Copy key to server:"
				gum style --foreground 78 "  ssh-copy-id -i ~/.ssh/id_ed25519.pub user@server"
				echo ""

				divider

				gum style --foreground 212 --bold "  Manual copy (if ssh-copy-id unavailable):"
				gum style --foreground 240 "  1. Copy your public key:"
				gum style --foreground 78 "     cat ~/.ssh/id_ed25519.pub"
				gum style --foreground 240 "  2. On the remote server:"
				gum style --foreground 78 "     mkdir -p ~/.ssh && chmod 700 ~/.ssh"
				gum style --foreground 78 "     echo 'PASTE_KEY_HERE' >> ~/.ssh/authorized_keys"
				gum style --foreground 78 "     chmod 600 ~/.ssh/authorized_keys"
				echo ""

				divider

				gum style --foreground 212 --bold "  ~/.ssh/config shortcut:"
				gum style --foreground 78 "  Host myserver"
				gum style --foreground 78 "      HostName 192.168.1.100"
				gum style --foreground 78 "      User deploy"
				gum style --foreground 78 "      IdentityFile ~/.ssh/id_ed25519"
				echo ""
				gum style --foreground 240 "  Then connect with: ssh myserver"

				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

do_ssh_restore_age() {
	if ! mountpoint -q "$SSD" 2>/dev/null; then
		error "SSD not mounted"
		pause
		return
	fi

	if [[ ! -d "$SSH_BACKUP_DIR" ]]; then
		error "No SSH backups found on SSD"
		pause
		return
	fi

	local backups=() labels=()
	mapfile -t backups < <(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort)

	if [[ ${#backups[@]} -eq 0 ]]; then
		error "No SSH backups found"
		pause
		return
	fi

	for b in "${backups[@]}"; do
		local size
		size=$(du -sh "$b" 2>/dev/null | cut -f1)
		labels+=("$(basename "$b")  ($size)")
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--header "Select backup to restore:" \
		--height 10 \
	) || return 0

	echo ""
	warn "Will restore SSH keys from SSD"
	warn "Existing keys backed up to ~/.ssh.bak.*"
	echo ""

	if gum confirm "Restore SSH keys?"; then
		echo ""
		"$DEV_ENV/secrets" ssh restore
	fi
	pause
}

get_project_alias() {
	local dirname="$1"
	if [[ -f "$ENV_ALIAS_FILE" ]]; then
		local alias
		alias=$(grep "^${dirname}=" "$ENV_ALIAS_FILE" 2>/dev/null | head -1 | cut -d= -f2-)
		if [[ -n "$alias" ]]; then
			echo "$alias"
			return
		fi
	fi
	echo "$dirname"
}

env_projects() {
	# Discover projects that contain .env* files
	local projects=()
	for d in "$PROJECTS_DIR"/*/; do
		[[ -d "$d" ]] || continue
		local name
		name=$(basename "$d")
		[[ "$name" == ".git" || "$name" == "node_modules" || "$name" == ".cache" ]] && continue
		[[ "$name" == ".ror" || "$name" == ".playwright-mcp" ]] && continue
		local has_env=0
		while read -r f; do
			[[ -f "$f" ]] && { has_env=1; break; }
		done < <(find "$d" -maxdepth 3 \
			\( -name ".env" -o -name ".env.local" -o -name ".env.production" -o -name ".env.development" \) \
			2>/dev/null | grep -v node_modules | grep -v .git/ | grep -v __pycache__ | grep -v .venv | grep -v .conda | head -1)
		[[ $has_env -eq 1 ]] && projects+=("$name")
	done
	printf '%s\n' "${projects[@]}"
}

pick_env_project() {
	local header="${1:-Select project:}"
	local projects
	mapfile -t projects < <(env_projects)
	if [[ ${#projects[@]} -eq 0 ]]; then
		error "No projects with .env files found"
		return 1
	fi
	# Build display labels: "Alias (dirname)" or just "dirname"
	local labels=()
	for p in "${projects[@]}"; do
		local alias
		alias=$(get_project_alias "$p")
		if [[ "$alias" != "$p" ]]; then
			labels+=("$alias ($p)")
		else
			labels+=("$p")
		fi
	done
	local selection
	selection=$(printf '%s\n' "${labels[@]}" | gum choose --header "$header" --height 15) || return 1
	# Extract dirname: if selection has parentheses, grab the dirname from inside
	local re='\(([^)]+)\)$'
	if [[ "$selection" =~ $re ]]; then
		echo "${BASH_REMATCH[1]}"
	else
		echo "$selection"
	fi
}

menu_secrets_env() {
	while true; do
		clear
		header "Env Files"

		# Show .env count
		local env_count=0
		while read -r f; do
			[[ -f "$f" ]] && env_count=$(( env_count + 1 ))
		done < <(find "$PROJECTS_DIR" -maxdepth 4 \
			\( -name ".env" -o -name ".env.local" -o -name ".env.production" -o -name ".env.development" \) \
			2>/dev/null | grep -v node_modules | grep -v .git/ | grep -v __pycache__ | grep -v .venv | grep -v .conda)

		info "Local: $env_count .env file(s) in projects"

		if check_ssd && [[ -d "$ENV_BACKUP_DIR" ]]; then
			local backup_count
			backup_count=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "SSD: $backup_count age-encrypted backup(s)"
		fi

		if command -v bw &>/dev/null; then
			info "Bitwarden: available"
		fi

		echo ""

		local choice
		choice=$(gum choose \
			--header "Env file operations:" \
			--height 17 \
			"Backup All (SSD)" \
			"Backup All (Bitwarden)" \
			"Backup Project (SSD)" \
			"Backup Project (Bitwarden)" \
			"Restore All (SSD)" \
			"Restore All (Bitwarden)" \
			"Restore Project (SSD)" \
			"Restore Project (Bitwarden)" \
			"Copy Env (cross-project)" \
			"List Env Files" \
			"List Project Env Files" \
			"Manage Aliases" \
			"Dry Run (SSD)" \
			"Back" \
		) || return 0

		case "$choice" in
			"Backup All (SSD)")
				echo ""
				if gum confirm "Encrypt all .env files and save to SSD?"; then
					echo ""
					"$DEV_ENV/secrets" env backup
				fi
				pause
				;;
			"Backup All (Bitwarden)")
				echo ""
				if gum confirm "Store all .env files in Bitwarden vault?"; then
					echo ""
					"$DEV_ENV/secrets" env backup --bw
				fi
				pause
				;;
			"Backup Project (SSD)")
				local proj
				proj=$(pick_env_project "Select project to backup (SSD):") || { pause; continue; }
				echo ""
				if gum confirm "Encrypt $proj .env files to SSD?"; then
					echo ""
					"$DEV_ENV/secrets" env backup "$proj"
				fi
				pause
				;;
			"Backup Project (Bitwarden)")
				local proj
				proj=$(pick_env_project "Select project to backup (Bitwarden):") || { pause; continue; }
				echo ""
				if gum confirm "Store $proj .env files in Bitwarden?"; then
					echo ""
					"$DEV_ENV/secrets" env backup "$proj" --bw
				fi
				pause
				;;
			"Restore All (SSD)")
				echo ""
				if gum confirm "Restore all .env files from SSD?"; then
					echo ""
					"$DEV_ENV/secrets" env restore
				fi
				pause
				;;
			"Restore All (Bitwarden)")
				echo ""
				if gum confirm "Restore all .env files from Bitwarden?"; then
					echo ""
					"$DEV_ENV/secrets" env restore --bw
				fi
				pause
				;;
			"Restore Project (SSD)")
				local proj
				proj=$(pick_env_project "Select project to restore (SSD):") || { pause; continue; }
				echo ""
				if gum confirm "Restore $proj .env files from SSD?"; then
					echo ""
					"$DEV_ENV/secrets" env restore "$proj"
				fi
				pause
				;;
			"Restore Project (Bitwarden)")
				local proj
				proj=$(pick_env_project "Select project to restore (Bitwarden):") || { pause; continue; }
				echo ""
				if gum confirm "Restore $proj .env files from Bitwarden?"; then
					echo ""
					"$DEV_ENV/secrets" env restore "$proj" --bw
				fi
				pause
				;;
			"Copy Env (cross-project)")
				local src_proj dest_proj
				src_proj=$(pick_env_project "Select SOURCE project:") || { pause; continue; }
				dest_proj=$(pick_env_project "Select DESTINATION project:") || { pause; continue; }
				if [[ "$src_proj" == "$dest_proj" ]]; then
					error "Source and destination are the same"
					pause
					continue
				fi
				echo ""
				if gum confirm "Copy .env from $src_proj → $dest_proj (via SSD backup)?"; then
					echo ""
					"$DEV_ENV/secrets" env restore "$src_proj" --to "$dest_proj"
				fi
				pause
				;;
			"List Env Files")
				echo ""
				"$DEV_ENV/secrets" env list
				pause
				;;
			"List Project Env Files")
				local proj
				proj=$(pick_env_project "Select project to list:") || { pause; continue; }
				echo ""
				"$DEV_ENV/secrets" env list "$proj"
				pause
				;;
			"Manage Aliases")
				do_manage_aliases
				;;
			"Dry Run (SSD)")
				echo ""
				"$DEV_ENV/secrets" env backup --dry
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

do_manage_aliases() {
	while true; do
		clear
		header "Manage Aliases"

		local choice
		choice=$(gum choose \
			--header "Alias operations:" \
			--height 7 \
			"View Aliases" \
			"Set Alias" \
			"Remove Alias" \
			"Back" \
		) || return 0

		case "$choice" in
			"View Aliases")
				echo ""
				if [[ -f "$ENV_ALIAS_FILE" ]] && [[ -s "$ENV_ALIAS_FILE" ]]; then
					info "Current aliases ($ENV_ALIAS_FILE):"
					echo ""
					while IFS='=' read -r dirname alias; do
						[[ -z "$dirname" || "$dirname" == \#* ]] && continue
						success "  $dirname = $alias"
					done < "$ENV_ALIAS_FILE"
				else
					warn "No aliases set"
				fi
				pause
				;;
			"Set Alias")
				# Pick from all env projects (show raw dirnames for clarity)
				local projects
				mapfile -t projects < <(env_projects)
				if [[ ${#projects[@]} -eq 0 ]]; then
					error "No projects with .env files found"
					pause
					continue
				fi
				# Show current alias next to each project
				local labels=()
				for p in "${projects[@]}"; do
					local current
					current=$(get_project_alias "$p")
					if [[ "$current" != "$p" ]]; then
						labels+=("$p  (current: $current)")
					else
						labels+=("$p")
					fi
				done
				echo ""
				local selected
				selected=$(printf '%s\n' "${labels[@]}" | gum choose \
					--header "Select project to alias:" \
					--height 15 \
				) || { continue; }
				local dirname
				dirname=$(echo "$selected" | awk '{print $1}')
				local current_alias
				current_alias=$(get_project_alias "$dirname")
				local placeholder=""
				[[ "$current_alias" != "$dirname" ]] && placeholder="$current_alias"
				local new_alias
				new_alias=$(gum input \
					--header "Display name for $dirname:" \
					--placeholder "${placeholder:-Enter alias}" \
					--value "$placeholder" \
				) || { continue; }
				if [[ -z "$new_alias" ]]; then
					warn "Empty alias — skipped"
					pause
					continue
				fi
				# Write alias to file
				mkdir -p "$(dirname "$ENV_ALIAS_FILE")"
				if [[ -f "$ENV_ALIAS_FILE" ]] && grep -q "^${dirname}=" "$ENV_ALIAS_FILE" 2>/dev/null; then
					# Update existing entry
					sed -i "s|^${dirname}=.*|${dirname}=${new_alias}|" "$ENV_ALIAS_FILE"
				else
					echo "${dirname}=${new_alias}" >> "$ENV_ALIAS_FILE"
				fi
				echo ""
				success "Alias set: $dirname = $new_alias"
				pause
				;;
			"Remove Alias")
				if [[ ! -f "$ENV_ALIAS_FILE" ]] || [[ ! -s "$ENV_ALIAS_FILE" ]]; then
					warn "No aliases to remove"
					pause
					continue
				fi
				local aliases=()
				while IFS='=' read -r dirname alias; do
					[[ -z "$dirname" || "$dirname" == \#* ]] && continue
					aliases+=("$dirname = $alias")
				done < "$ENV_ALIAS_FILE"
				if [[ ${#aliases[@]} -eq 0 ]]; then
					warn "No aliases to remove"
					pause
					continue
				fi
				echo ""
				local selected
				selected=$(printf '%s\n' "${aliases[@]}" | gum choose \
					--header "Select alias to remove:" \
					--height 10 \
				) || { continue; }
				local dirname
				dirname=$(echo "$selected" | cut -d' ' -f1)
				sed -i "/^${dirname}=/d" "$ENV_ALIAS_FILE"
				echo ""
				success "Removed alias for $dirname"
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

do_ssh_view() {
	clear
	header "Local SSH Keys"

	if [[ ! -d "$HOME/.ssh" ]]; then
		warn "No ~/.ssh/ directory"
		pause
		return
	fi

	for f in "$HOME/.ssh"/*; do
		[[ -e "$f" ]] || continue
		local name perms size
		name=$(basename "$f")
		perms=$(stat -c '%a' "$f")
		size=$(du -sh "$f" 2>/dev/null | cut -f1)

		case "$name" in
			id_*|*.pem)
				if [[ "$name" == *.pub ]]; then
					success "  $name  ($perms)  $size  [public key]"
				else
					info "  $name  ($perms)  $size  [private key]"
				fi
				;;
			config)       info "  $name  ($perms)  $size  [ssh config]" ;;
			known_hosts)  info "  $name  ($perms)  $size  [known hosts]" ;;
			known_hosts.old) gum style --foreground 240 "  $name  ($perms)  $size" ;;
			*)            info "  $name  ($perms)  $size" ;;
		esac
	done

	pause
}

# -----------------------------------------------------------------------
# Settings
# -----------------------------------------------------------------------
menu_settings() {
	while true; do
		clear
		header "Settings"

		info "Config file: $DEV_ENV_CONFIG_FILE"
		echo ""

		local choice
		choice=$(gum choose \
			--header "Settings:" \
			--height 9 \
			"Change SSD Path" \
			"Change Projects Directory" \
			"Change Sources" \
			"View Config File" \
			"Reset to Defaults" \
			"Back" \
		) || return 0

		case "$choice" in
			"Change SSD Path")
				local new_val
				new_val=$(gum input --header "SSD mount path:" --value "$SSD") || continue
				if [[ -n "$new_val" ]]; then
					save_config "SSD_PATH" "$new_val"
					load_config
					success "SSD path set to: $SSD"
					pause
				fi
				;;
			"Change Projects Directory")
				local new_val
				new_val=$(gum input --header "Projects directory:" --value "$PROJECTS_DIR") || continue
				if [[ -n "$new_val" ]]; then
					save_config "PROJECTS_DIR" "$new_val"
					load_config
					success "Projects directory set to: $PROJECTS_DIR"
					pause
				fi
				;;
			"Change Sources")
				local current_sources
				current_sources=$(IFS=','; echo "${SOURCES[*]}")
				local new_val
				new_val=$(gum input --header "Sources (comma-separated):" --value "$current_sources") || continue
				if [[ -n "$new_val" ]]; then
					save_config "SOURCES" "$new_val"
					load_config
					success "Sources set to: ${SOURCES[*]}"
					pause
				fi
				;;
			"View Config File")
				echo ""
				if [[ -f "$DEV_ENV_CONFIG_FILE" ]]; then
					gum style --foreground 240 "  $DEV_ENV_CONFIG_FILE:"
					echo ""
					while IFS= read -r line; do
						info "  $line"
					done < "$DEV_ENV_CONFIG_FILE"
				else
					warn "No config file found"
				fi
				pause
				;;
			"Reset to Defaults")
				if gum confirm "Reset all settings to defaults?"; then
					rm -f "$DEV_ENV_CONFIG_FILE"
					load_config
					success "Config reset to defaults"
					pause
				fi
				;;
			"Back") return 0 ;;
		esac
	done
}

# -----------------------------------------------------------------------
# Status
# -----------------------------------------------------------------------
menu_status() {
	clear
	header "System Status"

	# SSD
	divider
	gum style --foreground 212 --bold "  SSD"
	if mountpoint -q "$SSD" 2>/dev/null; then
		local fs total used free pct
		fs=$(df -Th "$SSD" | awk 'NR==2 {print $2}')
		total=$(df -h "$SSD" | awk 'NR==2 {print $2}')
		used=$(df -h "$SSD" | awk 'NR==2 {print $3}')
		free=$(df -h "$SSD" | awk 'NR==2 {print $4}')
		pct=$(df "$SSD" | awk 'NR==2 {print $5}')
		info "Mount:       $SSD"
		info "Filesystem:  $fs"
		info "Size:        $total"
		info "Used:        $used ($pct)"
		info "Free:        $free"
	else
		error "Not mounted"
	fi

	echo ""

	# Backups
	divider
	gum style --foreground 212 --bold "  Backups"
	if mountpoint -q "$SSD" 2>/dev/null; then
		local backups
		mapfile -t backups < <(backup_list)
		if [[ ${#backups[@]} -gt 0 ]]; then
			info "Count: ${#backups[@]}"
			for b in "${backups[@]}"; do
				local size contents
				size=$(du -sh "$b" 2>/dev/null | cut -f1)
				contents=$(ls -1 "$b" 2>/dev/null | tr '\n' ', ' | sed 's/,$//')
				info "  $(basename "$b")  $size  [$contents]"
			done
		else
			warn "No backups found"
		fi
	else
		warn "SSD not mounted"
	fi

	echo ""

	# System
	divider
	gum style --foreground 212 --bold "  System"
	info "CPU:    $(lscpu | grep 'Model name' | sed 's/.*: *//')"
	info "Cores:  $(nproc) threads"
	info "rsync:  $(rsync --version | head -1 | awk '{print $3}')"
	info "gum:    $(gum --version 2>&1 | awk '{print $NF}')"

	echo ""

	# Dev repo
	divider
	gum style --foreground 212 --bold "  Dev Repo"
	info "Path: $DEV_ENV"
	local git_status
	git_status=$(cd "$DEV_ENV" && git status --porcelain 2>/dev/null | wc -l)
	if [[ "$git_status" -eq 0 ]]; then
		success "Clean (no uncommitted changes)"
	else
		warn "$git_status uncommitted change(s)"
	fi
	local branch
	branch=$(cd "$DEV_ENV" && git branch --show-current 2>/dev/null)
	info "Branch: $branch"

	echo ""

	# Secrets
	divider
	gum style --foreground 212 --bold "  Secrets"
	if mountpoint -q "$SSD" 2>/dev/null; then
		local ssh_bk=0 env_bk=0
		[[ -d "$SSH_BACKUP_DIR" ]] && ssh_bk=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
		[[ -d "$ENV_BACKUP_DIR" ]] && env_bk=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
		info "SSD SSH backups: $ssh_bk"
		info "SSD env backups: $env_bk"
	else
		warn "SSD not mounted"
	fi
	if command -v bw &>/dev/null; then
		local bw_st
		bw_st=$(bw status 2>/dev/null | jq -r '.status' 2>/dev/null || echo "unknown")
		info "Bitwarden: $bw_st"
	else
		info "Bitwarden: not installed"
	fi

	echo ""

	# Tools
	divider
	gum style --foreground 212 --bold "  Installed Tools"
	local tool_count
	tool_count=$(find "$DEV_ENV/runs" -mindepth 1 -maxdepth 1 -executable 2>/dev/null | wc -l)
	info "$tool_count tool scripts in runs/"

	pause
}

# -----------------------------------------------------------------------
# First-run wizard
# -----------------------------------------------------------------------
first_run_wizard() {
	if [[ -f "$DEV_ENV_CONFIG_FILE" ]]; then
		return
	fi

	clear
	header "Welcome to Dev Environment"

	gum style --foreground 240 "  First time setup — configure your defaults."
	echo ""

	# SSD path
	local ssd_path
	ssd_path=$(gum input \
		--header "SSD mount path:" \
		--value "$_DEFAULT_SSD_PATH" \
		--placeholder "/run/media/$USER/TRANSCEND" \
	) || ssd_path="$_DEFAULT_SSD_PATH"
	[[ -z "$ssd_path" ]] && ssd_path="$_DEFAULT_SSD_PATH"

	# Projects directory
	local projects_dir
	projects_dir=$(gum input \
		--header "Projects directory:" \
		--value "$_DEFAULT_PROJECTS_DIR" \
		--placeholder "$HOME/Personal" \
	) || projects_dir="$_DEFAULT_PROJECTS_DIR"
	[[ -z "$projects_dir" ]] && projects_dir="$_DEFAULT_PROJECTS_DIR"

	# Sources
	local sources
	sources=$(gum input \
		--header "Source directories to backup (comma-separated):" \
		--value "$_DEFAULT_SOURCES" \
		--placeholder "Personal" \
	) || sources="$_DEFAULT_SOURCES"
	[[ -z "$sources" ]] && sources="$_DEFAULT_SOURCES"

	# Save config
	mkdir -p "$DEV_ENV_CONFIG_DIR"
	cat > "$DEV_ENV_CONFIG_FILE" <<-EOF
	SSD_PATH=$ssd_path
	PROJECTS_DIR=$projects_dir
	SOURCES=$sources
	EOF

	load_config

	echo ""
	success "Config saved to $DEV_ENV_CONFIG_FILE"
	pause
}

# -----------------------------------------------------------------------
# Entry point
# -----------------------------------------------------------------------
first_run_wizard
main_menu
