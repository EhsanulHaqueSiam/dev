#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------
# Interactive TUI for dev environment management
# Requires: gum (charmbracelet/gum)
# -----------------------------------------------------------------------

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"

if [ -z "${DEV_ENV:-}" ]; then
	DEV_ENV="$script_dir"
fi

source "$script_dir/lib/config.sh"

# -----------------------------------------------------------------------
# Check dependencies — auto-install gum if missing
# -----------------------------------------------------------------------
if ! command -v gum &>/dev/null; then
	echo "gum is required for the TUI but not installed."
	if command -v yay &>/dev/null; then
		echo "Installing gum..."
		yay -S --noconfirm --needed gum
	elif command -v pacman &>/dev/null; then
		echo "Installing gum..."
		sudo pacman -S --noconfirm --needed gum
	else
		echo "Install gum manually: https://github.com/charmbracelet/gum"
		exit 1
	fi
fi

# -----------------------------------------------------------------------
# Theme
# -----------------------------------------------------------------------
export GUM_CHOOSE_CURSOR_FOREGROUND="212"
export GUM_CHOOSE_SELECTED_FOREGROUND="212"
export GUM_CHOOSE_HEADER_FOREGROUND="240"
export GUM_CONFIRM_PROMPT_FOREGROUND="212"

# -----------------------------------------------------------------------
# Helpers
# -----------------------------------------------------------------------
header() {
	echo ""
	gum style \
		--foreground 212 --bold \
		--border double --border-foreground 240 \
		--padding "0 2" --margin "0 0" \
		"$1"
	echo ""
}

divider() {
	gum style --foreground 240 "$(printf '%.0s─' {1..50})"
}

info() {
	gum style --foreground 39 "  $1"
}

success() {
	gum style --foreground 78 "  $1"
}

warn() {
	gum style --foreground 214 "  $1"
}

error() {
	gum style --foreground 196 "  $1"
}

pause() {
	echo ""
	gum style --foreground 240 "  Press any key to continue..."
	read -rsn1
}

# -----------------------------------------------------------------------
# SSD status helper
# -----------------------------------------------------------------------
ssd_status() {
	if mountpoint -q "$SSD" 2>/dev/null; then
		local fs used total free pct
		fs=$(df -Th "$SSD" | awk 'NR==2 {print $2}')
		total=$(df -h "$SSD" | awk 'NR==2 {print $2}')
		used=$(df -h "$SSD" | awk 'NR==2 {print $3}')
		free=$(df -h "$SSD" | awk 'NR==2 {print $4}')
		pct=$(df "$SSD" | awk 'NR==2 {print $5}')
		echo "mounted  $fs  ${used}/${total} (${pct})  ${free} free"
	else
		echo "not mounted"
	fi
}

backup_list() {
	find "$BACKUP_ROOT" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | sort
}

latest_backup() {
	backup_list | tail -1
}

# -----------------------------------------------------------------------
# Main menu
# -----------------------------------------------------------------------
main_menu() {
	while true; do
		clear
		header "Dev Environment"

		local ssd_info
		ssd_info=$(ssd_status)
		info "SSD: $ssd_info"

		# Warn if backup is stale
		local backup_warning
		backup_warning=$(check_backup_age 7 2>/dev/null)
		if [[ -n "$backup_warning" ]]; then
			warn "$backup_warning"
		fi
		echo ""

		local choice
		choice=$(gum choose \
			--header "What would you like to do?" \
			--height 14 \
			"Install Tools" \
			"Deploy Configs" \
			"Skills" \
			"Backup to SSD" \
			"Restore from SSD" \
			"Secrets" \
			"Status" \
			"Live Dashboard" \
			"Settings" \
			"Quit" \
		) || continue

		case "$choice" in
			"Install Tools")  menu_install ;;
			"Deploy Configs") menu_deploy ;;
			"Skills")         menu_skills ;;
			"Backup to SSD")  menu_backup ;;
			"Restore from SSD") menu_restore ;;
			"Secrets")        menu_secrets ;;
			"Status")         menu_status ;;
			"Live Dashboard") live_dashboard 5 ;;
			"Settings")       menu_settings ;;
			"Quit")           return 0 ;;
		esac
	done
}

# -----------------------------------------------------------------------
# Install Tools
# -----------------------------------------------------------------------
tool_installed() {
	local tool="$1"
	case "$tool" in
		age)          command -v age &>/dev/null ;;
		atuin)        command -v atuin &>/dev/null ;;
		bat)          command -v bat &>/dev/null ;;
		bitwarden-cli) command -v bw &>/dev/null ;;
		bun)          command -v bun &>/dev/null ;;
		discord)      command -v discord &>/dev/null || pacman -Qi discord &>/dev/null ;;
		expressvpn)   command -v expressvpn &>/dev/null ;;
		eza)          command -v eza &>/dev/null ;;
		fnm)          command -v fnm &>/dev/null ;;
		gcalcli)      command -v gcalcli &>/dev/null ;;
		gemini)       command -v gemini &>/dev/null ;;
		ghostty)      command -v ghostty &>/dev/null ;;
		go)           command -v go &>/dev/null ;;
		gum)          command -v gum &>/dev/null ;;
		miniconda)    command -v conda &>/dev/null ;;
		neovim)       command -v nvim &>/dev/null ;;
		node)         command -v node &>/dev/null ;;
		nvidiaDriver) pacman -Qi nvidia &>/dev/null 2>&1 ;;
		ollama)       command -v ollama &>/dev/null ;;
		omarchy)      [[ -d "$HOME/.omarchy" ]] 2>/dev/null ;;
		python)       command -v python3 &>/dev/null ;;
		rust)         command -v rustc &>/dev/null ;;
		starship)     command -v starship &>/dev/null ;;
		ticktick)     command -v ticktick &>/dev/null || flatpak list 2>/dev/null | grep -qi ticktick ;;
		tldr)         command -v tldr &>/dev/null ;;
		tmux)         command -v tmux &>/dev/null ;;
		uv)           command -v uv &>/dev/null ;;
		xh)           command -v xh &>/dev/null ;;
		yazi)         command -v yazi &>/dev/null ;;
		zsh)          command -v zsh &>/dev/null ;;
		*)            command -v "$tool" &>/dev/null ;;
	esac
}

tool_version() {
	local tool="$1"
	case "$tool" in
		bun)       bun --version 2>/dev/null ;;
		go)        go version 2>/dev/null | awk '{print $3}' | sed 's/go//' ;;
		node)      node --version 2>/dev/null | sed 's/v//' ;;
		nvim|neovim) nvim --version 2>/dev/null | awk 'NR==1{gsub(/^v/,"",$2); print $2; exit}' ;;
		python)    python3 --version 2>/dev/null | awk '{print $2}' ;;
		rust)      rustc --version 2>/dev/null | awk '{print $2}' ;;
		tmux)      tmux -V 2>/dev/null | awk '{print $2}' ;;
		zsh)       zsh --version 2>/dev/null | awk '{print $2}' ;;
		gum)       gum --version 2>/dev/null | awk '{print $3}' ;;
		bat)       bat --version 2>/dev/null | awk '{print $2}' ;;
		bitwarden-cli) bw --version 2>/dev/null ;;
		eza)       eza --version 2>/dev/null | awk 'NR==2 {print $1}' | sed 's/v//' ;;
		starship)  starship --version 2>/dev/null | awk 'NR==1{print $2; exit}' ;;
		uv)        uv --version 2>/dev/null | awk '{print $2}' ;;
		xh)        xh --version 2>/dev/null | awk 'NR==1{print $2; exit}' ;;
		yazi)      yazi --version 2>/dev/null | awk '{print $2}' ;;
		age)       age --version 2>/dev/null | awk '{print $2}' | sed 's/v//' ;;
		atuin)     atuin --version 2>/dev/null | awk '{print $2}' ;;
		fnm)       fnm --version 2>/dev/null | sed 's/fnm //' ;;
		ollama)    ollama --version 2>/dev/null | awk '{print $NF}' ;;
		ghostty)   ghostty --version 2>/dev/null | awk 'NR==1{print $2; exit}' ;;
		*)         echo "" ;;
	esac
}

menu_install() {
	while true; do
		clear
		header "Install Tools"

		# Gather tool info
		local tools=() installed_count=0 total_count=0
		shopt -s nullglob
		for s in "$DEV_ENV"/runs/*; do
			[[ -x "$s" ]] || continue
			tools+=("$(basename "$s")")
			total_count=$(( total_count + 1 ))
		done
		shopt -u nullglob

		if [[ ${#tools[@]} -eq 0 ]]; then
			error "No tools found in runs/"
			pause
			return
		fi

		# Show tool status overview
		local installed_list=() missing_list=()
		for t in "${tools[@]}"; do
			if tool_installed "$t"; then
				local ver
				ver=$(tool_version "$t")
				installed_count=$(( installed_count + 1 ))
				if [[ -n "$ver" ]]; then
					installed_list+=("$t ($ver)")
				else
					installed_list+=("$t")
				fi
			else
				missing_list+=("$t")
			fi
		done

		gum style --foreground 240 "  Tools: $installed_count/$total_count installed"
		echo ""

		if [[ ${#missing_list[@]} -gt 0 ]]; then
			gum style --foreground 214 "  Not installed:"
			for t in "${missing_list[@]}"; do
				gum style --foreground 214 "    - $t"
			done
			echo ""
		fi

		local choice
		choice=$(gum choose \
			--header "Select mode:" \
			--height 8 \
			"Install All" \
			"Install Missing Only" \
			"Select Tools" \
			"View Installed" \
			"Dry Run (preview)" \
			"Back" \
		) || return 0

		case "$choice" in
			"Install All")
				echo ""
				if gum confirm "Install/update all $total_count tools?"; then
					echo ""
					"$DEV_ENV/run"
				fi
				pause
				;;
			"Install Missing Only")
				do_install_missing "${missing_list[@]}"
				;;
			"Select Tools")
				select_and_install "${tools[@]}"
				;;
			"View Installed")
				do_view_installed "${installed_list[@]}"
				;;
			"Dry Run (preview)")
				echo ""
				"$DEV_ENV/run" --dry
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

do_install_missing() {
	local missing=("$@")

	if [[ ${#missing[@]} -eq 0 ]]; then
		echo ""
		success "All tools already installed!"
		pause
		return
	fi

	echo ""
	gum style --foreground 214 "Missing tools to install:"
	for t in "${missing[@]}"; do
		info "  $t"
	done
	echo ""

	if gum confirm "Install ${#missing[@]} missing tool(s)?"; then
		echo ""
		for tool in "${missing[@]}"; do
			gum style --foreground 39 --bold "--- $tool ---"
			"$DEV_ENV/run" "$tool" || true
			echo ""
		done
		success "Done!"
	else
		warn "Cancelled"
	fi
	pause
}

select_and_install() {
	local tools=("$@")

	# Build labels with installed status
	local labels=()
	for t in "${tools[@]}"; do
		if tool_installed "$t"; then
			local ver
			ver=$(tool_version "$t")
			if [[ -n "$ver" ]]; then
				labels+=("$t  ✓ $ver")
			else
				labels+=("$t  ✓")
			fi
		else
			labels+=("$t  ✗ not installed")
		fi
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--no-limit \
		--header "Select tools (space to toggle, enter to confirm):" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	# Extract tool names (first word before spaces)
	local tool_names=()
	while read -r line; do
		tool_names+=("$(echo "$line" | awk '{print $1}')")
	done <<< "$selected"

	echo ""
	gum style --foreground 78 "Selected:"
	for t in "${tool_names[@]}"; do
		info "  $t"
	done
	echo ""

	if gum confirm "Install ${#tool_names[@]} selected tool(s)?"; then
		echo ""
		for tool in "${tool_names[@]}"; do
			gum style --foreground 39 --bold "--- $tool ---"
			"$DEV_ENV/run" "$tool" || true
			echo ""
		done
		success "Done!"
	else
		warn "Cancelled"
	fi
	pause
}

do_view_installed() {
	local installed=("$@")

	clear
	header "Installed Tools"

	if [[ ${#installed[@]} -eq 0 ]]; then
		warn "No tools installed"
		pause
		return
	fi

	gum style --foreground 240 "  ${#installed[@]} tools installed:"
	echo ""
	for t in "${installed[@]}"; do
		success "✓ $t"
	done
	pause
}

# -----------------------------------------------------------------------
# Skills — Claude Code skill library
# -----------------------------------------------------------------------
menu_skills() {
	local skills_lib="$DEV_ENV/skills-lib"

	while true; do
		clear
		header "Claude Code Skills"

		# Show library stats with provider count
		if [[ -d "$skills_lib" ]]; then
			local lib_count=0 provider_set=""
			for d in "$skills_lib"/*/; do
				[[ -d "$d" ]] || continue
				lib_count=$(( lib_count + 1 ))
				local p
				p="$(_skill_provider "$d")"
				if [[ ":$provider_set:" != *":$p:"* ]]; then
					provider_set="${provider_set:+$provider_set:}$p"
				fi
			done
			local prov_count=0
			IFS=':' read -ra _arr <<< "$provider_set"
			prov_count=${#_arr[@]}
			gum style --foreground 39 "  Library: ${lib_count} skills from ${prov_count} providers"
		else
			warn "  Library: not fetched — run Fetch first"
		fi

		# Show project stats
		local project_dir=".claude/skills"
		if [[ -d "$project_dir" ]]; then
			local proj_count=0
			for d in "$project_dir"/*/; do
				[[ -d "$d" ]] && proj_count=$(( proj_count + 1 ))
			done
			if [[ "$proj_count" -gt 0 ]]; then
				gum style --foreground 78 "  Project: ${proj_count} skill(s) installed"
			else
				gum style --foreground 240 "  Project: none installed"
			fi
		else
			gum style --foreground 240 "  Project: none installed"
		fi

		echo ""

		local choice
		choice=$(gum choose \
			--header "Skills management:" \
			--height 11 \
			--cursor "▸ " \
			--cursor.foreground "212" \
			"Install Skills" \
			"Remove Skills" \
			"View Installed" \
			"Search Library" \
			"Discover New Skills" \
			"Fetch / Update Library" \
			"Back" \
		) || return 0

		case "$choice" in
			"Install Skills")    do_skills_install ;;
			"Remove Skills")     do_skills_remove ;;
			"View Installed")    do_skills_installed ;;
			"Search Library")    do_skills_search ;;
			"Discover New Skills")
				info "Opening awesome-agent-skills catalog..."
				xdg-open "https://github.com/VoltAgent/awesome-agent-skills" 2>/dev/null &
				info "Updated daily with new community and official skills."
				pause
				;;
			"Fetch / Update Library")
				echo ""
				"$DEV_ENV/skills-fetch"
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

_skill_provider() {
	local source_file="$1/.source"
	if [[ -f "$source_file" ]]; then
		local repo
		repo=$(<"$source_file")
		case "$repo" in
			anthropics/*)            echo "anthropic" ;;
			vercel-labs/*)           echo "vercel" ;;
			cloudflare/*)            echo "cloudflare" ;;
			supabase/*)              echo "supabase" ;;
			google-labs-code/*)      echo "google" ;;
			huggingface/*)           echo "huggingface" ;;
			stripe/*)                echo "stripe" ;;
			callstackincubator/*)    echo "callstack" ;;
			expo/*)                  echo "expo" ;;
			better-auth/*)           echo "better-auth" ;;
			neondatabase/*)          echo "neon" ;;
			dmmulroy/*)              echo "dmmulroy" ;;
			hashicorp/*)             echo "hashicorp" ;;
			sanity-io/*)             echo "sanity" ;;
			remotion-dev/*)          echo "remotion" ;;
			WordPress/*)             echo "wordpress" ;;
			openai/*)                echo "openai" ;;
			ComposioHQ/*)            echo "composio" ;;
			obra/*)                  echo "obra" ;;
			coreyhaines31/*)         echo "coreyhaines" ;;
			BrianRWagner/*)          echo "brianwagner" ;;
			AgriciDaniel/*)          echo "agricidaniel" ;;
			wshuyi/*)                echo "wshuyi" ;;
			jthack/*)                echo "jthack" ;;
			lackeyjb/*)              echo "lackeyjb" ;;
			K-Dense-AI/*)            echo "k-dense-ai" ;;
			Orchestra-Research/*)    echo "orchestra" ;;
			*)                       echo "${repo%%/*}" ;;
		esac
	else
		echo "unknown"
	fi
}

_skill_description() {
	local skill_md="$1/SKILL.md"
	[[ -f "$skill_md" ]] || return 0
	local in_front=0 val=""
	while IFS= read -r line; do
		if [[ "$in_front" -eq 0 ]]; then
			[[ "$line" == "---" ]] && in_front=1
			continue
		fi
		[[ "$line" == "---" ]] && break
		if [[ "$line" =~ ^description: ]]; then
			val="${line#description:}"
			val="${val#"${val%%[![:space:]]*}"}"
			val="${val#\"}" ; val="${val%\"}"
			val="${val#\'}" ; val="${val%\'}"
			if [[ -z "$val" || "$val" == ">" || "$val" == "|" ]]; then
				val=""
				while IFS= read -r nextline; do
					if [[ "$nextline" =~ ^[[:space:]]+ ]]; then
						local trimmed="${nextline#"${nextline%%[![:space:]]*}"}"
						if [[ -z "$val" ]]; then
							val="$trimmed"
						else
							val="$val $trimmed"
						fi
					else
						break
					fi
				done
			fi
			break
		fi
	done < "$skill_md"
	echo "$val"
}

do_skills_install() {
	local skills_lib="$DEV_ENV/skills-lib"
	if [[ ! -d "$skills_lib" ]]; then
		error "Library not fetched. Run fetch first."
		pause
		return
	fi

	# Build filter labels: "provider/name · description"
	local labels=() names_map=()
	for d in "$skills_lib"/*/; do
		[[ -d "$d" && -f "$d/SKILL.md" ]] || continue
		local name provider desc label
		name="$(basename "$d")"
		provider="$(_skill_provider "$d")"
		desc="$(_skill_description "$d")"
		[[ ${#desc} -gt 55 ]] && desc="${desc:0:52}..."
		if [[ -n "$desc" ]]; then
			label="${provider}/${name} · ${desc}"
		else
			label="${provider}/${name}"
		fi
		labels+=("$label")
		names_map+=("$name")
	done

	if [[ ${#labels[@]} -eq 0 ]]; then
		error "No skills in library"
		pause
		return
	fi

	echo ""
	gum style --foreground 212 --bold "  Select skills to install"
	gum style --foreground 240 "  Type to filter by provider or skill name"
	echo ""

	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum filter \
		--no-limit \
		--header "space = select, enter = confirm:" \
		--height 20 \
		--placeholder "e.g. anthropic, react, terraform..." \
		--indicator "▸" \
		--indicator.foreground "212" \
		--match.foreground "78" \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	# Extract skill names from selected labels
	local install_names=()
	while IFS= read -r line; do
		# Parse "provider/name · desc" → extract name
		local prov_name="${line%% ·*}"
		local skill_name="${prov_name##*/}"
		install_names+=("$skill_name")
	done <<< "$selected"

	echo ""
	gum style --foreground 78 --bold "  Selected ${#install_names[@]} skill(s):"
	echo ""
	for n in "${install_names[@]}"; do
		# Find provider for display
		local prov=""
		if [[ -d "$skills_lib/$n" ]]; then
			prov="$(_skill_provider "$skills_lib/$n")"
		fi
		gum style --foreground 78 "    ▸ ${prov}/${n}"
	done
	echo ""

	if gum confirm "Install ${#install_names[@]} skill(s) into this project?"; then
		echo ""
		"$DEV_ENV/skills" install "${install_names[@]}"
	fi
	pause
}

do_skills_remove() {
	local project_dir=".claude/skills"
	if [[ ! -d "$project_dir" ]]; then
		warn "No skills installed in this project"
		pause
		return
	fi

	local labels=() names=()
	for d in "$project_dir"/*/; do
		[[ -d "$d" ]] || continue
		local name provider desc label
		name="$(basename "$d")"
		provider="$(_skill_provider "$d")"
		desc="$(_skill_description "$d")"
		[[ ${#desc} -gt 50 ]] && desc="${desc:0:47}..."
		if [[ -n "$desc" ]]; then
			label="${provider}/${name} · ${desc}"
		else
			label="${provider}/${name}"
		fi
		labels+=("$label")
		names+=("$name")
	done

	if [[ ${#labels[@]} -eq 0 ]]; then
		warn "No skills installed"
		pause
		return
	fi

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--no-limit \
		--header "Select skills to remove:" \
		--height 15 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	warn "Will remove:"
	while IFS= read -r line; do
		gum style --foreground 214 "    ${line}"
	done <<< "$selected"
	echo ""

	if gum confirm "Remove selected skill(s)?"; then
		echo ""
		while IFS= read -r line; do
			local prov_name="${line%% ·*}"
			local skill_name="${prov_name##*/}"
			"$DEV_ENV/skills" remove "$skill_name"
		done <<< "$selected"
	fi
	pause
}

do_skills_installed() {
	clear
	header "Installed Skills"

	local project_dir=".claude/skills"
	if [[ ! -d "$project_dir" ]]; then
		warn "No skills installed in this project."
		pause
		return
	fi

	# Group by provider
	declare -A groups
	local count=0
	for d in "$project_dir"/*/; do
		[[ -d "$d" ]] || continue
		local name provider
		name="$(basename "$d")"
		provider="$(_skill_provider "$d")"
		groups["$provider"]+="$name"$'\n'
		((count++)) || true
	done

	if [[ "$count" -eq 0 ]]; then
		warn "No skills installed in this project."
		pause
		return
	fi

	gum style --foreground 240 "  ${count} skill(s) in .claude/skills/"
	echo ""

	local sorted_providers
	sorted_providers=$(printf '%s\n' "${!groups[@]}" | sort)
	while IFS= read -r provider; do
		[[ -z "$provider" ]] && continue
		gum style --foreground 212 --bold "  $provider"
		while IFS= read -r name; do
			[[ -z "$name" ]] && continue
			local desc
			desc="$(_skill_description "$project_dir/$name")"
			[[ ${#desc} -gt 55 ]] && desc="${desc:0:52}..."
			if [[ -n "$desc" ]]; then
				gum style --foreground 78 "    $name" --foreground 240
				printf "      \033[38;5;240m%s\033[0m\n" "$desc"
			else
				gum style --foreground 78 "    $name"
			fi
		done <<< "${groups[$provider]}"
		echo ""
	done <<< "$sorted_providers"

	pause
}

do_skills_search() {
	local skills_lib="$DEV_ENV/skills-lib"
	if [[ ! -d "$skills_lib" ]]; then
		error "Library not fetched. Run fetch first."
		pause
		return
	fi

	local term
	term=$(gum input \
		--header "Search skills:" \
		--placeholder "e.g. react, terraform, seo..." \
		--prompt "▸ " \
		--prompt.foreground "212" \
	) || return 0

	if [[ -z "$term" ]]; then
		return
	fi

	echo ""
	local found=0
	for d in "$skills_lib"/*/; do
		[[ -d "$d" && -f "$d/SKILL.md" ]] || continue
		local name provider desc
		name="$(basename "$d")"
		provider="$(_skill_provider "$d")"
		desc="$(_skill_description "$d")"
		local haystack="$name $provider $desc"
		if echo "$haystack" | grep -qFi "$term"; then
			[[ ${#desc} -gt 50 ]] && desc="${desc:0:47}..."
			gum style --foreground 212 --bold "  ${provider}/${name}"
			if [[ -n "$desc" ]]; then
				gum style --foreground 240 "    ${desc}"
			fi
			echo ""
			((found++)) || true
		fi
	done

	if [[ "$found" -eq 0 ]]; then
		warn "No skills matching '$term'"
	else
		gum style --foreground 240 "  ${found} result(s)"
	fi
	pause
}


# -----------------------------------------------------------------------
# Deploy Configs
# -----------------------------------------------------------------------
config_status() {
	# Returns: "deployed" | "not_deployed" | "missing"
	local src="$1" dest="$2"
	if [[ ! -e "$src" && ! -d "$src" ]]; then
		echo "missing"
	elif [[ -e "$dest" ]]; then
		echo "deployed"
	else
		echo "not_deployed"
	fi
}

gather_configs() {
	# Outputs lines: type|name|src|dest|status
	local xdg="${XDG_CONFIG_HOME:-$HOME/.config}"

	# .config/ directories
	for dir in "$DEV_ENV"/env/.config/*/; do
		[[ -d "$dir" ]] || continue
		local name
		name=$(basename "$dir")
		local src="$DEV_ENV/env/.config/$name"
		local dest="$xdg/$name"
		local st
		st=$(config_status "$src" "$dest")
		echo "config|$name|$src|$dest|$st"
	done

	# .config/ standalone files (e.g. starship.toml)
	for file in "$DEV_ENV"/env/.config/*; do
		[[ -f "$file" ]] || continue
		local name
		name=$(basename "$file")
		local src="$file"
		local dest="$xdg/$name"
		local st
		st=$(config_status "$src" "$dest")
		echo "config|$name|$src|$dest|$st"
	done

	# .local/ files
	if [[ -d "$DEV_ENV/env/.local" ]]; then
		for dir in "$DEV_ENV"/env/.local/*/; do
			[[ -d "$dir" ]] || continue
			local dirname
			dirname=$(basename "$dir")
			for item in "$dir"*; do
				[[ -e "$item" ]] || continue
				local fname
				fname=$(basename "$item")
				local src="$item"
				local dest="$HOME/.local/$dirname/$fname"
				local st
				st=$(config_status "$src" "$dest")
				echo "local|.local/$dirname/$fname|$src|$dest|$st"
			done
		done
	fi

	# Home dotfiles (auto-detect any dotfile in env/)
	for file in "$DEV_ENV"/env/.*; do
		[[ -f "$file" ]] || continue
		local name
		name=$(basename "$file")
		[[ "$name" == "." || "$name" == ".." ]] && continue
		local src="$file"
		local dest="$HOME/$name"
		local st
		st=$(config_status "$src" "$dest")
		echo "dotfile|$name|$src|$dest|$st"
	done
}

menu_deploy() {
	while true; do
		clear
		header "Deploy Configs"

		# Gather config status
		local configs=()
		local deployed_count=0 not_deployed_count=0 total_count=0
		while IFS='|' read -r type name src dest status; do
			configs+=("$type|$name|$src|$dest|$status")
			total_count=$(( total_count + 1 ))
			case "$status" in
				deployed)     deployed_count=$(( deployed_count + 1 )) ;;
				not_deployed) not_deployed_count=$(( not_deployed_count + 1 )) ;;
			esac
		done < <(gather_configs)

		gum style --foreground 240 "  Configs: $deployed_count/$total_count deployed"
		if [[ $not_deployed_count -gt 0 ]]; then
			gum style --foreground 214 "  Not deployed: $not_deployed_count"
		fi
		echo ""

		local choice
		choice=$(gum choose \
			--header "Select mode:" \
			--height 11 \
			"Deploy All Configs" \
			"Deploy Missing Only" \
			"Select Configs" \
			"Compare Configs" \
			"Capture Config" \
			"Update All (re-capture)" \
			"View Status" \
			"Dry Run (preview)" \
			"Back" \
		) || return 0

		case "$choice" in
			"Deploy All Configs")
				echo ""
				if gum confirm "Deploy all $total_count configs?"; then
					echo ""
					"$DEV_ENV/dev-env"
				fi
				pause
				;;
			"Deploy Missing Only")
				do_deploy_unlinked "${configs[@]}"
				;;
			"Select Configs")
				do_deploy_select "${configs[@]}"
				;;
			"Compare Configs")
				echo ""
				"$DEV_ENV/dev-env" compare
				pause
				;;
			"Capture Config")
				local cap_path
				cap_path=$(gum input \
					--header "Path to capture (e.g. ~/.config/ghostty):" \
					--placeholder "~/.config/something" \
				) || continue
				if [[ -n "$cap_path" ]]; then
					echo ""
					"$DEV_ENV/dev-env" capture "$cap_path"
					pause
				fi
				;;
			"Update All (re-capture)")
				echo ""
				"$DEV_ENV/dev-env" update
				pause
				;;
			"View Status")
				do_view_config_status "${configs[@]}"
				;;
			"Dry Run (preview)")
				echo ""
				"$DEV_ENV/dev-env" --dry
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

deploy_single_config() {
	local type="$1" name="$2" src="$3" dest="$4"

	# Backup existing before replacing
	if [[ -e "$dest" ]]; then
		local backup_dir="$HOME/.config-backup/$(date +%Y%m%d-%H%M%S)"
		mkdir -p "$backup_dir"
		cp -r "$dest" "$backup_dir/$(basename "$dest")"
		info "  backed up: $dest"
		rm -rf "$dest"
	fi

	mkdir -p "$(dirname "$dest")"
	cp -r "$src" "$dest"
	success "  deployed: $name -> $dest"
}

do_deploy_unlinked() {
	local configs=("$@")
	local undeployed=()

	for entry in "${configs[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"
		if [[ "$status" == "not_deployed" ]]; then
			undeployed+=("$entry")
		fi
	done

	if [[ ${#undeployed[@]} -eq 0 ]]; then
		echo ""
		success "All configs already deployed!"
		pause
		return
	fi

	echo ""
	gum style --foreground 214 "Configs to deploy:"
	for entry in "${undeployed[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"
		info "  $name"
	done
	echo ""

	if gum confirm "Deploy ${#undeployed[@]} config(s)?"; then
		echo ""
		for entry in "${undeployed[@]}"; do
			IFS='|' read -r type name src dest status <<< "$entry"
			deploy_single_config "$type" "$name" "$src" "$dest"
		done
		echo ""
		success "Done!"
	else
		warn "Cancelled"
	fi
	pause
}

do_deploy_select() {
	local configs=("$@")

	# Build labels with status
	local labels=()
	for entry in "${configs[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"
		case "$status" in
			deployed)     labels+=("$name  ✓ deployed") ;;
			not_deployed) labels+=("$name  ✗ not deployed") ;;
			missing)      labels+=("$name  ? missing source") ;;
		esac
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--no-limit \
		--header "Select configs (space to toggle, enter to confirm):" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	# Match selected labels back to config entries
	local to_deploy=()
	while read -r line; do
		local sel_name
		sel_name=$(echo "$line" | awk '{print $1}')
		for entry in "${configs[@]}"; do
			IFS='|' read -r type name src dest status <<< "$entry"
			if [[ "$name" == "$sel_name" ]]; then
				to_deploy+=("$entry")
				break
			fi
		done
	done <<< "$selected"

	echo ""
	gum style --foreground 78 "Selected:"
	for entry in "${to_deploy[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"
		info "  $name"
	done
	echo ""

	if gum confirm "Deploy ${#to_deploy[@]} config(s)?"; then
		echo ""
		for entry in "${to_deploy[@]}"; do
			IFS='|' read -r type name src dest status <<< "$entry"
			deploy_single_config "$type" "$name" "$src" "$dest"
		done
		echo ""
		success "Done!"
	else
		warn "Cancelled"
	fi
	pause
}

do_view_config_status() {
	local configs=("$@")

	clear
	header "Config Status"

	local prev_type=""
	for entry in "${configs[@]}"; do
		IFS='|' read -r type name src dest status <<< "$entry"

		# Section headers
		if [[ "$type" != "$prev_type" ]]; then
			echo ""
			case "$type" in
				config)  gum style --foreground 212 --bold "  .config/ directories" ;;
				local)   gum style --foreground 212 --bold "  .local/ files" ;;
				dotfile) gum style --foreground 212 --bold "  Home dotfiles" ;;
			esac
			prev_type="$type"
		fi

		case "$status" in
			deployed)     success "  ✓ $name" ;;
			not_deployed) warn "  ✗ $name  (not deployed)" ;;
			missing)      gum style --foreground 240 "  ? $name  (source missing)" ;;
		esac
	done

	pause
}

# -----------------------------------------------------------------------
# Backup
# -----------------------------------------------------------------------
menu_backup() {
	while true; do
		if ! check_ssd; then
			clear
			header "Backup"
			error "SSD not mounted at $SSD"
			if gum confirm "Change SSD path?"; then
				local new_ssd
				new_ssd=$(gum input --header "Enter SSD mount path:" --value "$SSD") || { return 0; }
				if [[ -n "$new_ssd" ]] && mountpoint -q "$new_ssd" 2>/dev/null; then
					save_config "SSD_PATH" "$new_ssd"
					load_config
					success "SSD path updated to $SSD"
				else
					error "Path not mounted: $new_ssd"
					pause
					continue
				fi
			else
				return 0
			fi
		fi

		clear
		header "Backup to SSD"
		info "SSD: $(ssd_status)"

		# Show existing backups
		local backups
		mapfile -t backups < <(backup_list)
		if [[ ${#backups[@]} -gt 0 ]]; then
			echo ""
			gum style --foreground 240 "  Existing backups:"
			for b in "${backups[@]}"; do
				local size
				size=$(du -sh "$b" 2>/dev/null | cut -f1)
				info "  $(basename "$b")  $size"
			done
		fi

		echo ""

		# Show active SSD if multiple configured
		if [[ ${#SSD_LIST[@]} -gt 1 ]]; then
			gum style --foreground 240 "  Target: $SSD"
		fi

		local choice
		choice=$(gum choose \
			--header "Backup mode:" \
			--height 11 \
			"Quick Sync (incremental)" \
			"Full Backup (new snapshot)" \
			"Select Projects" \
			"Update Subfolder (in latest)" \
			"Verify Latest Backup" \
			"Switch Target SSD" \
			"Dry Run (preview)" \
			"Configure" \
			"Back" \
		) || return 0

		case "$choice" in
			"Quick Sync (incremental)")
				echo ""
				if gum confirm "Sync changed files to latest backup?"; then
					echo ""
					"$DEV_ENV/backup" --sync
				fi
				pause
				;;
			"Full Backup (new snapshot)")
				do_backup_full
				;;
			"Select Projects")
				do_backup_select
				;;
			"Update Subfolder (in latest)")
				do_backup_subfolder
				;;
			"Verify Latest Backup")
				echo ""
				"$DEV_ENV/backup" --verify
				pause
				;;
			"Switch Target SSD")
				do_switch_backup_ssd
				;;
			"Dry Run (preview)")
				echo ""
				"$DEV_ENV/backup" --dry
				pause
				;;
			"Configure")
				do_backup_configure
				;;
			"Back") return 0 ;;
		esac
	done
}

do_switch_backup_ssd() {
	if [[ ${#SSD_LIST[@]} -le 1 ]]; then
		warn "Only one SSD configured — add more in Settings > Manage SSDs"
		pause
		return
	fi
	local labels=()
	for p in "${SSD_LIST[@]}"; do
		local label="$p"
		if mountpoint -q "$p" 2>/dev/null; then
			local free
			free=$(df -h "$p" | awk 'NR==2 {print $4}')
			label="$p  (mounted, ${free} free)"
		else
			label="$p  (not mounted)"
		fi
		[[ "$p" == "$SSD" ]] && label="$label  [active]"
		labels+=("$label")
	done
	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--header "Select target SSD:" \
		--height 10 \
	) || return 0
	local new_ssd
	new_ssd=$(echo "$selected" | awk '{print $1}')
	switch_ssd "$new_ssd"
	success "Active SSD: $SSD"
	pause
}

do_backup_full() {
	echo ""
	if gum confirm "Run full backup of all sources?"; then
		echo ""
		"$DEV_ENV/backup"
		pause
	fi
}

do_backup_select() {
	# List available project directories in each source
	local projects=()
	for src in "${SOURCES[@]}"; do
		local src_path="$HOME/$src"
		[[ -d "$src_path" ]] || continue
		for d in "$src_path"/*/; do
			[[ -d "$d" ]] || continue
			local name
			name=$(basename "$d")
			# Skip common excludes
			[[ "$name" == ".git" || "$name" == "node_modules" || "$name" == ".cache" ]] && continue
			[[ "$name" == ".ror" || "$name" == ".playwright-mcp" ]] && continue
			projects+=("$src/$name")
		done
	done

	if [[ ${#projects[@]} -eq 0 ]]; then
		error "No projects found"
		pause
		return
	fi

	echo ""
	local selected
	selected=$(printf '%s\n' "${projects[@]}" | gum choose \
		--no-limit \
		--header "Select projects to backup (space to toggle):" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	gum style --foreground 78 "Selected for backup:"
	echo "$selected" | while read -r p; do
		info "  $p"
	done
	echo ""

	if gum confirm "Backup selected projects?"; then
		echo ""
		echo "$selected" | while read -r proj; do
			"$DEV_ENV/backup" "$proj"
		done
		pause
	fi
}

do_backup_subfolder() {
	local latest
	latest=$(latest_backup)
	if [[ -z "$latest" ]]; then
		error "No existing backup found — run a full backup first"
		pause
		return
	fi

	info "Will update: $(basename "$latest")"
	echo ""

	# List subfolders available for update
	local subfolders=()
	for src in "${SOURCES[@]}"; do
		local src_path="$HOME/$src"
		[[ -d "$src_path" ]] || continue
		for d in "$src_path"/*/; do
			[[ -d "$d" ]] || continue
			local name
			name=$(basename "$d")
			[[ "$name" == ".git" || "$name" == "node_modules" || "$name" == ".cache" ]] && continue
			[[ "$name" == ".ror" || "$name" == ".playwright-mcp" ]] && continue
			subfolders+=("$src/$name")
		done
	done

	local selected
	selected=$(printf '%s\n' "${subfolders[@]}" | gum choose \
		--no-limit \
		--header "Select subfolders to update in latest backup:" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	gum style --foreground 78 "Will update in $(basename "$latest"):"
	echo "$selected" | while read -r s; do
		info "  $s"
	done
	echo ""

	if gum confirm "Update selected subfolders?"; then
		echo ""
		echo "$selected" | while read -r sub; do
			"$DEV_ENV/backup" "$sub"
		done
		pause
	fi
}

do_backup_configure() {
	echo ""
	gum style --foreground 240 "  Current defaults are set in the backup script."
	gum style --foreground 240 "  You can override per-run with flags:"
	echo ""
	info "--keep N    retention count (default: 2)"
	info "--jobs N    parallel workers (default: 4)"
	echo ""
	info "Example: ./backup --keep 5 --jobs 8"
	pause
}

# -----------------------------------------------------------------------
# Restore
# -----------------------------------------------------------------------
menu_restore() {
	while true; do
		if ! check_ssd; then
			clear
			header "Restore"
			error "SSD not mounted at $SSD"
			if gum confirm "Change SSD path?"; then
				local new_ssd
				new_ssd=$(gum input --header "Enter SSD mount path:" --value "$SSD") || { return 0; }
				if [[ -n "$new_ssd" ]] && mountpoint -q "$new_ssd" 2>/dev/null; then
					save_config "SSD_PATH" "$new_ssd"
					load_config
					success "SSD path updated to $SSD"
				else
					error "Path not mounted: $new_ssd"
					pause
					continue
				fi
			else
				return 0
			fi
		fi

		clear
		header "Restore from SSD"

		local backups
		mapfile -t backups < <(backup_list)

		if [[ ${#backups[@]} -eq 0 ]]; then
			warn "No backups found on SSD"
			pause
			return
		fi

		# Show available backups
		gum style --foreground 240 "  Available backups:"
		for b in "${backups[@]}"; do
			local size contents
			size=$(du -sh "$b" 2>/dev/null | cut -f1)
			contents=$(ls -1 "$b" 2>/dev/null | tr '\n' ', ' | sed 's/,$//')
			info "$(basename "$b")  $size  [$contents]"
		done
		echo ""

		local choice
		choice=$(gum choose \
			--header "Restore mode:" \
			--height 9 \
			"Restore All from Latest" \
			"Restore Specific Projects" \
			"Restore Subfolder" \
			"Pick Individual Files" \
			"Choose Backup Version" \
			"Dry Run (preview)" \
			"Back" \
		) || return 0

		case "$choice" in
			"Restore All from Latest")
				do_restore_latest
				;;
			"Restore Specific Projects")
				do_restore_select_projects
				;;
			"Restore Subfolder")
				do_restore_subfolder
				;;
			"Pick Individual Files")
				echo ""
				"$DEV_ENV/restore" --pick
				pause
				;;
			"Choose Backup Version")
				do_restore_from_specific
				;;
			"Dry Run (preview)")
				do_restore_dry
				;;
			"Back") return 0 ;;
		esac
	done
}

do_restore_latest() {
	local latest
	latest=$(latest_backup)
	[[ -z "$latest" ]] && { error "No backup found"; pause; return; }

	local size
	size=$(du -sh "$latest" 2>/dev/null | cut -f1)

	echo ""
	warn "Restoring from: $(basename "$latest") ($size)"
	warn "This will overwrite files in your home directory"
	warn "Mode: safe merge (won't delete local files)"
	echo ""

	# List what's in the backup
	local targets=()
	for d in "$latest"/*/; do
		[[ -d "$d" ]] && targets+=("$(basename "$d")")
	done

	info "Contains: ${targets[*]}"
	echo ""

	if gum confirm "Restore all from latest backup?"; then
		echo ""
		for t in "${targets[@]}"; do
			echo "yes" | "$DEV_ENV/restore" "$t"
		done
		pause
	fi
}

do_restore_select_projects() {
	local latest
	latest=$(latest_backup)
	[[ -z "$latest" ]] && { error "No backup found"; pause; return; }

	# List available projects in backup
	local projects=()
	for d in "$latest"/*/; do
		[[ -d "$d" ]] && projects+=("$(basename "$d")")
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${projects[@]}" | gum choose \
		--no-limit \
		--header "Select projects to restore from $(basename "$latest"):" \
		--height 15 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	warn "Will restore from: $(basename "$latest")"
	echo "$selected" | while read -r p; do
		info "  $p"
	done
	echo ""

	if gum confirm "Restore selected projects?"; then
		echo ""
		echo "$selected" | while read -r proj; do
			echo "yes" | "$DEV_ENV/restore" "$proj"
		done
		pause
	fi
}

do_restore_subfolder() {
	local latest
	latest=$(latest_backup)
	[[ -z "$latest" ]] && { error "No backup found"; pause; return; }

	# Build list of subfolders in backup
	local subfolders=()
	for src_dir in "$latest"/*/; do
		[[ -d "$src_dir" ]] || continue
		local src_name
		src_name=$(basename "$src_dir")
		for sub_dir in "$src_dir"/*/; do
			[[ -d "$sub_dir" ]] || continue
			subfolders+=("$src_name/$(basename "$sub_dir")")
		done
	done

	if [[ ${#subfolders[@]} -eq 0 ]]; then
		error "No subfolders found in backup"
		pause
		return
	fi

	echo ""
	local selected
	selected=$(printf '%s\n' "${subfolders[@]}" | gum choose \
		--no-limit \
		--header "Select subfolders to restore from $(basename "$latest"):" \
		--height 20 \
	) || return 0

	if [[ -z "$selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	warn "Will restore subfolders from: $(basename "$latest")"
	echo "$selected" | while read -r s; do
		info "  $s"
	done
	echo ""

	if gum confirm "Restore selected subfolders?"; then
		echo ""
		echo "$selected" | while read -r sub; do
			echo "yes" | "$DEV_ENV/restore" "$sub"
		done
		pause
	fi
}

do_restore_from_specific() {
	local backups
	mapfile -t backups < <(backup_list)

	# Build selection list with sizes
	local labels=()
	for b in "${backups[@]}"; do
		local size
		size=$(du -sh "$b" 2>/dev/null | cut -f1)
		labels+=("$(basename "$b")  ($size)")
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--header "Choose backup:" \
		--height 10 \
	) || return 0

	# Extract timestamp from selection
	local ts
	ts=$(echo "$selected" | awk '{print $1}')

	local backup_dir="$BACKUP_ROOT/$ts"
	if [[ ! -d "$backup_dir" ]]; then
		error "Backup not found: $ts"
		pause
		return
	fi

	# List projects in that backup
	local projects=()
	for d in "$backup_dir"/*/; do
		[[ -d "$d" ]] && projects+=("$(basename "$d")")
	done

	local proj_selected
	proj_selected=$(printf '%s\n' "${projects[@]}" | gum choose \
		--no-limit \
		--header "Select projects to restore from $ts:" \
		--height 15 \
	) || return 0

	if [[ -z "$proj_selected" ]]; then
		warn "Nothing selected"
		pause
		return
	fi

	echo ""
	warn "Restoring from: $ts"
	echo "$proj_selected" | while read -r p; do
		info "  $p"
	done
	echo ""

	if gum confirm "Restore selected?"; then
		echo ""
		echo "$proj_selected" | while read -r proj; do
			echo "yes" | "$DEV_ENV/restore" --from "$ts" "$proj"
		done
		pause
	fi
}

do_restore_dry() {
	local latest
	latest=$(latest_backup)
	[[ -z "$latest" ]] && { error "No backup found"; pause; return; }

	# List projects in backup
	local projects=()
	for d in "$latest"/*/; do
		[[ -d "$d" ]] && projects+=("$(basename "$d")")
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${projects[@]}" | gum choose \
		--header "Select project for dry run preview:" \
		--height 10 \
	) || return 0

	echo ""
	"$DEV_ENV/restore" --dry "$selected"
	pause
}

# -----------------------------------------------------------------------
# Secrets (SSH Keys + .env files — age SSD + Bitwarden)
# -----------------------------------------------------------------------

menu_secrets() {
	while true; do
		clear
		header "Secrets"

		# SSH key status
		if [[ -d "$HOME/.ssh" ]]; then
			local key_count=0
			for f in "$HOME/.ssh"/id_*; do
				[[ -f "$f" && "$f" != *.pub ]] && key_count=$(( key_count + 1 ))
			done
			info "SSH: $key_count private key(s) in ~/.ssh/"
		else
			warn "SSH: no ~/.ssh/ directory"
		fi

		# SSD backup status
		if check_ssd; then
			local ssh_count=0 env_count=0
			[[ -d "$SSH_BACKUP_DIR" ]] && ssh_count=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			[[ -d "$ENV_BACKUP_DIR" ]] && env_count=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "SSD: $ssh_count SSH backup(s), $env_count env backup(s)"
		else
			error "SSD: not mounted"
		fi

		# Bitwarden status
		if command -v bw &>/dev/null; then
			local bw_status
			bw_status=$(bw status 2>/dev/null | jq -r '.status' 2>/dev/null || echo "unknown")
			info "Bitwarden: $bw_status"
		else
			gum style --foreground 240 "  Bitwarden: not installed"
		fi

		echo ""

		# Claude config status
		if [[ -f "$HOME/.claude.json" ]] && command -v jq &>/dev/null; then
			local mcp_count
			mcp_count=$(jq '.mcpServers | length' "$HOME/.claude.json" 2>/dev/null || echo "0")
			info "Claude: $mcp_count MCP server(s)"
		fi

		echo ""

		local choice
		choice=$(gum choose \
			--header "Secrets management:" \
			--height 11 \
			"SSH Keys" \
			"Env Files" \
			"Claude Config" \
			"Health Check" \
			"List All Secrets" \
			"View Local SSH Keys" \
			"Back" \
		) || return 0

		case "$choice" in
			"SSH Keys")        menu_secrets_ssh ;;
			"Env Files")       menu_secrets_env ;;
			"Claude Config")   menu_secrets_claude ;;
			"Health Check")
				echo ""
				"$DEV_ENV/secrets" --health
				pause
				;;
			"List All Secrets")
				echo ""
				"$DEV_ENV/secrets" --list
				pause
				;;
			"View Local SSH Keys") do_ssh_view ;;
			"Back") return 0 ;;
		esac
	done
}

menu_secrets_ssh() {
	while true; do
		clear
		header "SSH Keys"

		# Show current status
		if [[ -d "$HOME/.ssh" ]]; then
			local key_count=0
			for f in "$HOME/.ssh"/id_*; do
				[[ -f "$f" && "$f" != *.pub ]] && key_count=$(( key_count + 1 ))
			done
			info "Local: $key_count private key(s)"
		else
			warn "Local: no ~/.ssh/ directory"
		fi

		if check_ssd && [[ -d "$SSH_BACKUP_DIR" ]]; then
			local ssh_count
			ssh_count=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "SSD: $ssh_count age-encrypted backup(s)"
		fi

		if command -v bw &>/dev/null; then
			info "Bitwarden: available"
		fi

		echo ""

		local choice
		choice=$(gum choose \
			--header "SSH key operations:" \
			--height 10 \
			"Backup to SSD (age)" \
			"Backup to Bitwarden" \
			"Restore from SSD (age)" \
			"Restore from Bitwarden" \
			"Setup SSH on Remote Server" \
			"Dry Run (SSD)" \
			"Back" \
		) || return 0

		case "$choice" in
			"Backup to SSD (age)")
				echo ""
				if gum confirm "Encrypt SSH keys and save to SSD?"; then
					echo ""
					"$DEV_ENV/secrets" ssh backup
				fi
				pause
				;;
			"Backup to Bitwarden")
				echo ""
				if gum confirm "Store SSH keys in Bitwarden vault?"; then
					echo ""
					"$DEV_ENV/secrets" ssh backup --bw
				fi
				pause
				;;
			"Restore from SSD (age)")
				do_ssh_restore_age
				;;
			"Restore from Bitwarden")
				echo ""
				if gum confirm "Restore SSH keys from Bitwarden?"; then
					echo ""
					"$DEV_ENV/secrets" ssh restore --bw
				fi
				pause
				;;
			"Setup SSH on Remote Server")
				do_ssh_setup_guide
				;;
			"Dry Run (SSD)")
				echo ""
				"$DEV_ENV/secrets" ssh backup --dry
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

do_ssh_setup_guide() {
	while true; do
		clear
		header "Setup SSH on Remote Server"

		# Detect available keys
		local keys=()
		for f in "$HOME/.ssh"/id_*.pub; do
			[[ -f "$f" ]] && keys+=("$f")
		done

		if [[ ${#keys[@]} -gt 0 ]]; then
			info "Found ${#keys[@]} public key(s):"
			for k in "${keys[@]}"; do
				gum style --foreground 78 "  $(basename "$k")"
			done
		else
			warn "No SSH keys found in ~/.ssh/"
		fi
		echo ""

		local choice
		choice=$(gum choose \
			--header "What would you like to do?" \
			--height 8 \
			"Copy key to server (ssh-copy-id)" \
			"Test connection" \
			"View reference guide" \
			"Back" \
		) || return 0

		case "$choice" in
			"Copy key to server (ssh-copy-id)")
				if [[ ${#keys[@]} -eq 0 ]]; then
					error "No public keys found. Generate one first:"
					gum style --foreground 78 "  ssh-keygen -t ed25519"
					pause
					continue
				fi

				# Pick key if multiple
				local selected_key
				if [[ ${#keys[@]} -eq 1 ]]; then
					selected_key="${keys[0]}"
				else
					selected_key=$(printf '%s\n' "${keys[@]}" | xargs -I{} basename {} | gum choose --header "Select public key:") || continue
					selected_key="$HOME/.ssh/$selected_key"
				fi

				# Get user@host
				local remote
				remote=$(gum input \
					--header "Enter user@host (e.g. deploy@192.168.1.100):" \
					--placeholder "user@server" \
				) || continue

				if [[ -z "$remote" ]]; then
					error "No remote specified"
					pause
					continue
				fi

				echo ""
				info "Copying $(basename "$selected_key") → $remote"
				echo ""
				ssh-copy-id -i "$selected_key" "$remote"
				echo ""
				success "Done! Test with: ssh $remote"
				pause
				;;
			"Test connection")
				local remote
				remote=$(gum input \
					--header "Enter connection to test (e.g. user@server or git@github.com):" \
					--placeholder "user@server" \
				) || continue

				if [[ -z "$remote" ]]; then
					continue
				fi

				echo ""
				info "Testing connection to $remote..."
				echo ""
				if [[ "$remote" == *"github.com"* ]]; then
					ssh -T "$remote" 2>&1 || true
				else
					ssh -o ConnectTimeout=5 "$remote" echo "Connection successful" 2>&1 || true
				fi
				pause
				;;
			"View reference guide")
				clear
				header "SSH Reference Guide"

				gum style --foreground 212 --bold "  Generate a new key:"
				gum style --foreground 78 "  ssh-keygen -t ed25519 -C \"your_email@example.com\""
				echo ""

				divider

				gum style --foreground 212 --bold "  Copy key to server:"
				gum style --foreground 78 "  ssh-copy-id -i ~/.ssh/id_ed25519.pub user@server"
				echo ""

				divider

				gum style --foreground 212 --bold "  Manual copy (if ssh-copy-id unavailable):"
				gum style --foreground 240 "  1. Copy your public key:"
				gum style --foreground 78 "     cat ~/.ssh/id_ed25519.pub"
				gum style --foreground 240 "  2. On the remote server:"
				gum style --foreground 78 "     mkdir -p ~/.ssh && chmod 700 ~/.ssh"
				gum style --foreground 78 "     echo 'PASTE_KEY_HERE' >> ~/.ssh/authorized_keys"
				gum style --foreground 78 "     chmod 600 ~/.ssh/authorized_keys"
				echo ""

				divider

				gum style --foreground 212 --bold "  ~/.ssh/config shortcut:"
				gum style --foreground 78 "  Host myserver"
				gum style --foreground 78 "      HostName 192.168.1.100"
				gum style --foreground 78 "      User deploy"
				gum style --foreground 78 "      IdentityFile ~/.ssh/id_ed25519"
				echo ""
				gum style --foreground 240 "  Then connect with: ssh myserver"

				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

do_ssh_restore_age() {
	if ! mountpoint -q "$SSD" 2>/dev/null; then
		error "SSD not mounted"
		pause
		return
	fi

	if [[ ! -d "$SSH_BACKUP_DIR" ]]; then
		error "No SSH backups found on SSD"
		pause
		return
	fi

	local backups=() labels=()
	mapfile -t backups < <(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort)

	if [[ ${#backups[@]} -eq 0 ]]; then
		error "No SSH backups found"
		pause
		return
	fi

	for b in "${backups[@]}"; do
		local size
		size=$(du -sh "$b" 2>/dev/null | cut -f1)
		labels+=("$(basename "$b")  ($size)")
	done

	echo ""
	local selected
	selected=$(printf '%s\n' "${labels[@]}" | gum choose \
		--header "Select backup to restore:" \
		--height 10 \
	) || return 0

	echo ""
	warn "Will restore SSH keys from SSD"
	warn "Existing keys backed up to ~/.ssh.bak.*"
	echo ""

	if gum confirm "Restore SSH keys?"; then
		echo ""
		"$DEV_ENV/secrets" ssh restore
	fi
	pause
}

get_project_alias() {
	local dirname="$1"
	if [[ -f "$ENV_ALIAS_FILE" ]]; then
		local alias
		alias=$(grep "^${dirname}=" "$ENV_ALIAS_FILE" 2>/dev/null | head -1 | cut -d= -f2-)
		if [[ -n "$alias" ]]; then
			echo "$alias"
			return
		fi
	fi
	echo "$dirname"
}

env_projects() {
	# Discover projects that contain .env* files
	local projects=()
	for d in "$PROJECTS_DIR"/*/; do
		[[ -d "$d" ]] || continue
		local name
		name=$(basename "$d")
		[[ "$name" == ".git" || "$name" == "node_modules" || "$name" == ".cache" ]] && continue
		[[ "$name" == ".ror" || "$name" == ".playwright-mcp" ]] && continue
		local has_env=0
		while read -r f; do
			[[ -f "$f" ]] && { has_env=1; break; }
		done < <(find "$d" -maxdepth 3 \
			\( -name ".env" -o -name ".env.local" -o -name ".env.production" -o -name ".env.development" \) \
			2>/dev/null | grep -v node_modules | grep -v .git/ | grep -v __pycache__ | grep -v .venv | grep -v .conda | head -1)
		[[ $has_env -eq 1 ]] && projects+=("$name")
	done
	printf '%s\n' "${projects[@]}"
}

pick_env_project() {
	local header="${1:-Select project:}"
	local projects
	mapfile -t projects < <(env_projects)
	if [[ ${#projects[@]} -eq 0 ]]; then
		error "No projects with .env files found"
		return 1
	fi
	# Build display labels: "Alias (dirname)" or just "dirname"
	local labels=()
	for p in "${projects[@]}"; do
		local alias
		alias=$(get_project_alias "$p")
		if [[ "$alias" != "$p" ]]; then
			labels+=("$alias ($p)")
		else
			labels+=("$p")
		fi
	done
	local selection
	selection=$(printf '%s\n' "${labels[@]}" | gum choose --header "$header" --height 15) || return 1
	# Extract dirname: if selection has parentheses, grab the dirname from inside
	local re='\(([^)]+)\)$'
	if [[ "$selection" =~ $re ]]; then
		echo "${BASH_REMATCH[1]}"
	else
		echo "$selection"
	fi
}

menu_secrets_env() {
	while true; do
		clear
		header "Env Files"

		# Show .env count
		local env_count=0
		while read -r f; do
			[[ -f "$f" ]] && env_count=$(( env_count + 1 ))
		done < <(find "$PROJECTS_DIR" -maxdepth 4 \
			\( -name ".env" -o -name ".env.local" -o -name ".env.production" -o -name ".env.development" \) \
			2>/dev/null | grep -v node_modules | grep -v .git/ | grep -v __pycache__ | grep -v .venv | grep -v .conda)

		info "Local: $env_count .env file(s) in projects"

		if check_ssd && [[ -d "$ENV_BACKUP_DIR" ]]; then
			local backup_count
			backup_count=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "SSD: $backup_count age-encrypted backup(s)"
		fi

		if command -v bw &>/dev/null; then
			info "Bitwarden: available"
		fi

		echo ""

		local choice
		choice=$(gum choose \
			--header "Env file operations:" \
			--height 17 \
			"Backup All (SSD)" \
			"Backup All (Bitwarden)" \
			"Backup Project (SSD)" \
			"Backup Project (Bitwarden)" \
			"Restore All (SSD)" \
			"Restore All (Bitwarden)" \
			"Restore Project (SSD)" \
			"Restore Project (Bitwarden)" \
			"Copy Env (cross-project)" \
			"List Env Files" \
			"List Project Env Files" \
			"Manage Aliases" \
			"Dry Run (SSD)" \
			"Back" \
		) || return 0

		case "$choice" in
			"Backup All (SSD)")
				echo ""
				if gum confirm "Encrypt all .env files and save to SSD?"; then
					echo ""
					"$DEV_ENV/secrets" env backup
				fi
				pause
				;;
			"Backup All (Bitwarden)")
				echo ""
				if gum confirm "Store all .env files in Bitwarden vault?"; then
					echo ""
					"$DEV_ENV/secrets" env backup --bw
				fi
				pause
				;;
			"Backup Project (SSD)")
				local proj
				proj=$(pick_env_project "Select project to backup (SSD):") || { pause; continue; }
				echo ""
				if gum confirm "Encrypt $proj .env files to SSD?"; then
					echo ""
					"$DEV_ENV/secrets" env backup "$proj"
				fi
				pause
				;;
			"Backup Project (Bitwarden)")
				local proj
				proj=$(pick_env_project "Select project to backup (Bitwarden):") || { pause; continue; }
				echo ""
				if gum confirm "Store $proj .env files in Bitwarden?"; then
					echo ""
					"$DEV_ENV/secrets" env backup "$proj" --bw
				fi
				pause
				;;
			"Restore All (SSD)")
				echo ""
				if gum confirm "Restore all .env files from SSD?"; then
					echo ""
					"$DEV_ENV/secrets" env restore
				fi
				pause
				;;
			"Restore All (Bitwarden)")
				echo ""
				if gum confirm "Restore all .env files from Bitwarden?"; then
					echo ""
					"$DEV_ENV/secrets" env restore --bw
				fi
				pause
				;;
			"Restore Project (SSD)")
				local proj
				proj=$(pick_env_project "Select project to restore (SSD):") || { pause; continue; }
				echo ""
				if gum confirm "Restore $proj .env files from SSD?"; then
					echo ""
					"$DEV_ENV/secrets" env restore "$proj"
				fi
				pause
				;;
			"Restore Project (Bitwarden)")
				local proj
				proj=$(pick_env_project "Select project to restore (Bitwarden):") || { pause; continue; }
				echo ""
				if gum confirm "Restore $proj .env files from Bitwarden?"; then
					echo ""
					"$DEV_ENV/secrets" env restore "$proj" --bw
				fi
				pause
				;;
			"Copy Env (cross-project)")
				local src_proj dest_proj
				src_proj=$(pick_env_project "Select SOURCE project:") || { pause; continue; }
				dest_proj=$(pick_env_project "Select DESTINATION project:") || { pause; continue; }
				if [[ "$src_proj" == "$dest_proj" ]]; then
					error "Source and destination are the same"
					pause
					continue
				fi
				echo ""
				if gum confirm "Copy .env from $src_proj → $dest_proj (via SSD backup)?"; then
					echo ""
					"$DEV_ENV/secrets" env restore "$src_proj" --to "$dest_proj"
				fi
				pause
				;;
			"List Env Files")
				echo ""
				"$DEV_ENV/secrets" env list
				pause
				;;
			"List Project Env Files")
				local proj
				proj=$(pick_env_project "Select project to list:") || { pause; continue; }
				echo ""
				"$DEV_ENV/secrets" env list "$proj"
				pause
				;;
			"Manage Aliases")
				do_manage_aliases
				;;
			"Dry Run (SSD)")
				echo ""
				"$DEV_ENV/secrets" env backup --dry
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

menu_secrets_claude() {
	while true; do
		clear
		header "Claude Config"

		# Show current status
		if [[ -f "$HOME/.claude.json" ]] && command -v jq &>/dev/null; then
			local mcp_count
			mcp_count=$(jq '.mcpServers | length' "$HOME/.claude.json" 2>/dev/null || echo "0")
			info "MCP servers: $mcp_count"
		else
			warn "No .claude.json found"
		fi

		if [[ -f "$HOME/.claude/settings.json" ]] && command -v jq &>/dev/null; then
			local plugin_count
			plugin_count=$(jq '.enabledPlugins | length' "$HOME/.claude/settings.json" 2>/dev/null || echo "0")
			info "Plugins: $plugin_count"
		fi

		if check_ssd && [[ -d "$SSD/claude-config" ]]; then
			local claude_count
			claude_count=$(find "$SSD/claude-config" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "SSD: $claude_count age-encrypted backup(s)"
		fi

		if command -v bw &>/dev/null; then
			info "Bitwarden: available"
		fi

		echo ""

		local choice
		choice=$(gum choose \
			--header "Claude config operations:" \
			--height 10 \
			"Backup to SSD (age)" \
			"Backup to Bitwarden" \
			"Restore from SSD (age)" \
			"Restore from Bitwarden" \
			"List Config Files" \
			"Dry Run (SSD)" \
			"Back" \
		) || return 0

		case "$choice" in
			"Backup to SSD (age)")
				echo ""
				if gum confirm "Encrypt Claude configs and save to SSD?"; then
					echo ""
					"$DEV_ENV/secrets" claude backup
				fi
				pause
				;;
			"Backup to Bitwarden")
				echo ""
				if gum confirm "Store Claude configs in Bitwarden vault?"; then
					echo ""
					"$DEV_ENV/secrets" claude backup --bw
				fi
				pause
				;;
			"Restore from SSD (age)")
				echo ""
				warn "This will overwrite existing Claude config files"
				if gum confirm "Restore Claude configs from SSD?"; then
					echo ""
					"$DEV_ENV/secrets" claude restore
				fi
				pause
				;;
			"Restore from Bitwarden")
				echo ""
				warn "This will overwrite existing Claude config files"
				if gum confirm "Restore Claude configs from Bitwarden?"; then
					echo ""
					"$DEV_ENV/secrets" claude restore --bw
				fi
				pause
				;;
			"List Config Files")
				echo ""
				"$DEV_ENV/secrets" claude list
				pause
				;;
			"Dry Run (SSD)")
				echo ""
				"$DEV_ENV/secrets" claude backup --dry
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

do_manage_aliases() {
	while true; do
		clear
		header "Manage Aliases"

		local choice
		choice=$(gum choose \
			--header "Alias operations:" \
			--height 7 \
			"View Aliases" \
			"Set Alias" \
			"Remove Alias" \
			"Back" \
		) || return 0

		case "$choice" in
			"View Aliases")
				echo ""
				if [[ -f "$ENV_ALIAS_FILE" ]] && [[ -s "$ENV_ALIAS_FILE" ]]; then
					info "Current aliases ($ENV_ALIAS_FILE):"
					echo ""
					while IFS='=' read -r dirname alias; do
						[[ -z "$dirname" || "$dirname" == \#* ]] && continue
						success "  $dirname = $alias"
					done < "$ENV_ALIAS_FILE"
				else
					warn "No aliases set"
				fi
				pause
				;;
			"Set Alias")
				# Pick from all env projects (show raw dirnames for clarity)
				local projects
				mapfile -t projects < <(env_projects)
				if [[ ${#projects[@]} -eq 0 ]]; then
					error "No projects with .env files found"
					pause
					continue
				fi
				# Show current alias next to each project
				local labels=()
				for p in "${projects[@]}"; do
					local current
					current=$(get_project_alias "$p")
					if [[ "$current" != "$p" ]]; then
						labels+=("$p  (current: $current)")
					else
						labels+=("$p")
					fi
				done
				echo ""
				local selected
				selected=$(printf '%s\n' "${labels[@]}" | gum choose \
					--header "Select project to alias:" \
					--height 15 \
				) || { continue; }
				local dirname
				dirname=$(echo "$selected" | awk '{print $1}')
				local current_alias
				current_alias=$(get_project_alias "$dirname")
				local placeholder=""
				[[ "$current_alias" != "$dirname" ]] && placeholder="$current_alias"
				local new_alias
				new_alias=$(gum input \
					--header "Display name for $dirname:" \
					--placeholder "${placeholder:-Enter alias}" \
					--value "$placeholder" \
				) || { continue; }
				if [[ -z "$new_alias" ]]; then
					warn "Empty alias — skipped"
					pause
					continue
				fi
				# Write alias to file
				mkdir -p "$(dirname "$ENV_ALIAS_FILE")"
				if [[ -f "$ENV_ALIAS_FILE" ]] && grep -q "^${dirname}=" "$ENV_ALIAS_FILE" 2>/dev/null; then
					# Update existing entry
					sed -i "s|^${dirname}=.*|${dirname}=${new_alias}|" "$ENV_ALIAS_FILE"
				else
					echo "${dirname}=${new_alias}" >> "$ENV_ALIAS_FILE"
				fi
				echo ""
				success "Alias set: $dirname = $new_alias"
				pause
				;;
			"Remove Alias")
				if [[ ! -f "$ENV_ALIAS_FILE" ]] || [[ ! -s "$ENV_ALIAS_FILE" ]]; then
					warn "No aliases to remove"
					pause
					continue
				fi
				local aliases=()
				while IFS='=' read -r dirname alias; do
					[[ -z "$dirname" || "$dirname" == \#* ]] && continue
					aliases+=("$dirname = $alias")
				done < "$ENV_ALIAS_FILE"
				if [[ ${#aliases[@]} -eq 0 ]]; then
					warn "No aliases to remove"
					pause
					continue
				fi
				echo ""
				local selected
				selected=$(printf '%s\n' "${aliases[@]}" | gum choose \
					--header "Select alias to remove:" \
					--height 10 \
				) || { continue; }
				local dirname
				dirname=$(echo "$selected" | cut -d' ' -f1)
				sed -i "/^${dirname}=/d" "$ENV_ALIAS_FILE"
				echo ""
				success "Removed alias for $dirname"
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

do_ssh_view() {
	clear
	header "Local SSH Keys"

	if [[ ! -d "$HOME/.ssh" ]]; then
		warn "No ~/.ssh/ directory"
		pause
		return
	fi

	for f in "$HOME/.ssh"/*; do
		[[ -e "$f" ]] || continue
		local name perms size
		name=$(basename "$f")
		perms=$(stat -c '%a' "$f")
		size=$(du -sh "$f" 2>/dev/null | cut -f1)

		case "$name" in
			id_*|*.pem)
				if [[ "$name" == *.pub ]]; then
					success "  $name  ($perms)  $size  [public key]"
				else
					info "  $name  ($perms)  $size  [private key]"
				fi
				;;
			config)       info "  $name  ($perms)  $size  [ssh config]" ;;
			known_hosts)  info "  $name  ($perms)  $size  [known hosts]" ;;
			known_hosts.old) gum style --foreground 240 "  $name  ($perms)  $size" ;;
			*)            info "  $name  ($perms)  $size" ;;
		esac
	done

	pause
}

# -----------------------------------------------------------------------
# Settings
# -----------------------------------------------------------------------
menu_settings() {
	while true; do
		clear
		header "Settings"

		info "Config file: $DEV_ENV_CONFIG_FILE"
		info "Active SSD: $SSD"
		echo ""

		local choice
		choice=$(gum choose \
			--header "Settings:" \
			--height 10 \
			"Manage SSDs" \
			"Change Projects Directory" \
			"Change Sources" \
			"View Config File" \
			"Reset to Defaults" \
			"Back" \
		) || return 0

		case "$choice" in
			"Manage SSDs")
				menu_manage_ssds
				;;
			"Change Projects Directory")
				local new_val
				new_val=$(gum input --header "Projects directory:" --value "$PROJECTS_DIR") || continue
				if [[ -n "$new_val" ]]; then
					save_config "PROJECTS_DIR" "$new_val"
					load_config
					success "Projects directory set to: $PROJECTS_DIR"
					pause
				fi
				;;
			"Change Sources")
				local current_sources
				current_sources=$(IFS=','; echo "${SOURCES[*]}")
				local new_val
				new_val=$(gum input --header "Sources (comma-separated):" --value "$current_sources") || continue
				if [[ -n "$new_val" ]]; then
					save_config "SOURCES" "$new_val"
					load_config
					success "Sources set to: ${SOURCES[*]}"
					pause
				fi
				;;
			"View Config File")
				echo ""
				if [[ -f "$DEV_ENV_CONFIG_FILE" ]]; then
					gum style --foreground 240 "  $DEV_ENV_CONFIG_FILE:"
					echo ""
					while IFS= read -r line; do
						info "  $line"
					done < "$DEV_ENV_CONFIG_FILE"
				else
					warn "No config file found"
				fi
				pause
				;;
			"Reset to Defaults")
				if gum confirm "Reset all settings to defaults?"; then
					rm -f "$DEV_ENV_CONFIG_FILE"
					load_config
					success "Config reset to defaults"
					pause
				fi
				;;
			"Back") return 0 ;;
		esac
	done
}

menu_manage_ssds() {
	while true; do
		clear
		header "Manage SSDs"

		# Show all SSDs with status
		local ssd_info=()
		while IFS='|' read -r path status; do
			ssd_info+=("$path|$status")
			if [[ "$status" == *"*"* ]]; then
				info "$path  $status  (active)"
			else
				gum style --foreground 240 "  $path  $status"
			fi
		done < <(list_ssds)

		echo ""

		local choice
		choice=$(gum choose \
			--header "SSD management:" \
			--height 8 \
			"Switch Active SSD" \
			"Add SSD" \
			"Remove SSD" \
			"Back" \
		) || return 0

		case "$choice" in
			"Switch Active SSD")
				if [[ ${#SSD_LIST[@]} -le 1 ]]; then
					warn "Only one SSD configured"
					pause
					continue
				fi
				local labels=()
				for p in "${SSD_LIST[@]}"; do
					local label="$p"
					if mountpoint -q "$p" 2>/dev/null; then
						local free
						free=$(df -h "$p" | awk 'NR==2 {print $4}')
						label="$p  (mounted, ${free} free)"
					else
						label="$p  (not mounted)"
					fi
					[[ "$p" == "$SSD" ]] && label="$label  [active]"
					labels+=("$label")
				done
				echo ""
				local selected
				selected=$(printf '%s\n' "${labels[@]}" | gum choose \
					--header "Select active SSD:" \
					--height 10 \
				) || continue
				local new_ssd
				new_ssd=$(echo "$selected" | awk '{print $1}')
				switch_ssd "$new_ssd"
				success "Active SSD: $SSD"
				pause
				;;
			"Add SSD")
				local new_path
				new_path=$(gum input \
					--header "New SSD mount path:" \
					--placeholder "/run/media/$USER/DRIVENAME" \
				) || continue
				if [[ -z "$new_path" ]]; then
					warn "Empty path"
					pause
					continue
				fi
				add_ssd "$new_path"
				success "Added: $new_path"
				if ! mountpoint -q "$new_path" 2>/dev/null; then
					warn "Note: $new_path is not currently mounted"
				fi
				pause
				;;
			"Remove SSD")
				if [[ ${#SSD_LIST[@]} -le 1 ]]; then
					error "Can't remove the last SSD"
					pause
					continue
				fi
				local labels=()
				for p in "${SSD_LIST[@]}"; do
					local label="$p"
					[[ "$p" == "$SSD" ]] && label="$p  [active]"
					labels+=("$label")
				done
				echo ""
				local selected
				selected=$(printf '%s\n' "${labels[@]}" | gum choose \
					--header "Select SSD to remove:" \
					--height 10 \
				) || continue
				local rm_path
				rm_path=$(echo "$selected" | awk '{print $1}')
				if gum confirm "Remove $rm_path from SSD list?"; then
					remove_ssd "$rm_path"
					success "Removed: $rm_path"
					if [[ "$rm_path" == "$SSD" ]]; then
						info "Active SSD switched to: $SSD"
					fi
				fi
				pause
				;;
			"Back") return 0 ;;
		esac
	done
}

# -----------------------------------------------------------------------
# Status
# -----------------------------------------------------------------------
render_status() {
	# SSD
	divider
	gum style --foreground 212 --bold "  SSD"
	if mountpoint -q "$SSD" 2>/dev/null; then
		local fs total used free pct
		fs=$(df -Th "$SSD" | awk 'NR==2 {print $2}')
		total=$(df -h "$SSD" | awk 'NR==2 {print $2}')
		used=$(df -h "$SSD" | awk 'NR==2 {print $3}')
		free=$(df -h "$SSD" | awk 'NR==2 {print $4}')
		pct=$(df "$SSD" | awk 'NR==2 {print $5}')
		info "Mount: $SSD  ($fs)  ${used}/${total} (${pct})  ${free} free"
	else
		error "Not mounted"
	fi

	echo ""

	# Backup age
	divider
	gum style --foreground 212 --bold "  Backups"
	local backup_msg
	backup_msg=$(check_backup_age 7)
	if [[ -n "$backup_msg" ]]; then
		warn "$backup_msg"
	elif [[ -f "$TIMESTAMP_FILE" ]]; then
		local last now days_ago
		last=$(cat "$TIMESTAMP_FILE")
		now=$(date +%s)
		days_ago=$(( (now - last) / 86400 ))
		success "last backup: ${days_ago}d ago"
	else
		warn "no backup recorded"
	fi

	if mountpoint -q "$SSD" 2>/dev/null; then
		local backups
		mapfile -t backups < <(backup_list)
		if [[ ${#backups[@]} -gt 0 ]]; then
			info "${#backups[@]} snapshot(s) on SSD"
			for b in "${backups[@]}"; do
				local size
				size=$(du -sh "$b" 2>/dev/null | cut -f1)
				gum style --foreground 240 "    $(basename "$b")  $size"
			done
		else
			warn "no backups on SSD"
		fi
	fi

	echo ""

	# Secrets freshness
	divider
	gum style --foreground 212 --bold "  Secrets"

	# SSH
	local ssh_key_count=0
	if [[ -d "$HOME/.ssh" ]]; then
		for f in "$HOME/.ssh"/id_*; do
			[[ -f "$f" && "$f" != *.pub ]] && ssh_key_count=$(( ssh_key_count + 1 ))
		done
	fi
	if mountpoint -q "$SSD" 2>/dev/null && [[ -d "$SSH_BACKUP_DIR" ]]; then
		local ssh_bk
		ssh_bk=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
		if [[ "$ssh_bk" -gt 0 ]]; then
			local latest_ssh ssh_age
			latest_ssh=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | tail -1)
			ssh_age=$(( ( $(date +%s) - $(stat -c %Y "$latest_ssh") ) / 86400 ))
			if [[ $ssh_age -gt 30 ]]; then
				warn "SSH: $ssh_key_count key(s), $ssh_bk backup(s) — ${ssh_age}d old"
			else
				success "SSH: $ssh_key_count key(s), $ssh_bk backup(s) — ${ssh_age}d old"
			fi
		else
			warn "SSH: $ssh_key_count key(s), no backups"
		fi
	else
		info "SSH: $ssh_key_count key(s)"
	fi

	# Env
	local env_count=0
	while read -r f; do
		[[ -f "$f" ]] && env_count=$(( env_count + 1 ))
	done < <(find "$PROJECTS_DIR" -maxdepth 4 \
		\( -name ".env" -o -name ".env.local" -o -name ".env.production" -o -name ".env.development" \) \
		2>/dev/null | grep -v node_modules | grep -v .git/ | grep -v __pycache__ | grep -v .venv | grep -v .conda)

	if mountpoint -q "$SSD" 2>/dev/null && [[ -d "$ENV_BACKUP_DIR" ]]; then
		local env_bk
		env_bk=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
		if [[ "$env_bk" -gt 0 ]]; then
			local latest_env env_age
			latest_env=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | tail -1)
			env_age=$(( ( $(date +%s) - $(stat -c %Y "$latest_env") ) / 86400 ))
			if [[ $env_age -gt 14 ]]; then
				warn "Env: $env_count file(s), $env_bk backup(s) — ${env_age}d old"
			else
				success "Env: $env_count file(s), $env_bk backup(s) — ${env_age}d old"
			fi
		else
			if [[ $env_count -gt 0 ]]; then
				warn "Env: $env_count file(s), no backups!"
			else
				info "Env: no .env files"
			fi
		fi
	else
		info "Env: $env_count file(s)"
	fi

	# Claude
	if [[ -f "$HOME/.claude.json" ]] && command -v jq &>/dev/null; then
		local mcp_count
		mcp_count=$(jq '.mcpServers | length' "$HOME/.claude.json" 2>/dev/null || echo "0")
		if mountpoint -q "$SSD" 2>/dev/null && [[ -d "$SSD/claude-config" ]]; then
			local claude_bk
			claude_bk=$(find "$SSD/claude-config" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			if [[ "$claude_bk" -gt 0 ]]; then
				local latest_cl cl_age
				latest_cl=$(find "$SSD/claude-config" -name "*.tar.age" -type f 2>/dev/null | sort | tail -1)
				cl_age=$(( ( $(date +%s) - $(stat -c %Y "$latest_cl") ) / 86400 ))
				success "Claude: $mcp_count MCP(s), $claude_bk backup(s) — ${cl_age}d old"
			else
				warn "Claude: $mcp_count MCP(s), no backups"
			fi
		else
			info "Claude: $mcp_count MCP server(s)"
		fi
	fi

	echo ""

	# Config drift
	divider
	gum style --foreground 212 --bold "  Config Drift"
	local drift_count=0
	local xdg="${XDG_CONFIG_HOME:-$HOME/.config}"
	while IFS='|' read -r type name src dest status; do
		if [[ "$status" == "deployed" ]]; then
			if [[ -d "$src" && -d "$dest" ]]; then
				local diff_out
				diff_out=$(diff -rq "$src" "$dest" 2>/dev/null | head -3 || true)
				if [[ -n "$diff_out" ]]; then
					warn "  $name: drifted"
					drift_count=$(( drift_count + 1 ))
				fi
			elif [[ -f "$src" && -f "$dest" ]]; then
				if ! diff -q "$src" "$dest" &>/dev/null; then
					warn "  $name: drifted"
					drift_count=$(( drift_count + 1 ))
				fi
			fi
		fi
	done < <(gather_configs)

	if [[ $drift_count -eq 0 ]]; then
		success "all configs in sync"
	else
		warn "$drift_count config(s) drifted — run: dev-env update"
	fi

	echo ""

	# Dev repo
	divider
	gum style --foreground 212 --bold "  Dev Repo"
	local git_changes
	git_changes=$(cd "$DEV_ENV" && git status --porcelain 2>/dev/null | wc -l)
	local branch
	branch=$(cd "$DEV_ENV" && git branch --show-current 2>/dev/null)
	if [[ "$git_changes" -eq 0 ]]; then
		success "clean ($branch)"
	else
		warn "$git_changes uncommitted change(s) ($branch)"
	fi

	echo ""

	# Tools
	divider
	gum style --foreground 212 --bold "  Tools"
	local total_tools=0 installed_tools=0
	shopt -s nullglob
	for s in "$DEV_ENV"/runs/*; do
		[[ -x "$s" ]] || continue
		total_tools=$(( total_tools + 1 ))
		if tool_installed "$(basename "$s")"; then
			installed_tools=$(( installed_tools + 1 ))
		fi
	done
	shopt -u nullglob
	if [[ $installed_tools -eq $total_tools ]]; then
		success "$installed_tools/$total_tools installed"
	else
		warn "$installed_tools/$total_tools installed"
	fi
}

menu_status() {
	clear
	header "System Status"
	render_status
	pause
}

live_dashboard() {
	local interval="${1:-5}"
	while true; do
		clear
		header "Live Dashboard  (refreshes every ${interval}s — press q to exit)"
		render_status
		gum style --foreground 240 "  $(date '+%H:%M:%S')"

		# Wait for interval, break on 'q'
		local i=0
		while (( i < interval )); do
			if read -rsn1 -t 1 key 2>/dev/null; then
				[[ "$key" == "q" || "$key" == "Q" ]] && return 0
			fi
			i=$(( i + 1 ))
		done
	done
}

# -----------------------------------------------------------------------
# First-run wizard
# -----------------------------------------------------------------------
first_run_wizard() {
	if [[ -f "$DEV_ENV_CONFIG_FILE" ]]; then
		return
	fi

	clear
	header "Welcome to Dev Environment"

	gum style --foreground 240 "  First time setup — configure your defaults."
	echo ""

	# SSD path
	local ssd_path
	ssd_path=$(gum input \
		--header "SSD mount path:" \
		--value "$_DEFAULT_SSD_PATH" \
		--placeholder "/run/media/$USER/TRANSCEND" \
	) || ssd_path="$_DEFAULT_SSD_PATH"
	[[ -z "$ssd_path" ]] && ssd_path="$_DEFAULT_SSD_PATH"

	# Projects directory
	local projects_dir
	projects_dir=$(gum input \
		--header "Projects directory:" \
		--value "$_DEFAULT_PROJECTS_DIR" \
		--placeholder "$HOME/Personal" \
	) || projects_dir="$_DEFAULT_PROJECTS_DIR"
	[[ -z "$projects_dir" ]] && projects_dir="$_DEFAULT_PROJECTS_DIR"

	# Sources
	local sources
	sources=$(gum input \
		--header "Source directories to backup (comma-separated):" \
		--value "$_DEFAULT_SOURCES" \
		--placeholder "Personal" \
	) || sources="$_DEFAULT_SOURCES"
	[[ -z "$sources" ]] && sources="$_DEFAULT_SOURCES"

	# Save config
	mkdir -p "$DEV_ENV_CONFIG_DIR"
	cat > "$DEV_ENV_CONFIG_FILE" <<EOF
SSD_PATH="$ssd_path"
SSD_PATHS="$ssd_path"
PROJECTS_DIR="$projects_dir"
SOURCES="$sources"
EOF

	load_config

	echo ""
	success "Config saved to $DEV_ENV_CONFIG_FILE"
	pause
}

# -----------------------------------------------------------------------
# CLI mode: ./tui --run <action>
# -----------------------------------------------------------------------
cli_usage() {
	echo "Usage: ./tui [--run <action>] [--list]"
	echo ""
	echo "Actions:"
	echo "  backup          full backup (new snapshot)"
	echo "  sync            quick sync (incremental)"
	echo "  verify          verify latest backup"
	echo "  restore         restore from latest"
	echo "  status          show system status"
	echo "  dashboard       live dashboard"
	echo "  secrets-health  secrets health check"
	echo "  secrets-diff    secrets diff since last backup"
	echo "  secrets-list    list all secrets"
	echo "  skills-list     list available skills"
	echo "  skills-fetch    fetch/update skill library"
	echo "  deploy          deploy configs"
	echo "  compare         compare repo vs live configs"
	echo "  install         install all tools"
	echo "  doctor          run dev-env doctor"
	echo ""
	echo "Examples:"
	echo "  ./tui --run backup"
	echo "  ./tui --run secrets-health"
	echo "  ./tui --run status"
}

if [[ "${1:-}" == "--run" ]]; then
	action="${2:-}"
	if [[ -z "$action" ]]; then
		cli_usage
		exit 1
	fi
	case "$action" in
		backup)         "$DEV_ENV/backup" ;;
		sync)           "$DEV_ENV/backup" --sync ;;
		verify)         "$DEV_ENV/backup" --verify ;;
		restore)        "$DEV_ENV/restore" "${@:3}" ;;
		status)         render_status ;;
		dashboard)      live_dashboard "${3:-5}" ;;
		secrets-health) "$DEV_ENV/secrets" --health ;;
		secrets-diff)   "$DEV_ENV/secrets" --diff ;;
		secrets-list)   "$DEV_ENV/secrets" --list ;;
		deploy)         "$DEV_ENV/dev-env" ;;
		compare)        "$DEV_ENV/dev-env" compare ;;
		install)        "$DEV_ENV/run" "${@:3}" ;;
		skills-list)    "$DEV_ENV/skills" list ;;
		skills-fetch)   "$DEV_ENV/skills-fetch" ;;
		doctor)         "$DEV_ENV/dev-env" doctor ;;
		*)
			echo "Unknown action: $action"
			echo ""
			cli_usage
			exit 1
			;;
	esac
	exit 0
fi

if [[ "${1:-}" == "--list" ]]; then
	cli_usage
	exit 0
fi

if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
	cli_usage
	exit 0
fi

# -----------------------------------------------------------------------
# Entry point (interactive mode)
# -----------------------------------------------------------------------
first_run_wizard
main_menu
