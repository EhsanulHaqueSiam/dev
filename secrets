#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------
# Secrets manager — backup/restore SSH keys and .env files
#
# Backends:
#   age   — encrypted to external SSD (offline, passphrase-based)
#   bw    — Bitwarden vault (cloud, synced across devices)
#
# Usage:
#   ./secrets ssh backup              — backup SSH keys (age → SSD)
#   ./secrets ssh backup --bw         — backup SSH keys (→ Bitwarden)
#   ./secrets ssh restore             — restore SSH keys (age ← SSD)
#   ./secrets ssh restore --bw        — restore SSH keys (← Bitwarden)
#   ./secrets env backup              — backup .env files (age → SSD)
#   ./secrets env backup --bw         — backup .env files (→ Bitwarden)
#   ./secrets env restore             — restore .env files (age ← SSD)
#   ./secrets env restore --bw        — restore .env files (← Bitwarden)
#   ./secrets env list                — list .env files in projects
#   ./secrets --list                  — list all secrets on SSD/Bitwarden
#   ./secrets --dry                   — preview mode (any command)
# -----------------------------------------------------------------------

SSD="/run/media/siam/TRANSCEND"
SSH_BACKUP_DIR="$SSD/ssh-keys"
ENV_BACKUP_DIR="$SSD/env-secrets"
SSH_DIR="$HOME/.ssh"
PROJECTS_DIR="$HOME/Personal"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

log()  { echo -e "${GREEN}[secrets]${NC} $1"; }
warn() { echo -e "${YELLOW}[secrets]${NC} $1"; }
err()  { echo -e "${RED}[secrets]${NC} $1"; }
info() { echo -e "${BLUE}[secrets]${NC} $1"; }

# -----------------------------------------------------------------------
# Dependency checks
# -----------------------------------------------------------------------
ensure_age() {
	if ! command -v age &>/dev/null; then
		warn "age not found — installing..."
		if command -v yay &>/dev/null; then
			yay -S --noconfirm --needed age
		elif command -v pacman &>/dev/null; then
			sudo pacman -S --noconfirm --needed age
		else
			err "install age: https://github.com/FiloSottile/age"
			exit 1
		fi
	fi
}

ensure_bw() {
	if ! command -v bw &>/dev/null; then
		warn "bitwarden-cli not found — installing..."
		if command -v yay &>/dev/null; then
			yay -S --noconfirm --needed bitwarden-cli
		elif command -v pacman &>/dev/null; then
			sudo pacman -S --noconfirm --needed bitwarden-cli
		else
			err "install bitwarden-cli: sudo pacman -S bitwarden-cli"
			exit 1
		fi
	fi
	if ! command -v jq &>/dev/null; then
		warn "jq not found — installing..."
		if command -v yay &>/dev/null; then
			yay -S --noconfirm --needed jq
		else
			sudo pacman -S --noconfirm --needed jq
		fi
	fi
}

ensure_ssd() {
	if ! mountpoint -q "$SSD" 2>/dev/null; then
		err "SSD not mounted at $SSD"
		exit 1
	fi
}

# -----------------------------------------------------------------------
# Bitwarden session helper
# -----------------------------------------------------------------------
bw_unlock() {
	local status
	status=$(bw status 2>/dev/null | jq -r '.status' 2>/dev/null || echo "unauthenticated")

	if [[ "$status" == "unauthenticated" ]]; then
		warn "not logged in — run: bw login"
		err "login first, then re-run this command"
		exit 1
	fi

	if [[ "$status" == "locked" ]]; then
		log "unlocking Bitwarden vault..."
		BW_SESSION=$(bw unlock --raw) || { err "unlock failed"; exit 1; }
		export BW_SESSION
	fi

	bw sync --quiet 2>/dev/null || true
}

# -----------------------------------------------------------------------
# SSH: age backup (→ SSD)
# -----------------------------------------------------------------------
ssh_backup_age() {
	ensure_age
	ensure_ssd

	if [[ ! -d "$SSH_DIR" ]]; then
		err "no SSH directory at $SSH_DIR"
		exit 1
	fi

	echo ""
	log "SSH keys to backup:"
	local key_count=0
	for f in "$SSH_DIR"/*; do
		[[ -e "$f" ]] || continue
		local name size
		name=$(basename "$f")
		[[ "$name" == "known_hosts.old" ]] && continue
		size=$(du -sh "$f" 2>/dev/null | cut -f1)
		case "$name" in
			id_*|*.pem)
				[[ "$name" == *.pub ]] && info "  $name ($size) [public]" || info "  $name ($size) [private]"
				key_count=$(( key_count + 1 )) ;;
			config)       info "  $name ($size) [config]" ;;
			known_hosts)  info "  $name ($size) [known_hosts]" ;;
			*)            info "  $name ($size)" ;;
		esac
	done
	[[ $key_count -eq 0 ]] && { warn "no SSH keys found"; exit 0; }

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would encrypt ~/.ssh/ → $SSH_BACKUP_DIR/"
		exit 0
	fi

	local timestamp hostname backup_file
	timestamp=$(date +%Y-%m-%d_%H-%M-%S)
	hostname=$(hostname 2>/dev/null || echo "unknown")
	backup_file="$SSH_BACKUP_DIR/ssh-keys_${hostname}_${timestamp}.tar.age"
	mkdir -p "$SSH_BACKUP_DIR"

	echo ""
	log "encrypting SSH keys..."
	warn "choose a strong passphrase:"
	echo ""
	tar -C "$HOME" -cf - .ssh | age -p -o "$backup_file"

	local backup_size
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)
	echo ""
	log "SSH backup complete → $backup_file ($backup_size)"
	warn "remember your passphrase!"
}

# -----------------------------------------------------------------------
# SSH: age restore (← SSD)
# -----------------------------------------------------------------------
ssh_restore_age() {
	ensure_age
	ensure_ssd

	if [[ ! -d "$SSH_BACKUP_DIR" ]]; then
		err "no SSH backups at $SSH_BACKUP_DIR"
		exit 1
	fi

	mapfile -t backups < <(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort)
	[[ ${#backups[@]} -eq 0 ]] && { err "no SSH backups found"; exit 1; }

	local backup_file
	backup_file="${backups[-1]}"
	local backup_name backup_size
	backup_name=$(basename "$backup_file")
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)

	echo ""
	log "restoring from: $backup_name ($backup_size)"

	if [[ $dry_run -eq 1 ]]; then
		warn "DRY RUN — would decrypt to ~/.ssh/ and fix permissions"
		exit 0
	fi

	echo ""
	warn "this will overwrite ~/.ssh/"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	# Backup existing
	if [[ -d "$SSH_DIR" ]]; then
		local bak="$HOME/.ssh.bak.$(date +%Y%m%d-%H%M%S)"
		log "backing up existing → $bak"
		cp -r "$SSH_DIR" "$bak"
	fi

	# Decrypt
	echo ""
	log "decrypting..."
	local tmpdir
	tmpdir=$(mktemp -d)
	trap 'rm -rf "$tmpdir"' EXIT
	age -d "$backup_file" | tar -C "$tmpdir" -xf -
	[[ ! -d "$tmpdir/.ssh" ]] && { err "decryption failed"; exit 1; }

	mkdir -p "$SSH_DIR"
	cp -r "$tmpdir/.ssh/"* "$SSH_DIR/" 2>/dev/null || true
	cp -r "$tmpdir/.ssh/".[!.]* "$SSH_DIR/" 2>/dev/null || true

	# Fix permissions
	chmod 700 "$SSH_DIR"
	for f in "$SSH_DIR"/*; do
		[[ -e "$f" ]] || continue
		case "$(basename "$f")" in
			*.pub|known_hosts|known_hosts.old|authorized_keys) chmod 644 "$f" ;;
			*) chmod 600 "$f" ;;
		esac
	done

	echo ""
	log "SSH restore complete — test: ssh -T git@github.com"
}

# -----------------------------------------------------------------------
# SSH: Bitwarden backup (→ vault)
# -----------------------------------------------------------------------
ssh_backup_bw() {
	ensure_bw
	bw_unlock

	if [[ ! -f "$SSH_DIR/id_ed25519" ]]; then
		err "no SSH key at $SSH_DIR/id_ed25519"
		exit 1
	fi

	local privkey pubkey hostname
	privkey=$(cat "$SSH_DIR/id_ed25519")
	pubkey=$(cat "$SSH_DIR/id_ed25519.pub" 2>/dev/null || echo "")
	hostname=$(hostname 2>/dev/null || echo "unknown")

	echo ""
	info "private key: $SSH_DIR/id_ed25519"
	[[ -n "$pubkey" ]] && info "public key:  $SSH_DIR/id_ed25519.pub"
	echo ""

	if [[ $dry_run -eq 1 ]]; then
		warn "DRY RUN — would store SSH key in Bitwarden as secure note"
		exit 0
	fi

	local item_name="SSH Key - $hostname - id_ed25519"

	# Check if item already exists
	local existing
	existing=$(bw list items --search "$item_name" 2>/dev/null | jq -r '.[0].id // empty' 2>/dev/null || echo "")

	if [[ -n "$existing" ]]; then
		log "updating existing item: $item_name"
		bw get item "$existing" | jq \
			--arg key "$privkey" \
			--arg pub "$pubkey" \
			--arg date "$(date -I)" \
			'.notes = $key |
			 .fields = [
				{"name": "public_key", "value": $pub, "type": 0},
				{"name": "key_type", "value": "ed25519", "type": 0},
				{"name": "updated", "value": $date, "type": 0}
			 ]' \
			| bw encode | bw edit item "$existing" > /dev/null
	else
		log "creating new item: $item_name"
		bw get template item | jq \
			--arg key "$privkey" \
			--arg pub "$pubkey" \
			--arg name "$item_name" \
			--arg date "$(date -I)" \
			'.type = 2 |
			 .secureNote.type = 0 |
			 .name = $name |
			 .notes = $key |
			 .fields = [
				{"name": "public_key", "value": $pub, "type": 0},
				{"name": "key_type", "value": "ed25519", "type": 0},
				{"name": "created", "value": $date, "type": 0}
			 ]' \
			| bw encode | bw create item > /dev/null
	fi

	log "SSH key stored in Bitwarden vault"
}

# -----------------------------------------------------------------------
# SSH: Bitwarden restore (← vault)
# -----------------------------------------------------------------------
ssh_restore_bw() {
	ensure_bw
	bw_unlock

	echo ""
	log "searching Bitwarden for SSH keys..."

	local items
	items=$(bw list items --search "SSH Key" 2>/dev/null | jq -r '.[].name' 2>/dev/null || echo "")

	if [[ -z "$items" ]]; then
		err "no SSH keys found in Bitwarden"
		exit 1
	fi

	log "found:"
	echo "$items" | while read -r name; do
		info "  $name"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would restore SSH key from Bitwarden to ~/.ssh/"
		exit 0
	fi

	# Get the first SSH key item
	local item_name
	item_name=$(echo "$items" | head -1)

	echo ""
	warn "restoring: $item_name"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	# Backup existing
	if [[ -d "$SSH_DIR" ]]; then
		local bak="$HOME/.ssh.bak.$(date +%Y%m%d-%H%M%S)"
		log "backing up existing → $bak"
		cp -r "$SSH_DIR" "$bak"
	fi

	mkdir -p "$SSH_DIR"
	chmod 700 "$SSH_DIR"

	# Restore private key
	bw get item "$item_name" | jq -r '.notes' > "$SSH_DIR/id_ed25519"
	chmod 600 "$SSH_DIR/id_ed25519"
	log "restored: id_ed25519"

	# Restore public key
	local pubkey
	pubkey=$(bw get item "$item_name" | jq -r '.fields[] | select(.name=="public_key") | .value' 2>/dev/null || echo "")
	if [[ -n "$pubkey" ]]; then
		echo "$pubkey" > "$SSH_DIR/id_ed25519.pub"
		chmod 644 "$SSH_DIR/id_ed25519.pub"
		log "restored: id_ed25519.pub"
	fi

	echo ""
	log "SSH restore complete — test: ssh -T git@github.com"
}

# -----------------------------------------------------------------------
# ENV: find .env files
# -----------------------------------------------------------------------
find_env_files() {
	find "$PROJECTS_DIR" -maxdepth 4 \
		-name ".env" -o -name ".env.local" -o -name ".env.production" \
		-o -name ".env.development" 2>/dev/null \
		| grep -v node_modules \
		| grep -v .git/ \
		| grep -v __pycache__ \
		| grep -v .venv \
		| grep -v .conda \
		| sort
}

env_list() {
	echo ""
	log ".env files in $PROJECTS_DIR:"
	echo ""

	local count=0
	while read -r f; do
		[[ -f "$f" ]] || continue
		local relpath size lines
		relpath="${f#$PROJECTS_DIR/}"
		size=$(du -sh "$f" 2>/dev/null | cut -f1)
		lines=$(wc -l < "$f")
		info "  $relpath  ($size, $lines lines)"
		count=$(( count + 1 ))
	done < <(find_env_files)

	echo ""
	log "$count .env file(s) found"
}

# -----------------------------------------------------------------------
# ENV: age backup (→ SSD)
# -----------------------------------------------------------------------
env_backup_age() {
	ensure_age
	ensure_ssd

	local env_files=()
	while read -r f; do
		[[ -f "$f" ]] && env_files+=("$f")
	done < <(find_env_files)

	if [[ ${#env_files[@]} -eq 0 ]]; then
		warn "no .env files found"
		exit 0
	fi

	echo ""
	log "${#env_files[@]} .env file(s) to backup:"
	for f in "${env_files[@]}"; do
		local relpath size
		relpath="${f#$PROJECTS_DIR/}"
		size=$(du -sh "$f" 2>/dev/null | cut -f1)
		info "  $relpath ($size)"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would encrypt .env files → $ENV_BACKUP_DIR/"
		exit 0
	fi

	local timestamp backup_file
	timestamp=$(date +%Y-%m-%d_%H-%M-%S)
	backup_file="$ENV_BACKUP_DIR/env-secrets_${timestamp}.tar.age"
	mkdir -p "$ENV_BACKUP_DIR"

	echo ""
	log "encrypting .env files..."
	warn "choose a strong passphrase:"
	echo ""

	# Create tar of all .env files preserving relative paths
	local tmplist
	tmplist=$(mktemp)
	for f in "${env_files[@]}"; do
		echo "${f#$HOME/}" >> "$tmplist"
	done

	tar -C "$HOME" -cf - -T "$tmplist" | age -p -o "$backup_file"
	rm -f "$tmplist"

	local backup_size
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)
	echo ""
	log "env backup complete → $backup_file ($backup_size)"
	log "${#env_files[@]} .env files encrypted"
	warn "remember your passphrase!"
}

# -----------------------------------------------------------------------
# ENV: age restore (← SSD)
# -----------------------------------------------------------------------
env_restore_age() {
	ensure_age
	ensure_ssd

	if [[ ! -d "$ENV_BACKUP_DIR" ]]; then
		err "no env backups at $ENV_BACKUP_DIR"
		exit 1
	fi

	mapfile -t backups < <(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort)
	[[ ${#backups[@]} -eq 0 ]] && { err "no env backups found"; exit 1; }

	local backup_file backup_name backup_size
	backup_file="${backups[-1]}"
	backup_name=$(basename "$backup_file")
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)

	echo ""
	log "restoring from: $backup_name ($backup_size)"

	if [[ $dry_run -eq 1 ]]; then
		warn "DRY RUN — would decrypt .env files to their project directories"
		exit 0
	fi

	echo ""
	warn "this will overwrite existing .env files"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	echo ""
	log "decrypting..."
	age -d "$backup_file" | tar -C "$HOME" -xvf - 2>&1 | while read -r f; do
		info "  restored: $f"
	done

	echo ""
	log "env restore complete"
}

# -----------------------------------------------------------------------
# ENV: Bitwarden backup (→ vault)
# -----------------------------------------------------------------------
env_backup_bw() {
	ensure_bw
	bw_unlock

	local env_files=()
	while read -r f; do
		[[ -f "$f" ]] && env_files+=("$f")
	done < <(find_env_files)

	if [[ ${#env_files[@]} -eq 0 ]]; then
		warn "no .env files found"
		exit 0
	fi

	echo ""
	log "${#env_files[@]} .env file(s) to backup:"
	for f in "${env_files[@]}"; do
		info "  ${f#$PROJECTS_DIR/}"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would store .env files in Bitwarden as secure notes"
		exit 0
	fi

	echo ""
	local stored=0
	for f in "${env_files[@]}"; do
		local relpath content item_name
		relpath="${f#$PROJECTS_DIR/}"
		content=$(cat "$f")
		item_name="env - $relpath"

		# Check if exists
		local existing
		existing=$(bw list items --search "$item_name" 2>/dev/null | jq -r '.[0].id // empty' 2>/dev/null || echo "")

		if [[ -n "$existing" ]]; then
			bw get item "$existing" | jq \
				--arg content "$content" \
				--arg date "$(date -I)" \
				'.notes = $content |
				 .fields = [{"name": "updated", "value": $date, "type": 0}]' \
				| bw encode | bw edit item "$existing" > /dev/null
			info "  updated: $relpath"
		else
			bw get template item | jq \
				--arg content "$content" \
				--arg name "$item_name" \
				--arg date "$(date -I)" \
				'.type = 2 |
				 .secureNote.type = 0 |
				 .name = $name |
				 .notes = $content |
				 .fields = [{"name": "created", "value": $date, "type": 0}]' \
				| bw encode | bw create item > /dev/null
			info "  created: $relpath"
		fi
		stored=$(( stored + 1 ))
	done

	echo ""
	log "$stored .env file(s) stored in Bitwarden vault"
}

# -----------------------------------------------------------------------
# ENV: Bitwarden restore (← vault)
# -----------------------------------------------------------------------
env_restore_bw() {
	ensure_bw
	bw_unlock

	echo ""
	log "searching Bitwarden for .env files..."

	local items
	items=$(bw list items --search "env -" 2>/dev/null | jq -r '.[].name' 2>/dev/null | grep "^env - " || echo "")

	if [[ -z "$items" ]]; then
		err "no .env files found in Bitwarden"
		exit 1
	fi

	log "found:"
	echo "$items" | while read -r name; do
		info "  ${name#env - }"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would restore .env files from Bitwarden to project dirs"
		exit 0
	fi

	echo ""
	warn "this will overwrite existing .env files"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	echo ""
	local restored=0
	while read -r item_name; do
		local relpath dest_file dest_dir content
		relpath="${item_name#env - }"
		dest_file="$PROJECTS_DIR/$relpath"
		dest_dir=$(dirname "$dest_file")

		content=$(bw get notes "$item_name" 2>/dev/null || echo "")
		if [[ -z "$content" ]]; then
			warn "  empty: $relpath (skipped)"
			continue
		fi

		mkdir -p "$dest_dir"
		echo "$content" > "$dest_file"
		info "  restored: $relpath"
		restored=$(( restored + 1 ))
	done <<< "$items"

	echo ""
	log "$restored .env file(s) restored"
}

# -----------------------------------------------------------------------
# List all secrets
# -----------------------------------------------------------------------
list_all() {
	echo ""

	# SSD
	if mountpoint -q "$SSD" 2>/dev/null; then
		log "SSD secrets:"
		echo ""

		# SSH
		if [[ -d "$SSH_BACKUP_DIR" ]]; then
			local ssh_count
			ssh_count=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "  SSH backups: $ssh_count"
			find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | while read -r b; do
				local size
				size=$(du -sh "$b" 2>/dev/null | cut -f1)
				echo -e "    ${BOLD}$(basename "$b")${NC}  $size"
			done
		else
			info "  SSH backups: none"
		fi

		# ENV
		if [[ -d "$ENV_BACKUP_DIR" ]]; then
			local env_count
			env_count=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "  Env backups: $env_count"
			find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | while read -r b; do
				local size
				size=$(du -sh "$b" 2>/dev/null | cut -f1)
				echo -e "    ${BOLD}$(basename "$b")${NC}  $size"
			done
		else
			info "  Env backups: none"
		fi
	else
		warn "SSD not mounted"
	fi

	echo ""

	# Bitwarden
	if command -v bw &>/dev/null; then
		local status
		status=$(bw status 2>/dev/null | jq -r '.status' 2>/dev/null || echo "unknown")
		log "Bitwarden: $status"

		if [[ "$status" == "unlocked" ]]; then
			local ssh_items env_items
			ssh_items=$(bw list items --search "SSH Key" 2>/dev/null | jq -r '.[].name' 2>/dev/null | wc -l || echo "0")
			env_items=$(bw list items --search "env -" 2>/dev/null | jq -r '.[].name' 2>/dev/null | grep "^env - " | wc -l || echo "0")
			info "  SSH keys: $ssh_items"
			info "  Env files: $env_items"
		else
			info "  unlock to see items: export BW_SESSION=\"\$(bw unlock --raw)\""
		fi
	else
		info "Bitwarden: not installed"
	fi
}

# -----------------------------------------------------------------------
# Usage
# -----------------------------------------------------------------------
usage() {
	echo ""
	echo -e "${BOLD}Usage:${NC} ./secrets <type> <action> [--bw] [--dry]"
	echo ""
	echo -e "${BOLD}SSH keys:${NC}"
	echo "  ./secrets ssh backup           encrypt SSH keys → SSD (age)"
	echo "  ./secrets ssh backup --bw      store SSH keys → Bitwarden"
	echo "  ./secrets ssh restore          decrypt SSH keys ← SSD (age)"
	echo "  ./secrets ssh restore --bw     retrieve SSH keys ← Bitwarden"
	echo ""
	echo -e "${BOLD}Environment files:${NC}"
	echo "  ./secrets env backup           encrypt .env files → SSD (age)"
	echo "  ./secrets env backup --bw      store .env files → Bitwarden"
	echo "  ./secrets env restore          decrypt .env files ← SSD (age)"
	echo "  ./secrets env restore --bw     retrieve .env files ← Bitwarden"
	echo "  ./secrets env list             list .env files in projects"
	echo ""
	echo -e "${BOLD}Other:${NC}"
	echo "  ./secrets --list               list all secrets on SSD/Bitwarden"
	echo "  ./secrets --dry <command>      preview mode"
	echo ""
}

# -----------------------------------------------------------------------
# Parse and dispatch
# -----------------------------------------------------------------------
dry_run=0
use_bw=0
type=""
action=""

for arg in "$@"; do
	case "$arg" in
		--dry)  dry_run=1 ;;
		--bw)   use_bw=1 ;;
		--list) list_all; exit 0 ;;
		--help|-h) usage; exit 0 ;;
		ssh|env)
			[[ -z "$type" ]] && type="$arg" ;;
		backup|restore|list)
			[[ -z "$action" ]] && action="$arg" ;;
		*)
			err "unknown argument: $arg"
			usage
			exit 1
			;;
	esac
done

if [[ -z "$type" || -z "$action" ]]; then
	usage
	exit 0
fi

case "${type}_${action}" in
	ssh_backup)
		[[ $use_bw -eq 1 ]] && ssh_backup_bw || ssh_backup_age ;;
	ssh_restore)
		[[ $use_bw -eq 1 ]] && ssh_restore_bw || ssh_restore_age ;;
	env_backup)
		[[ $use_bw -eq 1 ]] && env_backup_bw || env_backup_age ;;
	env_restore)
		[[ $use_bw -eq 1 ]] && env_restore_bw || env_restore_age ;;
	env_list)
		env_list ;;
	*)
		err "unknown command: $type $action"
		usage
		exit 1
		;;
esac
