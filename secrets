#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------
# Secrets manager — backup/restore SSH keys and .env files
#
# Backends:
#   age   — encrypted to external SSD (offline, passphrase-based)
#   bw    — Bitwarden vault (cloud, synced across devices)
#
# Usage:
#   ./secrets ssh backup              — backup SSH keys (age → SSD)
#   ./secrets ssh backup --bw         — backup SSH keys (→ Bitwarden)
#   ./secrets ssh restore             — restore SSH keys (age ← SSD)
#   ./secrets ssh restore --bw        — restore SSH keys (← Bitwarden)
#   ./secrets env backup              — backup .env files (age → SSD)
#   ./secrets env backup --bw         — backup .env files (→ Bitwarden)
#   ./secrets env restore             — restore .env files (age ← SSD)
#   ./secrets env restore --bw        — restore .env files (← Bitwarden)
#   ./secrets env list                — list .env files in projects
#   ./secrets --list                  — list all secrets on SSD/Bitwarden
#   ./secrets --dry                   — preview mode (any command)
# -----------------------------------------------------------------------

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "$script_dir/lib/config.sh"
SSH_DIR="$HOME/.ssh"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

log()  { echo -e "${GREEN}[secrets]${NC} $1"; }
warn() { echo -e "${YELLOW}[secrets]${NC} $1"; }
err()  { echo -e "${RED}[secrets]${NC} $1"; }
info() { echo -e "${BLUE}[secrets]${NC} $1"; }

# -----------------------------------------------------------------------
# Dependency checks
# -----------------------------------------------------------------------
ensure_age() {
	if ! command -v age &>/dev/null; then
		warn "age not found — installing..."
		if command -v yay &>/dev/null; then
			yay -S --noconfirm --needed age
		elif command -v pacman &>/dev/null; then
			sudo pacman -S --noconfirm --needed age
		else
			err "install age: https://github.com/FiloSottile/age"
			exit 1
		fi
	fi
}

ensure_bw() {
	if ! command -v bw &>/dev/null; then
		warn "bitwarden-cli not found — installing..."
		if command -v yay &>/dev/null; then
			yay -S --noconfirm --needed bitwarden-cli
		elif command -v pacman &>/dev/null; then
			sudo pacman -S --noconfirm --needed bitwarden-cli
		else
			err "install bitwarden-cli: sudo pacman -S bitwarden-cli"
			exit 1
		fi
	fi
	if ! command -v jq &>/dev/null; then
		warn "jq not found — installing..."
		if command -v yay &>/dev/null; then
			yay -S --noconfirm --needed jq
		else
			sudo pacman -S --noconfirm --needed jq
		fi
	fi
}

ensure_ssd() {
	if ! mountpoint -q "$SSD" 2>/dev/null; then
		err "SSD not mounted at $SSD"
		exit 1
	fi
}

# -----------------------------------------------------------------------
# Bitwarden session helper
# -----------------------------------------------------------------------
bw_unlock() {
	local session_file="${XDG_CONFIG_HOME:-$HOME/.config}/dev-env/.bw_session"

	# Load saved session if not already set
	if [[ -z "${BW_SESSION:-}" && -f "$session_file" ]]; then
		BW_SESSION=$(cat "$session_file" 2>/dev/null)
		export BW_SESSION
	fi

	local status
	status=$(bw status 2>/dev/null | jq -r '.status' 2>/dev/null || echo "unauthenticated")

	# If already unlocked (e.g. via bwu shell function), skip
	if [[ "$status" == "unlocked" ]]; then
		bw sync --quiet 2>/dev/null || true
		return
	fi

	if [[ "$status" == "unauthenticated" ]]; then
		log "logging in to Bitwarden..."
		BW_SESSION=$(bw login --raw) || { err "login failed"; exit 1; }
		export BW_SESSION
	fi

	if [[ "$status" == "locked" ]]; then
		log "unlocking Bitwarden vault..."
		BW_SESSION=$(bw unlock --raw) || { err "unlock failed"; exit 1; }
		export BW_SESSION
	fi

	# Save session for other shells/scripts
	mkdir -p "$(dirname "$session_file")"
	echo "$BW_SESSION" > "$session_file"
	chmod 600 "$session_file"

	bw sync --quiet 2>/dev/null || true
}

# -----------------------------------------------------------------------
# SSH: age backup (→ SSD)
# -----------------------------------------------------------------------
ssh_backup_age() {
	ensure_age
	ensure_ssd

	if [[ ! -d "$SSH_DIR" ]]; then
		err "no SSH directory at $SSH_DIR"
		exit 1
	fi

	echo ""
	log "SSH keys to backup:"
	local key_count=0
	for f in "$SSH_DIR"/*; do
		[[ -e "$f" ]] || continue
		local name size
		name=$(basename "$f")
		[[ "$name" == "known_hosts.old" ]] && continue
		size=$(du -sh "$f" 2>/dev/null | cut -f1)
		case "$name" in
			id_*|*.pem)
				[[ "$name" == *.pub ]] && info "  $name ($size) [public]" || info "  $name ($size) [private]"
				key_count=$(( key_count + 1 )) ;;
			config)       info "  $name ($size) [config]" ;;
			known_hosts)  info "  $name ($size) [known_hosts]" ;;
			*)            info "  $name ($size)" ;;
		esac
	done
	[[ $key_count -eq 0 ]] && { warn "no SSH keys found"; exit 0; }

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would encrypt ~/.ssh/ → $SSH_BACKUP_DIR/"
		exit 0
	fi

	local timestamp hostname backup_file
	timestamp=$(date +%Y-%m-%d_%H-%M-%S)
	hostname=$(hostname 2>/dev/null || echo "unknown")
	backup_file="$SSH_BACKUP_DIR/ssh-keys_${hostname}_${timestamp}.tar.age"
	mkdir -p "$SSH_BACKUP_DIR"

	echo ""
	log "encrypting SSH keys..."
	warn "choose a strong passphrase:"
	echo ""
	tar -C "$HOME" -cf - .ssh | age -p -o "$backup_file"

	local backup_size
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)
	echo ""
	log "SSH backup complete → $backup_file ($backup_size)"
	warn "remember your passphrase!"
}

# -----------------------------------------------------------------------
# SSH: age restore (← SSD)
# -----------------------------------------------------------------------
ssh_restore_age() {
	ensure_age
	ensure_ssd

	if [[ ! -d "$SSH_BACKUP_DIR" ]]; then
		err "no SSH backups at $SSH_BACKUP_DIR"
		exit 1
	fi

	mapfile -t backups < <(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort)
	[[ ${#backups[@]} -eq 0 ]] && { err "no SSH backups found"; exit 1; }

	local backup_file
	backup_file="${backups[-1]}"
	local backup_name backup_size
	backup_name=$(basename "$backup_file")
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)

	echo ""
	log "restoring from: $backup_name ($backup_size)"

	if [[ $dry_run -eq 1 ]]; then
		warn "DRY RUN — would decrypt to ~/.ssh/ and fix permissions"
		exit 0
	fi

	echo ""
	warn "this will overwrite ~/.ssh/"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	# Backup existing
	if [[ -d "$SSH_DIR" ]]; then
		local bak="$HOME/.ssh.bak.$(date +%Y%m%d-%H%M%S)"
		log "backing up existing → $bak"
		cp -r "$SSH_DIR" "$bak"
	fi

	# Decrypt
	echo ""
	log "decrypting..."
	local tmpdir
	tmpdir=$(mktemp -d)
	trap 'rm -rf "$tmpdir"' EXIT
	age -d "$backup_file" | tar -C "$tmpdir" -xf -
	[[ ! -d "$tmpdir/.ssh" ]] && { err "decryption failed"; exit 1; }

	mkdir -p "$SSH_DIR"
	cp -r "$tmpdir/.ssh/"* "$SSH_DIR/" 2>/dev/null || true
	cp -r "$tmpdir/.ssh/".[!.]* "$SSH_DIR/" 2>/dev/null || true

	# Fix permissions
	chmod 700 "$SSH_DIR"
	for f in "$SSH_DIR"/*; do
		[[ -e "$f" ]] || continue
		case "$(basename "$f")" in
			*.pub|known_hosts|known_hosts.old|authorized_keys) chmod 644 "$f" ;;
			*) chmod 600 "$f" ;;
		esac
	done

	echo ""
	log "SSH restore complete — test: ssh -T git@github.com"
}

# -----------------------------------------------------------------------
# SSH: Bitwarden backup (→ vault)
# -----------------------------------------------------------------------
ssh_backup_bw() {
	ensure_bw
	bw_unlock

	if [[ ! -f "$SSH_DIR/id_ed25519" ]]; then
		err "no SSH key at $SSH_DIR/id_ed25519"
		exit 1
	fi

	local privkey pubkey hostname
	privkey=$(cat "$SSH_DIR/id_ed25519")
	pubkey=$(cat "$SSH_DIR/id_ed25519.pub" 2>/dev/null || echo "")
	hostname=$(hostname 2>/dev/null || echo "unknown")

	echo ""
	info "private key: $SSH_DIR/id_ed25519"
	[[ -n "$pubkey" ]] && info "public key:  $SSH_DIR/id_ed25519.pub"
	echo ""

	if [[ $dry_run -eq 1 ]]; then
		warn "DRY RUN — would store SSH key in Bitwarden as secure note"
		exit 0
	fi

	local item_name="SSH Key - $hostname - id_ed25519"

	# Check if item already exists
	local existing
	existing=$(bw list items --search "$item_name" 2>/dev/null | jq -r '.[0].id // empty' 2>/dev/null || echo "")

	if [[ -n "$existing" ]]; then
		log "updating existing item: $item_name"
		bw get item "$existing" | jq \
			--arg key "$privkey" \
			--arg pub "$pubkey" \
			--arg date "$(date -I)" \
			'.notes = $key |
			 .fields = [
				{"name": "public_key", "value": $pub, "type": 0},
				{"name": "key_type", "value": "ed25519", "type": 0},
				{"name": "updated", "value": $date, "type": 0}
			 ]' \
			| bw encode | bw edit item "$existing" > /dev/null
	else
		log "creating new item: $item_name"
		bw get template item | jq \
			--arg key "$privkey" \
			--arg pub "$pubkey" \
			--arg name "$item_name" \
			--arg date "$(date -I)" \
			'.type = 2 |
			 .secureNote.type = 0 |
			 .name = $name |
			 .notes = $key |
			 .fields = [
				{"name": "public_key", "value": $pub, "type": 0},
				{"name": "key_type", "value": "ed25519", "type": 0},
				{"name": "created", "value": $date, "type": 0}
			 ]' \
			| bw encode | bw create item > /dev/null
	fi

	log "SSH key stored in Bitwarden vault"
}

# -----------------------------------------------------------------------
# SSH: Bitwarden restore (← vault)
# -----------------------------------------------------------------------
ssh_restore_bw() {
	ensure_bw
	bw_unlock

	echo ""
	log "searching Bitwarden for SSH keys..."

	local items
	items=$(bw list items --search "SSH Key" 2>/dev/null | jq -r '.[].name' 2>/dev/null || echo "")

	if [[ -z "$items" ]]; then
		err "no SSH keys found in Bitwarden"
		exit 1
	fi

	log "found:"
	echo "$items" | while read -r name; do
		info "  $name"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would restore SSH key from Bitwarden to ~/.ssh/"
		exit 0
	fi

	# Get the first SSH key item
	local item_name
	item_name=$(echo "$items" | head -1)

	echo ""
	warn "restoring: $item_name"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	# Backup existing
	if [[ -d "$SSH_DIR" ]]; then
		local bak="$HOME/.ssh.bak.$(date +%Y%m%d-%H%M%S)"
		log "backing up existing → $bak"
		cp -r "$SSH_DIR" "$bak"
	fi

	mkdir -p "$SSH_DIR"
	chmod 700 "$SSH_DIR"

	# Restore private key
	bw get item "$item_name" | jq -r '.notes' > "$SSH_DIR/id_ed25519"
	chmod 600 "$SSH_DIR/id_ed25519"
	log "restored: id_ed25519"

	# Restore public key
	local pubkey
	pubkey=$(bw get item "$item_name" | jq -r '.fields[] | select(.name=="public_key") | .value' 2>/dev/null || echo "")
	if [[ -n "$pubkey" ]]; then
		echo "$pubkey" > "$SSH_DIR/id_ed25519.pub"
		chmod 644 "$SSH_DIR/id_ed25519.pub"
		log "restored: id_ed25519.pub"
	fi

	echo ""
	log "SSH restore complete — test: ssh -T git@github.com"
}

# -----------------------------------------------------------------------
# ENV: find .env files
# -----------------------------------------------------------------------
find_env_files() {
	local project="${1:-}"
	local search_dir="$PROJECTS_DIR"
	[[ -n "$project" ]] && search_dir="$PROJECTS_DIR/$project"
	find "$search_dir" -maxdepth 4 \
		-name ".env" -o -name ".env.local" -o -name ".env.production" \
		-o -name ".env.development" 2>/dev/null \
		| grep -v node_modules \
		| grep -v .git/ \
		| grep -v __pycache__ \
		| grep -v .venv \
		| grep -v .conda \
		| sort
}

get_project_alias() {
	local dirname="$1"
	if [[ -f "$ENV_ALIAS_FILE" ]]; then
		local alias
		alias=$(grep "^${dirname}=" "$ENV_ALIAS_FILE" 2>/dev/null | head -1 | cut -d= -f2-)
		[[ -n "$alias" ]] && echo "$alias" && return
	fi
	echo ""
}

env_list() {
	echo ""
	if [[ -n "$target" ]]; then
		log ".env files in $PROJECTS_DIR/$target:"
	else
		log ".env files in $PROJECTS_DIR:"
	fi
	echo ""

	local count=0
	while read -r f; do
		[[ -f "$f" ]] || continue
		local relpath size lines project_dir alias_label
		relpath="${f#$PROJECTS_DIR/}"
		size=$(du -sh "$f" 2>/dev/null | cut -f1)
		lines=$(wc -l < "$f")
		project_dir="${relpath%%/*}"
		alias_label=$(get_project_alias "$project_dir")
		if [[ -n "$alias_label" ]]; then
			info "  $relpath  ($size, $lines lines)  ($alias_label)"
		else
			info "  $relpath  ($size, $lines lines)"
		fi
		count=$(( count + 1 ))
	done < <(find_env_files "$target")

	echo ""
	log "$count .env file(s) found"
}

# -----------------------------------------------------------------------
# ENV: age backup (→ SSD)
# -----------------------------------------------------------------------
env_backup_age() {
	ensure_age
	ensure_ssd

	local env_files=()
	while read -r f; do
		[[ -f "$f" ]] && env_files+=("$f")
	done < <(find_env_files "$target")

	if [[ ${#env_files[@]} -eq 0 ]]; then
		if [[ -n "$target" ]]; then
			warn "no .env files found in $target"
		else
			warn "no .env files found"
		fi
		exit 0
	fi

	echo ""
	log "${#env_files[@]} .env file(s) to backup${target:+ ($target)}:"
	for f in "${env_files[@]}"; do
		local relpath size
		relpath="${f#$PROJECTS_DIR/}"
		size=$(du -sh "$f" 2>/dev/null | cut -f1)
		info "  $relpath ($size)"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would encrypt .env files → $ENV_BACKUP_DIR/"
		exit 0
	fi

	local timestamp backup_file
	timestamp=$(date +%Y-%m-%d_%H-%M-%S)
	if [[ -n "$target" ]]; then
		backup_file="$ENV_BACKUP_DIR/env-secrets_${target}_${timestamp}.tar.age"
	else
		backup_file="$ENV_BACKUP_DIR/env-secrets_${timestamp}.tar.age"
	fi
	mkdir -p "$ENV_BACKUP_DIR"

	echo ""
	log "encrypting .env files..."
	warn "choose a strong passphrase:"
	echo ""

	# Create tar of all .env files preserving relative paths
	local tmplist
	tmplist=$(mktemp)
	for f in "${env_files[@]}"; do
		echo "${f#$HOME/}" >> "$tmplist"
	done

	tar -C "$HOME" -cf - -T "$tmplist" | age -p -o "$backup_file"
	rm -f "$tmplist"

	local backup_size
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)
	echo ""
	log "env backup complete → $backup_file ($backup_size)"
	log "${#env_files[@]} .env files encrypted"
	warn "remember your passphrase!"
}

# -----------------------------------------------------------------------
# ENV: age restore (← SSD)
# -----------------------------------------------------------------------
env_restore_age() {
	ensure_age
	ensure_ssd

	if [[ ! -d "$ENV_BACKUP_DIR" ]]; then
		err "no env backups at $ENV_BACKUP_DIR"
		exit 1
	fi

	# Find matching archives based on target
	local pattern
	if [[ -n "$target" ]]; then
		pattern="env-secrets_${target}_*.tar.age"
	else
		# Match only all-projects archives (timestamp starts with digit, no project name)
		pattern="env-secrets_[0-9]*.tar.age"
	fi
	mapfile -t backups < <(find "$ENV_BACKUP_DIR" -name "$pattern" -type f 2>/dev/null | sort)
	if [[ ${#backups[@]} -eq 0 ]]; then
		if [[ -n "$target" ]]; then
			err "no env backups found for $target"
		else
			err "no env backups found"
		fi
		exit 1
	fi

	local backup_file backup_name backup_size
	backup_file="${backups[-1]}"
	backup_name=$(basename "$backup_file")
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)

	echo ""
	log "restoring from: $backup_name ($backup_size)"
	[[ -n "$to_project" ]] && log "destination: $to_project/"

	if [[ $dry_run -eq 1 ]]; then
		if [[ -n "$to_project" ]]; then
			warn "DRY RUN — would decrypt .env files from ${target:-all} → $to_project/"
		else
			warn "DRY RUN — would decrypt .env files to their project directories"
		fi
		exit 0
	fi

	echo ""
	warn "this will overwrite existing .env files"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	echo ""
	log "decrypting..."

	if [[ -n "$to_project" ]]; then
		# Cross-project restore: extract to temp dir, then copy with preserved structure
		local tmpdir
		tmpdir=$(mktemp -d)
		trap 'rm -rf "$tmpdir"' EXIT
		age -d "$backup_file" | tar -C "$tmpdir" -xvf - 2>&1 | while read -r f; do
			info "  extracted: $f"
		done

		# Find source project root inside the extracted tree
		local src_root=""
		if [[ -n "$target" ]]; then
			# Look for the source project directory
			src_root=$(find "$tmpdir" -maxdepth 3 -type d -name "$target" 2>/dev/null | head -1)
		fi
		if [[ -z "$src_root" ]]; then
			# Fallback: use the deepest common path that has .env files
			src_root="$tmpdir"
		fi

		# Copy .env files preserving relative paths within the project
		local dest_dir="$PROJECTS_DIR/$to_project"
		find "$src_root" -maxdepth 5 \( -name ".env" -o -name ".env.local" -o -name ".env.production" -o -name ".env.development" \) 2>/dev/null | while read -r f; do
			local relpath="${f#$src_root/}"
			local dest_file="$dest_dir/$relpath"
			mkdir -p "$(dirname "$dest_file")"
			cp "$f" "$dest_file"
			info "  restored: $to_project/$relpath"
		done
	else
		age -d "$backup_file" | tar -C "$HOME" -xvf - 2>&1 | while read -r f; do
			info "  restored: $f"
		done
	fi

	echo ""
	log "env restore complete"
}

# -----------------------------------------------------------------------
# ENV: Bitwarden backup (→ vault)
# -----------------------------------------------------------------------
env_backup_bw() {
	ensure_bw
	bw_unlock

	local env_files=()
	while read -r f; do
		[[ -f "$f" ]] && env_files+=("$f")
	done < <(find_env_files "$target")

	if [[ ${#env_files[@]} -eq 0 ]]; then
		warn "no .env files found"
		exit 0
	fi

	echo ""
	log "${#env_files[@]} .env file(s) to backup:"
	for f in "${env_files[@]}"; do
		info "  ${f#$PROJECTS_DIR/}"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would store .env files in Bitwarden as secure notes"
		exit 0
	fi

	echo ""
	local stored=0
	for f in "${env_files[@]}"; do
		local relpath content item_name
		relpath="${f#$PROJECTS_DIR/}"
		content=$(cat "$f")
		item_name="env - $relpath"

		# Check if exists
		local existing
		existing=$(bw list items --search "$item_name" 2>/dev/null | jq -r '.[0].id // empty' 2>/dev/null || echo "")

		if [[ -n "$existing" ]]; then
			bw get item "$existing" | jq \
				--arg content "$content" \
				--arg date "$(date -I)" \
				'.notes = $content |
				 .fields = [{"name": "updated", "value": $date, "type": 0}]' \
				| bw encode | bw edit item "$existing" > /dev/null
			info "  updated: $relpath"
		else
			bw get template item | jq \
				--arg content "$content" \
				--arg name "$item_name" \
				--arg date "$(date -I)" \
				'.type = 2 |
				 .secureNote.type = 0 |
				 .name = $name |
				 .notes = $content |
				 .fields = [{"name": "created", "value": $date, "type": 0}]' \
				| bw encode | bw create item > /dev/null
			info "  created: $relpath"
		fi
		stored=$(( stored + 1 ))
	done

	echo ""
	log "$stored .env file(s) stored in Bitwarden vault"
}

# -----------------------------------------------------------------------
# ENV: Bitwarden restore (← vault)
# -----------------------------------------------------------------------
env_restore_bw() {
	ensure_bw
	bw_unlock

	echo ""
	log "searching Bitwarden for .env files..."

	local items
	if [[ -n "$target" ]]; then
		items=$(bw list items --search "env - $target/" 2>/dev/null | jq -r '.[].name' 2>/dev/null | grep "^env - $target/" || echo "")
	else
		items=$(bw list items --search "env -" 2>/dev/null | jq -r '.[].name' 2>/dev/null | grep "^env - " || echo "")
	fi

	if [[ -z "$items" ]]; then
		if [[ -n "$target" ]]; then
			err "no .env files found in Bitwarden for $target"
		else
			err "no .env files found in Bitwarden"
		fi
		exit 1
	fi

	log "found:"
	echo "$items" | while read -r name; do
		info "  ${name#env - }"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		if [[ -n "$to_project" ]]; then
			warn "DRY RUN — would restore .env files from Bitwarden (${target:-all}) → $to_project/"
		else
			warn "DRY RUN — would restore .env files from Bitwarden to project dirs"
		fi
		exit 0
	fi

	echo ""
	warn "this will overwrite existing .env files"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	echo ""
	local restored=0
	while read -r item_name; do
		local relpath dest_file dest_dir content
		relpath="${item_name#env - }"

		if [[ -n "$to_project" ]]; then
			# Cross-project: preserve directory structure under destination
			# relpath is like "projectA/subdir/.env" — strip source project prefix
			local inner_path="${relpath#*/}"
			dest_file="$PROJECTS_DIR/$to_project/$inner_path"
		else
			dest_file="$PROJECTS_DIR/$relpath"
		fi
		dest_dir=$(dirname "$dest_file")

		content=$(bw get notes "$item_name" 2>/dev/null || echo "")
		if [[ -z "$content" ]]; then
			warn "  empty: $relpath (skipped)"
			continue
		fi

		mkdir -p "$dest_dir"
		echo "$content" > "$dest_file"
		info "  restored: ${dest_file#$PROJECTS_DIR/}"
		restored=$(( restored + 1 ))
	done <<< "$items"

	echo ""
	log "$restored .env file(s) restored"
}

# -----------------------------------------------------------------------
# List all secrets
# -----------------------------------------------------------------------
list_all() {
	echo ""

	# SSD
	if mountpoint -q "$SSD" 2>/dev/null; then
		log "SSD secrets:"
		echo ""

		# SSH
		if [[ -d "$SSH_BACKUP_DIR" ]]; then
			local ssh_count
			ssh_count=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "  SSH backups: $ssh_count"
			find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | while read -r b; do
				local size
				size=$(du -sh "$b" 2>/dev/null | cut -f1)
				echo -e "    ${BOLD}$(basename "$b")${NC}  $size"
			done
		else
			info "  SSH backups: none"
		fi

		# ENV
		if [[ -d "$ENV_BACKUP_DIR" ]]; then
			local env_count
			env_count=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "  Env backups: $env_count"
			find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | while read -r b; do
				local size
				size=$(du -sh "$b" 2>/dev/null | cut -f1)
				echo -e "    ${BOLD}$(basename "$b")${NC}  $size"
			done
		else
			info "  Env backups: none"
		fi
	else
		warn "SSD not mounted"
	fi

	echo ""

	# Bitwarden
	if command -v bw &>/dev/null; then
		local status
		status=$(bw status 2>/dev/null | jq -r '.status' 2>/dev/null || echo "unknown")
		log "Bitwarden: $status"

		if [[ "$status" == "unlocked" ]]; then
			local ssh_items env_items
			ssh_items=$(bw list items --search "SSH Key" 2>/dev/null | jq -r '.[].name' 2>/dev/null | wc -l || echo "0")
			env_items=$(bw list items --search "env -" 2>/dev/null | jq -r '.[].name' 2>/dev/null | grep "^env - " | wc -l || echo "0")
			info "  SSH keys: $ssh_items"
			info "  Env files: $env_items"
		else
			info "  unlock to see items: export BW_SESSION=\"\$(bw unlock --raw)\""
		fi
	else
		info "Bitwarden: not installed"
	fi
}

# -----------------------------------------------------------------------
# Alias management (CLI)
# -----------------------------------------------------------------------
alias_list() {
	echo ""
	if [[ -f "$ENV_ALIAS_FILE" ]] && [[ -s "$ENV_ALIAS_FILE" ]]; then
		log "project aliases ($ENV_ALIAS_FILE):"
		echo ""
		while IFS='=' read -r dirname alias_name; do
			[[ -z "$dirname" || "$dirname" == \#* ]] && continue
			info "  $dirname = $alias_name"
		done < "$ENV_ALIAS_FILE"
	else
		warn "no aliases set"
	fi
}

alias_set() {
	local project="$1" alias_name="$2"
	if [[ -z "$project" || -z "$alias_name" ]]; then
		err "usage: ./secrets alias set <project> <name>"
		exit 1
	fi
	mkdir -p "$(dirname "$ENV_ALIAS_FILE")"
	if [[ -f "$ENV_ALIAS_FILE" ]] && grep -q "^${project}=" "$ENV_ALIAS_FILE" 2>/dev/null; then
		sed -i "s|^${project}=.*|${project}=${alias_name}|" "$ENV_ALIAS_FILE"
	else
		echo "${project}=${alias_name}" >> "$ENV_ALIAS_FILE"
	fi
	log "alias set: $project = $alias_name"
}

alias_remove() {
	local project="$1"
	if [[ -z "$project" ]]; then
		err "usage: ./secrets alias remove <project>"
		exit 1
	fi
	if [[ ! -f "$ENV_ALIAS_FILE" ]]; then
		warn "no aliases file"
		return
	fi
	if grep -q "^${project}=" "$ENV_ALIAS_FILE" 2>/dev/null; then
		sed -i "/^${project}=/d" "$ENV_ALIAS_FILE"
		log "removed alias for $project"
	else
		warn "no alias found for $project"
	fi
}

# -----------------------------------------------------------------------
# SSH copy-id (deploy key to remote server)
# -----------------------------------------------------------------------
ssh_copy_id() {
	local remote="$target"
	if [[ -z "$remote" ]]; then
		err "usage: ./secrets ssh copy-id user@server"
		exit 1
	fi

	# Find public keys
	local keys=()
	for f in "$SSH_DIR"/id_*.pub; do
		[[ -f "$f" ]] && keys+=("$f")
	done

	if [[ ${#keys[@]} -eq 0 ]]; then
		err "no public keys found in $SSH_DIR/"
		err "generate one: ssh-keygen -t ed25519"
		exit 1
	fi

	# Use first key by default, or specified key via target2
	local selected_key="${keys[0]}"
	if [[ -n "$target2" ]]; then
		if [[ -f "$SSH_DIR/$target2" ]]; then
			selected_key="$SSH_DIR/$target2"
		elif [[ -f "$SSH_DIR/$target2.pub" ]]; then
			selected_key="$SSH_DIR/$target2.pub"
		else
			err "key not found: $target2"
			exit 1
		fi
	fi

	log "copying $(basename "$selected_key") → $remote"

	if [[ $dry_run -eq 1 ]]; then
		warn "DRY RUN — would run: ssh-copy-id -i $selected_key $remote"
		exit 0
	fi

	ssh-copy-id -i "$selected_key" "$remote" || { err "ssh-copy-id failed"; exit 1; }

	echo ""
	log "key deployed! test with: ssh $remote"
}

# -----------------------------------------------------------------------
# SSH list (CLI)
# -----------------------------------------------------------------------
ssh_list() {
	echo ""
	log "local SSH keys ($SSH_DIR/):"
	echo ""
	if [[ ! -d "$SSH_DIR" ]]; then
		warn "no ~/.ssh/ directory"
		return
	fi
	for f in "$SSH_DIR"/*; do
		[[ -e "$f" ]] || continue
		local name perms size
		name=$(basename "$f")
		perms=$(stat -c '%a' "$f")
		size=$(du -sh "$f" 2>/dev/null | cut -f1)
		case "$name" in
			id_*|*.pem)
				if [[ "$name" == *.pub ]]; then
					info "  $name  ($perms)  $size  [public key]"
				else
					info "  $name  ($perms)  $size  [private key]"
				fi
				;;
			config)       info "  $name  ($perms)  $size  [ssh config]" ;;
			known_hosts)  info "  $name  ($perms)  $size  [known hosts]" ;;
			*)            info "  $name  ($perms)  $size" ;;
		esac
	done
}

# -----------------------------------------------------------------------
# Usage
# -----------------------------------------------------------------------
usage() {
	echo ""
	echo -e "${BOLD}Usage:${NC} ./secrets <type> <action> [project] [--bw] [--to <project>] [--ssd <path>] [--dry]"
	echo ""
	echo -e "${BOLD}SSH keys:${NC}"
	echo "  ./secrets ssh backup           encrypt SSH keys → SSD (age)"
	echo "  ./secrets ssh backup --bw      store SSH keys → Bitwarden"
	echo "  ./secrets ssh restore          decrypt SSH keys ← SSD (age)"
	echo "  ./secrets ssh restore --bw     retrieve SSH keys ← Bitwarden"
	echo "  ./secrets ssh list             list local SSH keys"
	echo "  ./secrets ssh copy-id <user@host>  copy public key to remote server"
	echo ""
	echo -e "${BOLD}Environment files (all projects):${NC}"
	echo "  ./secrets env backup           encrypt all .env files → SSD"
	echo "  ./secrets env backup --bw      store all .env files → Bitwarden"
	echo "  ./secrets env restore          decrypt all .env files ← SSD"
	echo "  ./secrets env restore --bw     retrieve all .env files ← Bitwarden"
	echo "  ./secrets env list             list all .env files"
	echo ""
	echo -e "${BOLD}Environment files (per-project):${NC}"
	echo "  ./secrets env backup <project>           only that project → SSD"
	echo "  ./secrets env backup <project> --bw      only that project → Bitwarden"
	echo "  ./secrets env restore <project>          only that project ← SSD"
	echo "  ./secrets env restore <project> --bw     only that project ← Bitwarden"
	echo "  ./secrets env list <project>             list only that project's .env files"
	echo ""
	echo -e "${BOLD}Cross-project restore:${NC}"
	echo "  ./secrets env restore <src> --to <dest>       copy src's .env → dest/ (SSD)"
	echo "  ./secrets env restore <src> --to <dest> --bw  copy src's .env → dest/ (Bitwarden)"
	echo ""
	echo -e "${BOLD}Aliases:${NC}"
	echo "  ./secrets alias list                    show all aliases"
	echo "  ./secrets alias set <project> <name>    set alias for project"
	echo "  ./secrets alias remove <project>        remove alias"
	echo ""
	echo -e "${BOLD}Other:${NC}"
	echo "  ./secrets --list               list all secrets on SSD/Bitwarden"
	echo "  ./secrets --ssd <path>         override SSD mount path"
	echo "  ./secrets --dry <command>      preview mode"
	echo ""
}

# -----------------------------------------------------------------------
# Parse and dispatch
# -----------------------------------------------------------------------
dry_run=0
use_bw=0
type=""
action=""
target=""
target2=""
to_project=""

_next_is_to=0
_next_is_ssd=0
for arg in "$@"; do
	if [[ $_next_is_to -eq 1 ]]; then
		to_project="$arg"
		_next_is_to=0
		continue
	fi
	if [[ $_next_is_ssd -eq 1 ]]; then
		SSD="$arg"
		SSH_BACKUP_DIR="$SSD/ssh-keys"
		ENV_BACKUP_DIR="$SSD/env-secrets"
		_next_is_ssd=0
		continue
	fi
	case "$arg" in
		--dry)  dry_run=1 ;;
		--bw)   use_bw=1 ;;
		--to)   _next_is_to=1 ;;
		--ssd)  _next_is_ssd=1 ;;
		--list) list_all; exit 0 ;;
		--help|-h) usage; exit 0 ;;
		ssh|env|alias)
			[[ -z "$type" ]] && type="$arg" ;;
		backup|restore|list|set|remove|copy-id)
			[[ -z "$action" ]] && action="$arg" ;;
		*)
			if [[ -z "$target" ]]; then
				target="$arg"
			elif [[ -z "$target2" ]]; then
				target2="$arg"
			else
				err "unknown argument: $arg"
				usage
				exit 1
			fi
			;;
	esac
done
unset _next_is_to _next_is_ssd

if [[ -z "$type" || -z "$action" ]]; then
	usage
	exit 0
fi

# Validate target project directory exists (for env commands, not list)
if [[ -n "$target" && "$type" == "env" && "$action" != "list" ]]; then
	if [[ ! -d "$PROJECTS_DIR/$target" ]]; then
		err "project directory not found: $PROJECTS_DIR/$target"
		exit 1
	fi
fi

case "${type}_${action}" in
	ssh_backup)
		[[ $use_bw -eq 1 ]] && ssh_backup_bw || ssh_backup_age ;;
	ssh_restore)
		[[ $use_bw -eq 1 ]] && ssh_restore_bw || ssh_restore_age ;;
	ssh_list)
		ssh_list ;;
	ssh_copy-id)
		ssh_copy_id ;;
	env_backup)
		[[ $use_bw -eq 1 ]] && env_backup_bw || env_backup_age ;;
	env_restore)
		[[ $use_bw -eq 1 ]] && env_restore_bw || env_restore_age ;;
	env_list)
		env_list ;;
	alias_list)
		alias_list ;;
	alias_set)
		alias_set "$target" "$target2"
		;;
	alias_remove)
		alias_remove "$target" ;;
	*)
		err "unknown command: $type $action"
		usage
		exit 1
		;;
esac
