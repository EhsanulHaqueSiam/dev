#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------
# Secrets manager — backup/restore SSH keys, .env files, and Claude config
#
# Backends:
#   age   — encrypted to external SSD (offline, passphrase-based)
#   bw    — Bitwarden vault (cloud, synced across devices)
#
# Usage:
#   ./secrets ssh backup              — backup SSH keys (age → SSD)
#   ./secrets ssh backup --bw         — backup SSH keys (→ Bitwarden)
#   ./secrets ssh restore             — restore SSH keys (age ← SSD)
#   ./secrets ssh restore --bw        — restore SSH keys (← Bitwarden)
#   ./secrets env backup              — backup .env files (age → SSD)
#   ./secrets env backup --bw         — backup .env files (→ Bitwarden)
#   ./secrets env restore             — restore .env files (age ← SSD)
#   ./secrets env restore --bw        — restore .env files (← Bitwarden)
#   ./secrets env list                — list .env files in projects
#   ./secrets claude backup           — backup Claude config (age → SSD)
#   ./secrets claude backup --bw      — backup Claude config (→ Bitwarden)
#   ./secrets claude restore          — restore Claude config (age ← SSD)
#   ./secrets claude restore --bw     — restore Claude config (← Bitwarden)
#   ./secrets claude list             — list Claude config files
#   ./secrets --list                  — list all secrets on SSD/Bitwarden
#   ./secrets --health                — health check dashboard
#   ./secrets --diff                  — show secrets changed since last backup
#   ./secrets --dry                   — preview mode (any command)
# -----------------------------------------------------------------------

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "$script_dir/lib/config.sh"
SSH_DIR="$HOME/.ssh"

# Claude config files to backup (contain MCP servers, API keys, plugins)
CLAUDE_CONFIG="$HOME/.claude.json"
CLAUDE_SETTINGS="$HOME/.claude/settings.json"
CLAUDE_MD="$HOME/.claude/CLAUDE.md"
CLAUDE_BACKUP_DIR="$SSD/claude-config"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

log()  { echo -e "${GREEN}[secrets]${NC} $1"; }
warn() { echo -e "${YELLOW}[secrets]${NC} $1"; }
err()  { echo -e "${RED}[secrets]${NC} $1"; }
info() { echo -e "${BLUE}[secrets]${NC} $1"; }

DEFAULT_KEEP=3

# Prune old age archives in a directory, keeping the newest N
prune_backups() {
	local dir="$1" keep="${2:-$DEFAULT_KEEP}"
	[[ ! -d "$dir" ]] && return
	mapfile -t archives < <(find "$dir" -name "*.tar.age" -type f 2>/dev/null | sort)
	local total=${#archives[@]}
	if (( total > keep )); then
		local prune_count=$(( total - keep ))
		log "pruning $prune_count old archive(s) in $(basename "$dir")/ (keeping $keep)..."
		for (( i=0; i<prune_count; i++ )); do
			info "  removing: $(basename "${archives[$i]}")"
			rm -f "${archives[$i]}"
		done
	fi
}

# -----------------------------------------------------------------------
# Dependency checks
# -----------------------------------------------------------------------
ensure_age() {
	if ! command -v age &>/dev/null; then
		warn "age not found — installing..."
		if command -v yay &>/dev/null; then
			yay -S --noconfirm --needed age
		elif command -v pacman &>/dev/null; then
			sudo pacman -S --noconfirm --needed age
		else
			err "install age: https://github.com/FiloSottile/age"
			exit 1
		fi
	fi
}

ensure_bw() {
	if ! command -v bw &>/dev/null; then
		warn "bitwarden-cli not found — installing..."
		if command -v yay &>/dev/null; then
			yay -S --noconfirm --needed bitwarden-cli
		elif command -v pacman &>/dev/null; then
			sudo pacman -S --noconfirm --needed bitwarden-cli
		else
			err "install bitwarden-cli: sudo pacman -S bitwarden-cli"
			exit 1
		fi
	fi
	if ! command -v jq &>/dev/null; then
		warn "jq not found — installing..."
		if command -v yay &>/dev/null; then
			yay -S --noconfirm --needed jq
		else
			sudo pacman -S --noconfirm --needed jq
		fi
	fi
}

ensure_ssd() {
	if ! mountpoint -q "$SSD" 2>/dev/null; then
		try_mount_ssd || { err "SSD not mounted at $SSD (and auto-mount failed)"; exit 1; }
	fi
}

# -----------------------------------------------------------------------
# Bitwarden session helper
# -----------------------------------------------------------------------
bw_unlock() {
	local session_file="${XDG_CONFIG_HOME:-$HOME/.config}/dev-env/.bw_session"

	# Load saved session if not already set
	if [[ -z "${BW_SESSION:-}" && -f "$session_file" ]]; then
		BW_SESSION=$(cat "$session_file" 2>/dev/null)
		export BW_SESSION
	fi

	local status
	status=$(bw status 2>/dev/null | jq -r '.status' 2>/dev/null || echo "unauthenticated")

	# If already unlocked (e.g. via bwu shell function), skip
	if [[ "$status" == "unlocked" ]]; then
		bw sync --quiet 2>/dev/null || true
		return
	fi

	if [[ "$status" == "unauthenticated" ]]; then
		log "logging in to Bitwarden..."
		BW_SESSION=$(bw login --raw) || { err "login failed"; exit 1; }
		export BW_SESSION
	fi

	if [[ "$status" == "locked" ]]; then
		log "unlocking Bitwarden vault..."
		BW_SESSION=$(bw unlock --raw) || { err "unlock failed"; exit 1; }
		export BW_SESSION
	fi

	# Save session for other shells/scripts
	mkdir -p "$(dirname "$session_file")"
	echo "$BW_SESSION" > "$session_file"
	chmod 600 "$session_file"

	bw sync --quiet 2>/dev/null || true
}

# -----------------------------------------------------------------------
# SSH: age backup (→ SSD)
# -----------------------------------------------------------------------
ssh_backup_age() {
	ensure_age
	ensure_ssd

	if [[ ! -d "$SSH_DIR" ]]; then
		err "no SSH directory at $SSH_DIR"
		exit 1
	fi

	echo ""
	log "SSH keys to backup:"
	local key_count=0
	for f in "$SSH_DIR"/*; do
		[[ -e "$f" ]] || continue
		local name size
		name=$(basename "$f")
		[[ "$name" == "known_hosts.old" ]] && continue
		size=$(du -sh "$f" 2>/dev/null | cut -f1)
		case "$name" in
			id_*|*.pem)
				[[ "$name" == *.pub ]] && info "  $name ($size) [public]" || info "  $name ($size) [private]"
				key_count=$(( key_count + 1 )) ;;
			config)       info "  $name ($size) [config]" ;;
			known_hosts)  info "  $name ($size) [known_hosts]" ;;
			*)            info "  $name ($size)" ;;
		esac
	done
	[[ $key_count -eq 0 ]] && { warn "no SSH keys found"; exit 0; }

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would encrypt ~/.ssh/ → $SSH_BACKUP_DIR/"
		exit 0
	fi

	local timestamp hostname backup_file
	timestamp=$(date +%Y-%m-%d_%H-%M-%S)
	hostname=$(hostname 2>/dev/null || echo "unknown")
	backup_file="$SSH_BACKUP_DIR/ssh-keys_${hostname}_${timestamp}.tar.age"
	mkdir -p "$SSH_BACKUP_DIR"

	echo ""
	log "encrypting SSH keys..."
	warn "choose a strong passphrase:"
	echo ""
	tar -C "$HOME" -cf - .ssh | age -p -o "$backup_file"

	local backup_size
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)
	echo ""
	log "SSH backup complete → $backup_file ($backup_size)"
	prune_backups "$SSH_BACKUP_DIR" "$keep"
	warn "remember your passphrase!"
}

# -----------------------------------------------------------------------
# SSH: age restore (← SSD)
# -----------------------------------------------------------------------
ssh_restore_age() {
	ensure_age
	ensure_ssd

	if [[ ! -d "$SSH_BACKUP_DIR" ]]; then
		err "no SSH backups at $SSH_BACKUP_DIR"
		exit 1
	fi

	mapfile -t backups < <(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort)
	[[ ${#backups[@]} -eq 0 ]] && { err "no SSH backups found"; exit 1; }

	local backup_file
	backup_file="${backups[-1]}"
	local backup_name backup_size
	backup_name=$(basename "$backup_file")
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)

	echo ""
	log "restoring from: $backup_name ($backup_size)"

	if [[ $dry_run -eq 1 ]]; then
		warn "DRY RUN — would decrypt to ~/.ssh/ and fix permissions"
		exit 0
	fi

	echo ""
	warn "this will overwrite ~/.ssh/"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	# Backup existing
	if [[ -d "$SSH_DIR" ]]; then
		local bak="$HOME/.ssh.bak.$(date +%Y%m%d-%H%M%S)"
		log "backing up existing → $bak"
		cp -r "$SSH_DIR" "$bak"
	fi

	# Decrypt
	echo ""
	log "decrypting..."
	local tmpdir
	tmpdir=$(mktemp -d)
	trap 'rm -rf "$tmpdir"' EXIT
	age -d "$backup_file" | tar -C "$tmpdir" -xf -
	[[ ! -d "$tmpdir/.ssh" ]] && { err "decryption failed"; exit 1; }

	mkdir -p "$SSH_DIR"
	cp -r "$tmpdir/.ssh/"* "$SSH_DIR/" 2>/dev/null || true
	cp -r "$tmpdir/.ssh/".[!.]* "$SSH_DIR/" 2>/dev/null || true

	# Fix permissions
	chmod 700 "$SSH_DIR"
	for f in "$SSH_DIR"/*; do
		[[ -e "$f" ]] || continue
		case "$(basename "$f")" in
			*.pub|known_hosts|known_hosts.old|authorized_keys) chmod 644 "$f" ;;
			*) chmod 600 "$f" ;;
		esac
	done

	echo ""
	log "SSH restore complete — test: ssh -T git@github.com"
}

# -----------------------------------------------------------------------
# SSH: Bitwarden backup (→ vault)
# -----------------------------------------------------------------------
ssh_backup_bw() {
	ensure_bw
	bw_unlock

	if [[ ! -f "$SSH_DIR/id_ed25519" ]]; then
		err "no SSH key at $SSH_DIR/id_ed25519"
		exit 1
	fi

	local privkey pubkey hostname
	privkey=$(cat "$SSH_DIR/id_ed25519")
	pubkey=$(cat "$SSH_DIR/id_ed25519.pub" 2>/dev/null || echo "")
	hostname=$(hostname 2>/dev/null || echo "unknown")

	echo ""
	info "private key: $SSH_DIR/id_ed25519"
	[[ -n "$pubkey" ]] && info "public key:  $SSH_DIR/id_ed25519.pub"
	echo ""

	if [[ $dry_run -eq 1 ]]; then
		warn "DRY RUN — would store SSH key in Bitwarden as secure note"
		exit 0
	fi

	local item_name="SSH Key - $hostname - id_ed25519"

	# Check if item already exists
	local existing
	existing=$(bw list items --search "$item_name" 2>/dev/null | jq -r '.[0].id // empty' 2>/dev/null || echo "")

	if [[ -n "$existing" ]]; then
		log "updating existing item: $item_name"
		bw get item "$existing" | jq \
			--arg key "$privkey" \
			--arg pub "$pubkey" \
			--arg date "$(date -I)" \
			'.notes = $key |
			 .fields = [
				{"name": "public_key", "value": $pub, "type": 0},
				{"name": "key_type", "value": "ed25519", "type": 0},
				{"name": "updated", "value": $date, "type": 0}
			 ]' \
			| bw encode | bw edit item "$existing" > /dev/null
	else
		log "creating new item: $item_name"
		bw get template item | jq \
			--arg key "$privkey" \
			--arg pub "$pubkey" \
			--arg name "$item_name" \
			--arg date "$(date -I)" \
			'.type = 2 |
			 .secureNote.type = 0 |
			 .name = $name |
			 .notes = $key |
			 .fields = [
				{"name": "public_key", "value": $pub, "type": 0},
				{"name": "key_type", "value": "ed25519", "type": 0},
				{"name": "created", "value": $date, "type": 0}
			 ]' \
			| bw encode | bw create item > /dev/null
	fi

	log "SSH key stored in Bitwarden vault"
}

# -----------------------------------------------------------------------
# SSH: Bitwarden restore (← vault)
# -----------------------------------------------------------------------
ssh_restore_bw() {
	ensure_bw
	bw_unlock

	echo ""
	log "searching Bitwarden for SSH keys..."

	local items
	items=$(bw list items --search "SSH Key" 2>/dev/null | jq -r '.[].name' 2>/dev/null || echo "")

	if [[ -z "$items" ]]; then
		err "no SSH keys found in Bitwarden"
		exit 1
	fi

	log "found:"
	echo "$items" | while read -r name; do
		info "  $name"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would restore SSH key from Bitwarden to ~/.ssh/"
		exit 0
	fi

	# Get the first SSH key item
	local item_name
	item_name=$(echo "$items" | head -1)

	echo ""
	warn "restoring: $item_name"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	# Backup existing
	if [[ -d "$SSH_DIR" ]]; then
		local bak="$HOME/.ssh.bak.$(date +%Y%m%d-%H%M%S)"
		log "backing up existing → $bak"
		cp -r "$SSH_DIR" "$bak"
	fi

	mkdir -p "$SSH_DIR"
	chmod 700 "$SSH_DIR"

	# Restore private key
	bw get item "$item_name" | jq -r '.notes' > "$SSH_DIR/id_ed25519"
	chmod 600 "$SSH_DIR/id_ed25519"
	log "restored: id_ed25519"

	# Restore public key
	local pubkey
	pubkey=$(bw get item "$item_name" | jq -r '.fields[] | select(.name=="public_key") | .value' 2>/dev/null || echo "")
	if [[ -n "$pubkey" ]]; then
		echo "$pubkey" > "$SSH_DIR/id_ed25519.pub"
		chmod 644 "$SSH_DIR/id_ed25519.pub"
		log "restored: id_ed25519.pub"
	fi

	echo ""
	log "SSH restore complete — test: ssh -T git@github.com"
}

# -----------------------------------------------------------------------
# ENV: find .env files
# -----------------------------------------------------------------------
find_env_files() {
	local project="${1:-}"
	local search_dir="$PROJECTS_DIR"
	[[ -n "$project" ]] && search_dir="$PROJECTS_DIR/$project"
	find "$search_dir" -maxdepth 4 -type f \
		\( -name ".env" -o -name ".env.local" -o -name ".env.production" \
		-o -name ".env.development" \) 2>/dev/null \
		| grep -v node_modules \
		| grep -v .git/ \
		| grep -v __pycache__ \
		| grep -v .venv \
		| grep -v .conda \
		| sort
}

get_project_alias() {
	local dirname="$1"
	if [[ -f "$ENV_ALIAS_FILE" ]]; then
		local alias
		alias=$(grep "^${dirname}=" "$ENV_ALIAS_FILE" 2>/dev/null | head -1 | cut -d= -f2-)
		[[ -n "$alias" ]] && echo "$alias" && return
	fi
	echo ""
}

env_list() {
	echo ""
	if [[ -n "$target" ]]; then
		log ".env files in $PROJECTS_DIR/$target:"
	else
		log ".env files in $PROJECTS_DIR:"
	fi
	echo ""

	local count=0
	while read -r f; do
		[[ -f "$f" ]] || continue
		local relpath size lines project_dir alias_label
		relpath="${f#$PROJECTS_DIR/}"
		size=$(du -sh "$f" 2>/dev/null | cut -f1)
		lines=$(wc -l < "$f")
		project_dir="${relpath%%/*}"
		alias_label=$(get_project_alias "$project_dir")
		if [[ -n "$alias_label" ]]; then
			info "  $relpath  ($size, $lines lines)  ($alias_label)"
		else
			info "  $relpath  ($size, $lines lines)"
		fi
		count=$(( count + 1 ))
	done < <(find_env_files "$target")

	echo ""
	log "$count .env file(s) found"
}

# -----------------------------------------------------------------------
# ENV: age backup (→ SSD)
# -----------------------------------------------------------------------
env_backup_age() {
	ensure_age
	ensure_ssd

	local env_files=()
	while read -r f; do
		[[ -f "$f" ]] && env_files+=("$f")
	done < <(find_env_files "$target")

	if [[ ${#env_files[@]} -eq 0 ]]; then
		if [[ -n "$target" ]]; then
			warn "no .env files found in $target"
		else
			warn "no .env files found"
		fi
		exit 0
	fi

	echo ""
	log "${#env_files[@]} .env file(s) to backup${target:+ ($target)}:"
	for f in "${env_files[@]}"; do
		local relpath size
		relpath="${f#$PROJECTS_DIR/}"
		size=$(du -sh "$f" 2>/dev/null | cut -f1)
		info "  $relpath ($size)"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would encrypt .env files → $ENV_BACKUP_DIR/"
		exit 0
	fi

	local timestamp backup_file
	timestamp=$(date +%Y-%m-%d_%H-%M-%S)
	if [[ -n "$target" ]]; then
		backup_file="$ENV_BACKUP_DIR/env-secrets_${target}_${timestamp}.tar.age"
	else
		backup_file="$ENV_BACKUP_DIR/env-secrets_${timestamp}.tar.age"
	fi
	mkdir -p "$ENV_BACKUP_DIR"

	echo ""
	log "encrypting .env files..."
	warn "choose a strong passphrase:"
	echo ""

	# Create tar of all .env files preserving relative paths
	local tmplist
	tmplist=$(mktemp)
	for f in "${env_files[@]}"; do
		echo "${f#$HOME/}" >> "$tmplist"
	done

	tar -C "$HOME" -cf - -T "$tmplist" | age -p -o "$backup_file"
	rm -f "$tmplist"

	local backup_size
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)
	echo ""
	log "env backup complete → $backup_file ($backup_size)"
	log "${#env_files[@]} .env files encrypted"
	prune_backups "$ENV_BACKUP_DIR" "$keep"
	warn "remember your passphrase!"
}

# -----------------------------------------------------------------------
# ENV: age restore (← SSD)
# -----------------------------------------------------------------------
env_restore_age() {
	ensure_age
	ensure_ssd

	if [[ ! -d "$ENV_BACKUP_DIR" ]]; then
		err "no env backups at $ENV_BACKUP_DIR"
		exit 1
	fi

	# Find matching archives based on target
	local pattern
	if [[ -n "$target" ]]; then
		pattern="env-secrets_${target}_*.tar.age"
	else
		# Match only all-projects archives (timestamp starts with digit, no project name)
		pattern="env-secrets_[0-9]*.tar.age"
	fi
	mapfile -t backups < <(find "$ENV_BACKUP_DIR" -name "$pattern" -type f 2>/dev/null | sort)
	if [[ ${#backups[@]} -eq 0 ]]; then
		if [[ -n "$target" ]]; then
			err "no env backups found for $target"
		else
			err "no env backups found"
		fi
		exit 1
	fi

	local backup_file backup_name backup_size
	backup_file="${backups[-1]}"
	backup_name=$(basename "$backup_file")
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)

	echo ""
	log "restoring from: $backup_name ($backup_size)"
	[[ -n "$to_project" ]] && log "destination: $to_project/"

	if [[ $dry_run -eq 1 ]]; then
		if [[ -n "$to_project" ]]; then
			warn "DRY RUN — would decrypt .env files from ${target:-all} → $to_project/"
		else
			warn "DRY RUN — would decrypt .env files to their project directories"
		fi
		exit 0
	fi

	echo ""
	warn "this will overwrite existing .env files"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	echo ""
	log "decrypting..."

	if [[ -n "$to_project" ]]; then
		# Cross-project restore: extract to temp dir, then copy with preserved structure
		local tmpdir
		tmpdir=$(mktemp -d)
		trap 'rm -rf "$tmpdir"' EXIT
		age -d "$backup_file" | tar -C "$tmpdir" -xvf - 2>&1 | while read -r f; do
			info "  extracted: $f"
		done

		# Find source project root inside the extracted tree
		local src_root=""
		if [[ -n "$target" ]]; then
			# Look for the source project directory
			src_root=$(find "$tmpdir" -maxdepth 3 -type d -name "$target" 2>/dev/null | head -1)
		fi
		if [[ -z "$src_root" ]]; then
			# Fallback: use the deepest common path that has .env files
			src_root="$tmpdir"
		fi

		# Copy .env files preserving relative paths within the project
		local dest_dir="$PROJECTS_DIR/$to_project"
		find "$src_root" -maxdepth 5 \( -name ".env" -o -name ".env.local" -o -name ".env.production" -o -name ".env.development" \) 2>/dev/null | while read -r f; do
			local relpath="${f#$src_root/}"
			local dest_file="$dest_dir/$relpath"
			mkdir -p "$(dirname "$dest_file")"
			cp "$f" "$dest_file"
			info "  restored: $to_project/$relpath"
		done
	else
		age -d "$backup_file" | tar -C "$HOME" -xvf - 2>&1 | while read -r f; do
			info "  restored: $f"
		done
	fi

	echo ""
	log "env restore complete"
}

# -----------------------------------------------------------------------
# ENV: Bitwarden backup (→ vault)
# -----------------------------------------------------------------------
env_backup_bw() {
	ensure_bw
	bw_unlock

	local env_files=()
	while read -r f; do
		[[ -f "$f" ]] && env_files+=("$f")
	done < <(find_env_files "$target")

	if [[ ${#env_files[@]} -eq 0 ]]; then
		warn "no .env files found"
		exit 0
	fi

	echo ""
	log "${#env_files[@]} .env file(s) to backup:"
	for f in "${env_files[@]}"; do
		info "  ${f#$PROJECTS_DIR/}"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would store .env files in Bitwarden as secure notes"
		exit 0
	fi

	echo ""
	local stored=0
	for f in "${env_files[@]}"; do
		local relpath content item_name
		relpath="${f#$PROJECTS_DIR/}"
		content=$(cat "$f")
		item_name="env - $relpath"

		# Check if exists
		local existing
		existing=$(bw list items --search "$item_name" 2>/dev/null | jq -r '.[0].id // empty' 2>/dev/null || echo "")

		if [[ -n "$existing" ]]; then
			bw get item "$existing" | jq \
				--arg content "$content" \
				--arg date "$(date -I)" \
				'.notes = $content |
				 .fields = [{"name": "updated", "value": $date, "type": 0}]' \
				| bw encode | bw edit item "$existing" > /dev/null
			info "  updated: $relpath"
		else
			bw get template item | jq \
				--arg content "$content" \
				--arg name "$item_name" \
				--arg date "$(date -I)" \
				'.type = 2 |
				 .secureNote.type = 0 |
				 .name = $name |
				 .notes = $content |
				 .fields = [{"name": "created", "value": $date, "type": 0}]' \
				| bw encode | bw create item > /dev/null
			info "  created: $relpath"
		fi
		stored=$(( stored + 1 ))
	done

	echo ""
	log "$stored .env file(s) stored in Bitwarden vault"
}

# -----------------------------------------------------------------------
# ENV: Bitwarden restore (← vault)
# -----------------------------------------------------------------------
env_restore_bw() {
	ensure_bw
	bw_unlock

	echo ""
	log "searching Bitwarden for .env files..."

	local items
	if [[ -n "$target" ]]; then
		items=$(bw list items --search "env - $target/" 2>/dev/null | jq -r '.[].name' 2>/dev/null | grep "^env - $target/" || echo "")
	else
		items=$(bw list items --search "env -" 2>/dev/null | jq -r '.[].name' 2>/dev/null | grep "^env - " || echo "")
	fi

	if [[ -z "$items" ]]; then
		if [[ -n "$target" ]]; then
			err "no .env files found in Bitwarden for $target"
		else
			err "no .env files found in Bitwarden"
		fi
		exit 1
	fi

	log "found:"
	echo "$items" | while read -r name; do
		info "  ${name#env - }"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		if [[ -n "$to_project" ]]; then
			warn "DRY RUN — would restore .env files from Bitwarden (${target:-all}) → $to_project/"
		else
			warn "DRY RUN — would restore .env files from Bitwarden to project dirs"
		fi
		exit 0
	fi

	echo ""
	warn "this will overwrite existing .env files"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	echo ""
	local restored=0
	while read -r item_name; do
		local relpath dest_file dest_dir content
		relpath="${item_name#env - }"

		if [[ -n "$to_project" ]]; then
			# Cross-project: preserve directory structure under destination
			# relpath is like "projectA/subdir/.env" — strip source project prefix
			local inner_path="${relpath#*/}"
			dest_file="$PROJECTS_DIR/$to_project/$inner_path"
		else
			dest_file="$PROJECTS_DIR/$relpath"
		fi
		dest_dir=$(dirname "$dest_file")

		content=$(bw get notes "$item_name" 2>/dev/null || echo "")
		if [[ -z "$content" ]]; then
			warn "  empty: $relpath (skipped)"
			continue
		fi

		mkdir -p "$dest_dir"
		printf '%s\n' "$content" > "$dest_file"
		info "  restored: ${dest_file#$PROJECTS_DIR/}"
		restored=$(( restored + 1 ))
	done <<< "$items"

	echo ""
	log "$restored .env file(s) restored"
}

# -----------------------------------------------------------------------
# Claude: find config files
# -----------------------------------------------------------------------
find_claude_files() {
	local files=()
	[[ -f "$CLAUDE_CONFIG" ]] && files+=("$CLAUDE_CONFIG")
	[[ -f "$CLAUDE_SETTINGS" ]] && files+=("$CLAUDE_SETTINGS")
	[[ -f "$CLAUDE_MD" ]] && files+=("$CLAUDE_MD")
	printf '%s\n' "${files[@]}"
}

claude_list() {
	echo ""
	log "Claude config files:"
	echo ""

	local count=0
	for f in "$CLAUDE_CONFIG" "$CLAUDE_SETTINGS" "$CLAUDE_MD"; do
		if [[ -f "$f" ]]; then
			local size
			size=$(du -sh "$f" 2>/dev/null | cut -f1)
			info "  $f  ($size)"
			count=$(( count + 1 ))
		else
			warn "  $f  (missing)"
		fi
	done

	# Show MCP server count from .claude.json
	if [[ -f "$CLAUDE_CONFIG" ]] && command -v jq &>/dev/null; then
		local mcp_count plugin_count
		mcp_count=$(jq '.mcpServers | length' "$CLAUDE_CONFIG" 2>/dev/null || echo "0")
		echo ""
		info "  MCP servers: $mcp_count"
		if [[ -f "$CLAUDE_SETTINGS" ]]; then
			plugin_count=$(jq '.enabledPlugins | length' "$CLAUDE_SETTINGS" 2>/dev/null || echo "0")
			info "  Plugins: $plugin_count"
		fi
	fi

	echo ""
	log "$count config file(s) found"
}

# -----------------------------------------------------------------------
# Claude: age backup (→ SSD)
# -----------------------------------------------------------------------
claude_backup_age() {
	ensure_age
	ensure_ssd

	local claude_files=()
	while read -r f; do
		[[ -f "$f" ]] && claude_files+=("$f")
	done < <(find_claude_files)

	if [[ ${#claude_files[@]} -eq 0 ]]; then
		warn "no Claude config files found"
		exit 0
	fi

	echo ""
	log "${#claude_files[@]} Claude config file(s) to backup:"
	for f in "${claude_files[@]}"; do
		local size
		size=$(du -sh "$f" 2>/dev/null | cut -f1)
		info "  $f ($size)"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would encrypt Claude configs → $CLAUDE_BACKUP_DIR/"
		exit 0
	fi

	local timestamp backup_file
	timestamp=$(date +%Y-%m-%d_%H-%M-%S)
	backup_file="$CLAUDE_BACKUP_DIR/claude-config_${timestamp}.tar.age"
	mkdir -p "$CLAUDE_BACKUP_DIR"

	echo ""
	log "encrypting Claude configs..."
	warn "choose a strong passphrase:"
	echo ""

	# Create tar preserving paths relative to $HOME
	local tmplist
	tmplist=$(mktemp)
	for f in "${claude_files[@]}"; do
		echo "${f#$HOME/}" >> "$tmplist"
	done

	tar -C "$HOME" -cf - -T "$tmplist" | age -p -o "$backup_file"
	rm -f "$tmplist"

	local backup_size
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)
	echo ""
	log "Claude backup complete → $backup_file ($backup_size)"
	log "${#claude_files[@]} config files encrypted"
	prune_backups "$CLAUDE_BACKUP_DIR" "$keep"
	warn "remember your passphrase!"
}

# -----------------------------------------------------------------------
# Claude: age restore (← SSD)
# -----------------------------------------------------------------------
claude_restore_age() {
	ensure_age
	ensure_ssd

	if [[ ! -d "$CLAUDE_BACKUP_DIR" ]]; then
		err "no Claude backups at $CLAUDE_BACKUP_DIR"
		exit 1
	fi

	mapfile -t backups < <(find "$CLAUDE_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort)
	[[ ${#backups[@]} -eq 0 ]] && { err "no Claude backups found"; exit 1; }

	local backup_file backup_name backup_size
	backup_file="${backups[-1]}"
	backup_name=$(basename "$backup_file")
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)

	echo ""
	log "restoring from: $backup_name ($backup_size)"

	if [[ $dry_run -eq 1 ]]; then
		warn "DRY RUN — would decrypt Claude configs to ~/.claude.json and ~/.claude/"
		exit 0
	fi

	echo ""
	warn "this will overwrite existing Claude config files"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	echo ""
	log "decrypting..."
	age -d "$backup_file" | tar -C "$HOME" -xvf - 2>&1 | while read -r f; do
		info "  restored: ~/$f"
	done

	echo ""
	log "Claude restore complete — restart Claude Code to pick up changes"
}

# -----------------------------------------------------------------------
# Claude: Bitwarden backup (→ vault)
# -----------------------------------------------------------------------
claude_backup_bw() {
	ensure_bw
	bw_unlock

	local claude_files=()
	while read -r f; do
		[[ -f "$f" ]] && claude_files+=("$f")
	done < <(find_claude_files)

	if [[ ${#claude_files[@]} -eq 0 ]]; then
		warn "no Claude config files found"
		exit 0
	fi

	echo ""
	log "${#claude_files[@]} Claude config file(s) to backup:"
	for f in "${claude_files[@]}"; do
		info "  $f"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would store Claude configs in Bitwarden"
		exit 0
	fi

	echo ""
	local stored=0
	for f in "${claude_files[@]}"; do
		local name content item_name
		name="${f#$HOME/}"
		content=$(cat "$f")
		item_name="claude - $name"

		local existing
		existing=$(bw list items --search "$item_name" 2>/dev/null | jq -r '.[0].id // empty' 2>/dev/null || echo "")

		if [[ -n "$existing" ]]; then
			bw get item "$existing" | jq \
				--arg content "$content" \
				--arg date "$(date -I)" \
				'.notes = $content |
				 .fields = [{"name": "updated", "value": $date, "type": 0}]' \
				| bw encode | bw edit item "$existing" > /dev/null
			info "  updated: $name"
		else
			bw get template item | jq \
				--arg content "$content" \
				--arg name "$item_name" \
				--arg date "$(date -I)" \
				'.type = 2 |
				 .secureNote.type = 0 |
				 .name = $name |
				 .notes = $content |
				 .fields = [{"name": "created", "value": $date, "type": 0}]' \
				| bw encode | bw create item > /dev/null
			info "  created: $name"
		fi
		stored=$(( stored + 1 ))
	done

	echo ""
	log "$stored Claude config(s) stored in Bitwarden vault"
}

# -----------------------------------------------------------------------
# Claude: Bitwarden restore (← vault)
# -----------------------------------------------------------------------
claude_restore_bw() {
	ensure_bw
	bw_unlock

	echo ""
	log "searching Bitwarden for Claude configs..."

	local items
	items=$(bw list items --search "claude -" 2>/dev/null | jq -r '.[].name' 2>/dev/null | grep "^claude - " || echo "")

	if [[ -z "$items" ]]; then
		err "no Claude configs found in Bitwarden"
		exit 1
	fi

	log "found:"
	echo "$items" | while read -r name; do
		info "  ${name#claude - }"
	done

	if [[ $dry_run -eq 1 ]]; then
		echo ""
		warn "DRY RUN — would restore Claude configs from Bitwarden"
		exit 0
	fi

	echo ""
	warn "this will overwrite existing Claude config files"
	echo -n "type 'yes' to continue: "
	read -r confirm
	[[ "$confirm" != "yes" ]] && { log "aborted"; exit 0; }

	echo ""
	local restored=0
	while read -r item_name; do
		local relpath dest_file content
		relpath="${item_name#claude - }"
		dest_file="$HOME/$relpath"

		content=$(bw get notes "$item_name" 2>/dev/null || echo "")
		if [[ -z "$content" ]]; then
			warn "  empty: $relpath (skipped)"
			continue
		fi

		mkdir -p "$(dirname "$dest_file")"
		printf '%s\n' "$content" > "$dest_file"
		info "  restored: $relpath"
		restored=$(( restored + 1 ))
	done <<< "$items"

	echo ""
	log "$restored Claude config(s) restored — restart Claude Code to pick up changes"
}

# -----------------------------------------------------------------------
# List all secrets
# -----------------------------------------------------------------------
list_all() {
	echo ""

	# SSD
	if mountpoint -q "$SSD" 2>/dev/null; then
		log "SSD secrets:"
		echo ""

		# SSH
		if [[ -d "$SSH_BACKUP_DIR" ]]; then
			local ssh_count
			ssh_count=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "  SSH backups: $ssh_count"
			find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | while read -r b; do
				local size
				size=$(du -sh "$b" 2>/dev/null | cut -f1)
				echo -e "    ${BOLD}$(basename "$b")${NC}  $size"
			done
		else
			info "  SSH backups: none"
		fi

		# ENV
		if [[ -d "$ENV_BACKUP_DIR" ]]; then
			local env_count
			env_count=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "  Env backups: $env_count"
			find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | while read -r b; do
				local size
				size=$(du -sh "$b" 2>/dev/null | cut -f1)
				echo -e "    ${BOLD}$(basename "$b")${NC}  $size"
			done
		else
			info "  Env backups: none"
		fi

		# Claude
		if [[ -d "$CLAUDE_BACKUP_DIR" ]]; then
			local claude_count
			claude_count=$(find "$CLAUDE_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
			info "  Claude backups: $claude_count"
			find "$CLAUDE_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | while read -r b; do
				local size
				size=$(du -sh "$b" 2>/dev/null | cut -f1)
				echo -e "    ${BOLD}$(basename "$b")${NC}  $size"
			done
		else
			info "  Claude backups: none"
		fi

	else
		warn "SSD not mounted"
	fi

	echo ""

	# Bitwarden
	if command -v bw &>/dev/null; then
		local status
		status=$(bw status 2>/dev/null | jq -r '.status' 2>/dev/null || echo "unknown")
		log "Bitwarden: $status"

		if [[ "$status" == "unlocked" ]]; then
			local ssh_items env_items claude_items
			ssh_items=$(bw list items --search "SSH Key" 2>/dev/null | jq -r '.[].name' 2>/dev/null | wc -l || echo "0")
			env_items=$(bw list items --search "env -" 2>/dev/null | jq -r '.[].name' 2>/dev/null | grep "^env - " | wc -l || echo "0")
			claude_items=$(bw list items --search "claude -" 2>/dev/null | jq -r '.[].name' 2>/dev/null | grep "^claude - " | wc -l || echo "0")
			info "  SSH keys: $ssh_items"
			info "  Env files: $env_items"
			info "  Claude configs: $claude_items"
		else
			info "  unlock to see items: export BW_SESSION=\"\$(bw unlock --raw)\""
		fi
	else
		info "Bitwarden: not installed"
	fi
}

# -----------------------------------------------------------------------
# Health check — dashboard of all secrets status
# -----------------------------------------------------------------------
health_check() {
	local issues=0

	echo ""
	echo -e "${BOLD}Secrets Health Check${NC}"
	echo -e "${BOLD}$(printf '%.0s─' {1..45})${NC}"

	# ── SSH Keys ──
	echo ""
	echo -e "${BOLD}SSH Keys${NC}"
	local ssh_key_count=0
	if [[ -d "$SSH_DIR" ]]; then
		for f in "$SSH_DIR"/id_*; do
			[[ -f "$f" && "$f" != *.pub ]] && ssh_key_count=$(( ssh_key_count + 1 ))
		done
	fi
	if [[ $ssh_key_count -gt 0 ]]; then
		log "  local: $ssh_key_count private key(s)"
	else
		warn "  local: no SSH keys found"
		issues=$(( issues + 1 ))
	fi

	if mountpoint -q "$SSD" 2>/dev/null && [[ -d "$SSH_BACKUP_DIR" ]]; then
		local ssh_bk
		ssh_bk=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
		if [[ "$ssh_bk" -gt 0 ]]; then
			local latest_ssh
			latest_ssh=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | tail -1)
			local ssh_age_days
			ssh_age_days=$(( ( $(date +%s) - $(stat -c %Y "$latest_ssh") ) / 86400 ))
			if [[ $ssh_age_days -gt 30 ]]; then
				warn "  SSD: $ssh_bk backup(s) — latest is ${ssh_age_days}d old"
				issues=$(( issues + 1 ))
			else
				log "  SSD: $ssh_bk backup(s) — latest is ${ssh_age_days}d old"
			fi
		else
			err "  SSD: no backups"
			issues=$(( issues + 1 ))
		fi
	elif mountpoint -q "$SSD" 2>/dev/null; then
		err "  SSD: no backups"
		issues=$(( issues + 1 ))
	else
		warn "  SSD: not mounted"
	fi

	# ── Env Files ──
	echo ""
	echo -e "${BOLD}Env Files${NC}"
	local env_count=0
	while read -r f; do
		[[ -f "$f" ]] && env_count=$(( env_count + 1 ))
	done < <(find_env_files "")
	if [[ $env_count -gt 0 ]]; then
		log "  local: $env_count .env file(s)"
	else
		info "  local: no .env files"
	fi

	if mountpoint -q "$SSD" 2>/dev/null && [[ -d "$ENV_BACKUP_DIR" ]]; then
		local env_bk
		env_bk=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
		if [[ "$env_bk" -gt 0 ]]; then
			local latest_env
			latest_env=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | tail -1)
			local env_age_days
			env_age_days=$(( ( $(date +%s) - $(stat -c %Y "$latest_env") ) / 86400 ))
			if [[ $env_age_days -gt 14 ]]; then
				warn "  SSD: $env_bk backup(s) — latest is ${env_age_days}d old"
				issues=$(( issues + 1 ))
			else
				log "  SSD: $env_bk backup(s) — latest is ${env_age_days}d old"
			fi
		else
			if [[ $env_count -gt 0 ]]; then
				err "  SSD: no backups (you have $env_count .env files!)"
				issues=$(( issues + 1 ))
			else
				info "  SSD: no backups"
			fi
		fi
	elif mountpoint -q "$SSD" 2>/dev/null; then
		if [[ $env_count -gt 0 ]]; then
			err "  SSD: no backups (you have $env_count .env files!)"
			issues=$(( issues + 1 ))
		fi
	else
		warn "  SSD: not mounted"
	fi

	# ── Claude Config ──
	echo ""
	echo -e "${BOLD}Claude Config${NC}"
	local claude_count=0
	[[ -f "$CLAUDE_CONFIG" ]] && claude_count=$(( claude_count + 1 ))
	[[ -f "$CLAUDE_SETTINGS" ]] && claude_count=$(( claude_count + 1 ))
	[[ -f "$CLAUDE_MD" ]] && claude_count=$(( claude_count + 1 ))
	if [[ $claude_count -gt 0 ]]; then
		log "  local: $claude_count config file(s)"
		if [[ -f "$CLAUDE_CONFIG" ]] && command -v jq &>/dev/null; then
			local mcp_count
			mcp_count=$(jq '.mcpServers | length' "$CLAUDE_CONFIG" 2>/dev/null || echo "0")
			info "  MCP servers: $mcp_count"
		fi
	else
		warn "  local: no Claude config files"
	fi

	if mountpoint -q "$SSD" 2>/dev/null && [[ -d "$CLAUDE_BACKUP_DIR" ]]; then
		local claude_bk
		claude_bk=$(find "$CLAUDE_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | wc -l)
		if [[ "$claude_bk" -gt 0 ]]; then
			local latest_claude
			latest_claude=$(find "$CLAUDE_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | tail -1)
			local claude_age_days
			claude_age_days=$(( ( $(date +%s) - $(stat -c %Y "$latest_claude") ) / 86400 ))
			if [[ $claude_age_days -gt 14 ]]; then
				warn "  SSD: $claude_bk backup(s) — latest is ${claude_age_days}d old"
				issues=$(( issues + 1 ))
			else
				log "  SSD: $claude_bk backup(s) — latest is ${claude_age_days}d old"
			fi
		else
			if [[ $claude_count -gt 0 ]]; then
				err "  SSD: no backups"
				issues=$(( issues + 1 ))
			fi
		fi
	elif mountpoint -q "$SSD" 2>/dev/null; then
		if [[ $claude_count -gt 0 ]]; then
			err "  SSD: no backups"
			issues=$(( issues + 1 ))
		fi
	else
		warn "  SSD: not mounted"
	fi

	# ── Project Backups ──
	echo ""
	echo -e "${BOLD}Project Backups${NC}"
	local backup_msg
	backup_msg=$(check_backup_age 7)
	if [[ -n "$backup_msg" ]]; then
		warn "  $backup_msg"
		issues=$(( issues + 1 ))
	else
		if [[ -f "$TIMESTAMP_FILE" ]]; then
			local last now days_ago
			last=$(cat "$TIMESTAMP_FILE")
			now=$(date +%s)
			days_ago=$(( (now - last) / 86400 ))
			log "  last backup: ${days_ago}d ago"
		fi
	fi

	if mountpoint -q "$SSD" 2>/dev/null; then
		local bk_count
		bk_count=$(find "$BACKUP_ROOT" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
		if [[ "$bk_count" -gt 0 ]]; then
			local latest_bk
			latest_bk=$(find "$BACKUP_ROOT" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | sort | tail -1)
			local bk_size
			bk_size=$(du -sh "$latest_bk" 2>/dev/null | cut -f1)
			log "  SSD: $bk_count snapshot(s) — latest: $(basename "$latest_bk") ($bk_size)"
		else
			err "  SSD: no project backups"
			issues=$(( issues + 1 ))
		fi
	else
		warn "  SSD: not mounted"
	fi

	# ── Summary ──
	echo ""
	echo -e "${BOLD}$(printf '%.0s─' {1..45})${NC}"
	if [[ $issues -eq 0 ]]; then
		log "all healthy — no issues found"
	else
		warn "$issues issue(s) found — consider running backups"
	fi
	echo ""
}

# -----------------------------------------------------------------------
# Diff — show secrets changed since last backup
# -----------------------------------------------------------------------
secrets_diff() {
	echo ""
	echo -e "${BOLD}Secrets Diff — changed since last backup${NC}"
	echo -e "${BOLD}$(printf '%.0s─' {1..50})${NC}"

	local changed=0

	# ── SSH Keys ──
	echo ""
	echo -e "${BOLD}SSH Keys${NC}"
	if mountpoint -q "$SSD" 2>/dev/null && [[ -d "$SSH_BACKUP_DIR" ]]; then
		local latest_ssh
		latest_ssh=$(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | tail -1)
		if [[ -n "$latest_ssh" ]]; then
			local bk_time
			bk_time=$(stat -c %Y "$latest_ssh")
			local ssh_changed=0
			for f in "$SSH_DIR"/id_* "$SSH_DIR"/config; do
				[[ -f "$f" ]] || continue
				local f_time
				f_time=$(stat -c %Y "$f")
				if (( f_time > bk_time )); then
					warn "  modified: $(basename "$f")  ($(date -d @"$f_time" '+%Y-%m-%d %H:%M'))"
					ssh_changed=1
					changed=1
				fi
			done
			[[ $ssh_changed -eq 0 ]] && log "  no changes since $(basename "$latest_ssh")"
		else
			warn "  no backup to compare against"
		fi
	else
		warn "  SSD not mounted or no backups"
	fi

	# ── Env Files ──
	echo ""
	echo -e "${BOLD}Env Files${NC}"
	if mountpoint -q "$SSD" 2>/dev/null && [[ -d "$ENV_BACKUP_DIR" ]]; then
		local latest_env
		latest_env=$(find "$ENV_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | tail -1)
		if [[ -n "$latest_env" ]]; then
			local bk_time
			bk_time=$(stat -c %Y "$latest_env")
			local env_changed=0
			while read -r f; do
				[[ -f "$f" ]] || continue
				local f_time
				f_time=$(stat -c %Y "$f")
				if (( f_time > bk_time )); then
					local relpath="${f#$PROJECTS_DIR/}"
					warn "  modified: $relpath  ($(date -d @"$f_time" '+%Y-%m-%d %H:%M'))"
					env_changed=1
					changed=1
				fi
			done < <(find_env_files "")
			[[ $env_changed -eq 0 ]] && log "  no changes since $(basename "$latest_env")"
		else
			warn "  no backup to compare against"
		fi
	else
		warn "  SSD not mounted or no backups"
	fi

	# ── Claude Config ──
	echo ""
	echo -e "${BOLD}Claude Config${NC}"
	if mountpoint -q "$SSD" 2>/dev/null && [[ -d "$CLAUDE_BACKUP_DIR" ]]; then
		local latest_claude
		latest_claude=$(find "$CLAUDE_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort | tail -1)
		if [[ -n "$latest_claude" ]]; then
			local bk_time
			bk_time=$(stat -c %Y "$latest_claude")
			local claude_changed=0
			for f in "$CLAUDE_CONFIG" "$CLAUDE_SETTINGS" "$CLAUDE_MD"; do
				[[ -f "$f" ]] || continue
				local f_time
				f_time=$(stat -c %Y "$f")
				if (( f_time > bk_time )); then
					warn "  modified: ${f#$HOME/}  ($(date -d @"$f_time" '+%Y-%m-%d %H:%M'))"
					claude_changed=1
					changed=1
				fi
			done
			[[ $claude_changed -eq 0 ]] && log "  no changes since $(basename "$latest_claude")"
		else
			warn "  no backup to compare against"
		fi
	else
		warn "  SSD not mounted or no backups"
	fi

	# ── Summary ──
	echo ""
	echo -e "${BOLD}$(printf '%.0s─' {1..50})${NC}"
	if [[ $changed -eq 0 ]]; then
		log "all secrets up to date with backups"
	else
		warn "some secrets have changed — consider running backups"
	fi
	echo ""
}

# -----------------------------------------------------------------------
# Migrate — move secrets between backends
# -----------------------------------------------------------------------
secrets_migrate() {
	local migrate_type="$1" migrate_dir="$2"

	if [[ -z "$migrate_type" || -z "$migrate_dir" ]]; then
		echo ""
		echo -e "${BOLD}Usage:${NC} ./secrets migrate <type> <direction>"
		echo ""
		echo "  ./secrets migrate ssh age-to-bw    copy SSH backups from SSD → Bitwarden"
		echo "  ./secrets migrate ssh bw-to-age    copy SSH from Bitwarden → SSD"
		echo "  ./secrets migrate env age-to-bw    copy env backups from SSD → Bitwarden"
		echo "  ./secrets migrate env bw-to-age    copy env from Bitwarden → SSD"
		echo "  ./secrets migrate claude age-to-bw copy Claude backups from SSD → Bitwarden"
		echo "  ./secrets migrate claude bw-to-age copy Claude from Bitwarden → SSD"
		echo "  ./secrets migrate all age-to-bw    migrate everything SSD → Bitwarden"
		echo "  ./secrets migrate all bw-to-age    migrate everything Bitwarden → SSD"
		echo ""
		exit 0
	fi

	local types=()
	if [[ "$migrate_type" == "all" ]]; then
		types=(ssh env claude)
	else
		types=("$migrate_type")
	fi

	case "$migrate_dir" in
		age-to-bw)
			log "migrating ${migrate_type} from SSD (age) → Bitwarden..."
			echo ""

			for t in "${types[@]}"; do
				info "--- $t ---"
				case "$t" in
					ssh)
						# Restore from age to local, then backup to BW
						log "restoring SSH from SSD (age)..."
						# We need the keys locally first — if they're already there, just backup to BW
						if [[ -d "$SSH_DIR" ]] && ls "$SSH_DIR"/id_* &>/dev/null; then
							log "SSH keys already local — backing up to Bitwarden..."
							ssh_backup_bw
						else
							warn "no local SSH keys — restore from SSD first: ./secrets ssh restore"
						fi
						;;
					env)
						# Env files should be local already, just backup to BW
						log "backing up env files to Bitwarden..."
						env_backup_bw
						;;
					claude)
						log "backing up Claude configs to Bitwarden..."
						claude_backup_bw
						;;
				esac
				echo ""
			done
			log "migration complete: SSD → Bitwarden"
			;;

		bw-to-age)
			log "migrating ${migrate_type} from Bitwarden → SSD (age)..."
			echo ""

			for t in "${types[@]}"; do
				info "--- $t ---"
				case "$t" in
					ssh)
						# Restore from BW to local, then backup to age
						log "restoring SSH from Bitwarden..."
						ssh_restore_bw
						echo ""
						log "backing up to SSD (age)..."
						ssh_backup_age
						;;
					env)
						log "restoring env from Bitwarden..."
						env_restore_bw
						echo ""
						log "backing up to SSD (age)..."
						env_backup_age
						;;
					claude)
						log "restoring Claude from Bitwarden..."
						claude_restore_bw
						echo ""
						log "backing up to SSD (age)..."
						claude_backup_age
						;;
				esac
				echo ""
			done
			log "migration complete: Bitwarden → SSD"
			;;

		*)
			err "unknown direction: $migrate_dir"
			err "use: age-to-bw or bw-to-age"
			exit 1
			;;
	esac
}

# -----------------------------------------------------------------------
# Alias management (CLI)
# -----------------------------------------------------------------------
alias_list() {
	echo ""
	if [[ -f "$ENV_ALIAS_FILE" ]] && [[ -s "$ENV_ALIAS_FILE" ]]; then
		log "project aliases ($ENV_ALIAS_FILE):"
		echo ""
		while IFS='=' read -r dirname alias_name; do
			[[ -z "$dirname" || "$dirname" == \#* ]] && continue
			info "  $dirname = $alias_name"
		done < "$ENV_ALIAS_FILE"
	else
		warn "no aliases set"
	fi
}

alias_set() {
	local project="$1" alias_name="$2"
	if [[ -z "$project" || -z "$alias_name" ]]; then
		err "usage: ./secrets alias set <project> <name>"
		exit 1
	fi
	mkdir -p "$(dirname "$ENV_ALIAS_FILE")"
	if [[ -f "$ENV_ALIAS_FILE" ]] && grep -q "^${project}=" "$ENV_ALIAS_FILE" 2>/dev/null; then
		sed -i "s|^${project}=.*|${project}=${alias_name}|" "$ENV_ALIAS_FILE"
	else
		echo "${project}=${alias_name}" >> "$ENV_ALIAS_FILE"
	fi
	log "alias set: $project = $alias_name"
}

alias_remove() {
	local project="$1"
	if [[ -z "$project" ]]; then
		err "usage: ./secrets alias remove <project>"
		exit 1
	fi
	if [[ ! -f "$ENV_ALIAS_FILE" ]]; then
		warn "no aliases file"
		return
	fi
	if grep -q "^${project}=" "$ENV_ALIAS_FILE" 2>/dev/null; then
		sed -i "/^${project}=/d" "$ENV_ALIAS_FILE"
		log "removed alias for $project"
	else
		warn "no alias found for $project"
	fi
}

# -----------------------------------------------------------------------
# SSH copy-id (deploy key to remote server)
# -----------------------------------------------------------------------
ssh_copy_id() {
	local remote="$target"
	if [[ -z "$remote" ]]; then
		err "usage: ./secrets ssh copy-id user@server"
		exit 1
	fi

	# Find public keys
	local keys=()
	for f in "$SSH_DIR"/id_*.pub; do
		[[ -f "$f" ]] && keys+=("$f")
	done

	if [[ ${#keys[@]} -eq 0 ]]; then
		err "no public keys found in $SSH_DIR/"
		err "generate one: ssh-keygen -t ed25519"
		exit 1
	fi

	# Use first key by default, or specified key via target2
	local selected_key="${keys[0]}"
	if [[ -n "$target2" ]]; then
		if [[ -f "$SSH_DIR/$target2" ]]; then
			selected_key="$SSH_DIR/$target2"
		elif [[ -f "$SSH_DIR/$target2.pub" ]]; then
			selected_key="$SSH_DIR/$target2.pub"
		else
			err "key not found: $target2"
			exit 1
		fi
	fi

	log "copying $(basename "$selected_key") → $remote"

	if [[ $dry_run -eq 1 ]]; then
		warn "DRY RUN — would run: ssh-copy-id -i $selected_key $remote"
		exit 0
	fi

	ssh-copy-id -i "$selected_key" "$remote" || { err "ssh-copy-id failed"; exit 1; }

	echo ""
	log "key deployed! test with: ssh $remote"
}

# -----------------------------------------------------------------------
# SSH list (CLI)
# -----------------------------------------------------------------------
ssh_list() {
	echo ""
	log "local SSH keys ($SSH_DIR/):"
	echo ""
	if [[ ! -d "$SSH_DIR" ]]; then
		warn "no ~/.ssh/ directory"
		return
	fi
	for f in "$SSH_DIR"/*; do
		[[ -e "$f" ]] || continue
		local name perms size
		name=$(basename "$f")
		perms=$(stat -c '%a' "$f")
		size=$(du -sh "$f" 2>/dev/null | cut -f1)
		case "$name" in
			id_*|*.pem)
				if [[ "$name" == *.pub ]]; then
					info "  $name  ($perms)  $size  [public key]"
				else
					info "  $name  ($perms)  $size  [private key]"
				fi
				;;
			config)       info "  $name  ($perms)  $size  [ssh config]" ;;
			known_hosts)  info "  $name  ($perms)  $size  [known hosts]" ;;
			*)            info "  $name  ($perms)  $size" ;;
		esac
	done
}

# -----------------------------------------------------------------------
# Usage
# -----------------------------------------------------------------------
usage() {
	echo ""
	echo -e "${BOLD}Usage:${NC} ./secrets <type> <action> [project] [--bw] [--to <project>] [--ssd <path>] [--dry]"
	echo ""
	echo -e "${BOLD}SSH keys:${NC}"
	echo "  ./secrets ssh backup           encrypt SSH keys → SSD (age)"
	echo "  ./secrets ssh backup --bw      store SSH keys → Bitwarden"
	echo "  ./secrets ssh restore          decrypt SSH keys ← SSD (age)"
	echo "  ./secrets ssh restore --bw     retrieve SSH keys ← Bitwarden"
	echo "  ./secrets ssh list             list local SSH keys"
	echo "  ./secrets ssh copy-id <user@host>  copy public key to remote server"
	echo ""
	echo -e "${BOLD}Environment files (all projects):${NC}"
	echo "  ./secrets env backup           encrypt all .env files → SSD"
	echo "  ./secrets env backup --bw      store all .env files → Bitwarden"
	echo "  ./secrets env restore          decrypt all .env files ← SSD"
	echo "  ./secrets env restore --bw     retrieve all .env files ← Bitwarden"
	echo "  ./secrets env list             list all .env files"
	echo ""
	echo -e "${BOLD}Environment files (per-project):${NC}"
	echo "  ./secrets env backup <project>           only that project → SSD"
	echo "  ./secrets env backup <project> --bw      only that project → Bitwarden"
	echo "  ./secrets env restore <project>          only that project ← SSD"
	echo "  ./secrets env restore <project> --bw     only that project ← Bitwarden"
	echo "  ./secrets env list <project>             list only that project's .env files"
	echo ""
	echo -e "${BOLD}Cross-project restore:${NC}"
	echo "  ./secrets env restore <src> --to <dest>       copy src's .env → dest/ (SSD)"
	echo "  ./secrets env restore <src> --to <dest> --bw  copy src's .env → dest/ (Bitwarden)"
	echo ""
	echo -e "${BOLD}Claude Code config (MCP servers, plugins, API keys):${NC}"
	echo "  ./secrets claude backup        encrypt Claude configs → SSD (age)"
	echo "  ./secrets claude backup --bw   store Claude configs → Bitwarden"
	echo "  ./secrets claude restore       decrypt Claude configs ← SSD (age)"
	echo "  ./secrets claude restore --bw  retrieve Claude configs ← Bitwarden"
	echo "  ./secrets claude list          list Claude config files"
	echo ""
	echo -e "${BOLD}Migrate between backends:${NC}"
	echo "  ./secrets migrate ssh age-to-bw     SSD → Bitwarden"
	echo "  ./secrets migrate ssh bw-to-age     Bitwarden → SSD"
	echo "  ./secrets migrate env age-to-bw     SSD → Bitwarden"
	echo "  ./secrets migrate env bw-to-age     Bitwarden → SSD"
	echo "  ./secrets migrate all age-to-bw     everything SSD → Bitwarden"
	echo "  ./secrets migrate all bw-to-age     everything Bitwarden → SSD"
	echo ""
	echo -e "${BOLD}Aliases:${NC}"
	echo "  ./secrets alias list                    show all aliases"
	echo "  ./secrets alias set <project> <name>    set alias for project"
	echo "  ./secrets alias remove <project>        remove alias"
	echo ""
	echo -e "${BOLD}Other:${NC}"
	echo "  ./secrets --list               list all secrets on SSD/Bitwarden"
	echo "  ./secrets --health             health check dashboard"
	echo "  ./secrets --diff               show secrets changed since last backup"
	echo "  ./secrets --ssd <path>         override SSD mount path"
	echo "  ./secrets --keep <n>           keep N most recent archives (default: $DEFAULT_KEEP)"
	echo "  ./secrets --dry <command>      preview mode"
	echo ""
}

# -----------------------------------------------------------------------
# Parse and dispatch
# -----------------------------------------------------------------------
dry_run=0
use_bw=0
keep=$DEFAULT_KEEP
type=""
action=""
target=""
target2=""
to_project=""

_migrate_type=""
_migrate_dir=""
if [[ "${1:-}" == "migrate" ]]; then
	_migrate_type="${2:-}"
	_migrate_dir="${3:-}"
fi

_next_is_to=0
_next_is_ssd=0
_next_is_keep=0
for arg in "$@"; do
	if [[ $_next_is_to -eq 1 ]]; then
		to_project="$arg"
		_next_is_to=0
		continue
	fi
	if [[ $_next_is_ssd -eq 1 ]]; then
		SSD="$arg"
		BACKUP_ROOT="$SSD/backups"
		SSH_BACKUP_DIR="$SSD/ssh-keys"
		ENV_BACKUP_DIR="$SSD/env-secrets"
		CLAUDE_BACKUP_DIR="$SSD/claude-config"
		_next_is_ssd=0
		continue
	fi
	if [[ $_next_is_keep -eq 1 ]]; then
		keep="$arg"
		_next_is_keep=0
		continue
	fi
	case "$arg" in
		--dry)  dry_run=1 ;;
		--bw)   use_bw=1 ;;
		--to)   _next_is_to=1 ;;
		--ssd)  _next_is_ssd=1 ;;
		--keep) _next_is_keep=1 ;;
		--list) list_all; exit 0 ;;
		--health) health_check; exit 0 ;;
		--diff) secrets_diff; exit 0 ;;
		--help|-h) usage; exit 0 ;;
		migrate|ssh|env|alias|claude)
			[[ -z "$type" ]] && type="$arg" ;;
		backup|restore|list|set|remove|copy-id)
			[[ -z "$action" ]] && action="$arg" ;;
		*)
			if [[ -z "$target" ]]; then
				target="$arg"
			elif [[ -z "$target2" ]]; then
				target2="$arg"
			else
				err "unknown argument: $arg"
				usage
				exit 1
			fi
			;;
	esac
done
if [[ $_next_is_to -eq 1 || $_next_is_ssd -eq 1 || $_next_is_keep -eq 1 ]]; then
	err "missing value for flag (--to, --ssd, or --keep)"
	exit 1
fi
unset _next_is_to _next_is_ssd _next_is_keep

# Dispatch migrate after flags are parsed
if [[ -n "$_migrate_type" || -n "$_migrate_dir" ]]; then
	secrets_migrate "$_migrate_type" "$_migrate_dir"
	exit 0
fi

if [[ -z "$type" || -z "$action" ]]; then
	usage
	exit 0
fi

# Validate target project directory exists (for env commands, not list)
if [[ -n "$target" && "$type" == "env" && "$action" != "list" ]]; then
	if [[ ! -d "$PROJECTS_DIR/$target" ]]; then
		err "project directory not found: $PROJECTS_DIR/$target"
		exit 1
	fi
fi

case "${type}_${action}" in
	ssh_backup)
		[[ $use_bw -eq 1 ]] && ssh_backup_bw || ssh_backup_age ;;
	ssh_restore)
		[[ $use_bw -eq 1 ]] && ssh_restore_bw || ssh_restore_age ;;
	ssh_list)
		ssh_list ;;
	ssh_copy-id)
		ssh_copy_id ;;
	env_backup)
		[[ $use_bw -eq 1 ]] && env_backup_bw || env_backup_age ;;
	env_restore)
		[[ $use_bw -eq 1 ]] && env_restore_bw || env_restore_age ;;
	env_list)
		env_list ;;
	claude_backup)
		[[ $use_bw -eq 1 ]] && claude_backup_bw || claude_backup_age ;;
	claude_restore)
		[[ $use_bw -eq 1 ]] && claude_restore_bw || claude_restore_age ;;
	claude_list)
		claude_list ;;
	alias_list)
		alias_list ;;
	alias_set)
		alias_set "$target" "$target2"
		;;
	alias_remove)
		alias_remove "$target" ;;
	*)
		err "unknown command: $type $action"
		usage
		exit 1
		;;
esac
