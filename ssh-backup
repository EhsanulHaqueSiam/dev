#!/usr/bin/env bash
set -euo pipefail

# -----------------------------------------------------------------------
# Backup SSH keys to external SSD (encrypted with age)
#
# Encrypts ~/.ssh/ into a single age-encrypted tarball on the SSD.
# Passphrase-based encryption — you choose the passphrase at backup time.
#
# Usage:
#   ./ssh-backup              — encrypt and save to SSD
#   ./ssh-backup --dry        — preview what would be backed up
#   ./ssh-backup --list       — show existing SSH backups on SSD
# -----------------------------------------------------------------------

SSD="/run/media/siam/TRANSCEND"
SSH_BACKUP_DIR="$SSD/ssh-keys"
SSH_DIR="$HOME/.ssh"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

log()  { echo -e "${GREEN}[ssh-backup]${NC} $1"; }
warn() { echo -e "${YELLOW}[ssh-backup]${NC} $1"; }
err()  { echo -e "${RED}[ssh-backup]${NC} $1"; }
info() { echo -e "${BLUE}[ssh-backup]${NC} $1"; }

# -----------------------------------------------------------------------
# Parse arguments
# -----------------------------------------------------------------------
dry_run=0
list_mode=0

while [[ $# -gt 0 ]]; do
	case "$1" in
		--dry)  dry_run=1 ;;
		--list) list_mode=1 ;;
		*)      err "unknown flag: $1"; exit 1 ;;
	esac
	shift
done

# -----------------------------------------------------------------------
# Check dependencies
# -----------------------------------------------------------------------
if ! command -v age &>/dev/null; then
	warn "age not found — installing..."
	if command -v paru &>/dev/null; then
		paru -S --noconfirm --needed age
	elif command -v pacman &>/dev/null; then
		sudo pacman -S --noconfirm --needed age
	else
		err "install age manually: https://github.com/FiloSottile/age"
		exit 1
	fi
fi

# -----------------------------------------------------------------------
# Check SSD
# -----------------------------------------------------------------------
if ! mountpoint -q "$SSD" 2>/dev/null; then
	err "SSD not mounted at $SSD"
	exit 1
fi

# -----------------------------------------------------------------------
# List mode
# -----------------------------------------------------------------------
if [[ $list_mode -eq 1 ]]; then
	log "SSH key backups on SSD:"
	echo ""

	if [[ ! -d "$SSH_BACKUP_DIR" ]]; then
		warn "no SSH backups found"
		exit 0
	fi

	mapfile -t backups < <(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort)

	if [[ ${#backups[@]} -eq 0 ]]; then
		warn "no SSH backups found"
		exit 0
	fi

	for b in "${backups[@]}"; do
		local_name=$(basename "$b")
		local_size=$(du -sh "$b" 2>/dev/null | cut -f1)
		echo -e "  ${BOLD}$local_name${NC}  $local_size"
	done
	echo ""
	exit 0
fi

# -----------------------------------------------------------------------
# Check SSH directory
# -----------------------------------------------------------------------
if [[ ! -d "$SSH_DIR" ]]; then
	err "no SSH directory found at $SSH_DIR"
	exit 1
fi

# Show what will be backed up
echo ""
log "SSH keys to backup:"
echo ""

key_count=0
for f in "$SSH_DIR"/*; do
	[[ -e "$f" ]] || continue
	name=$(basename "$f")
	# Skip known_hosts backups
	[[ "$name" == "known_hosts.old" ]] && continue
	size=$(du -sh "$f" 2>/dev/null | cut -f1)

	case "$name" in
		id_*|*.pem)
			if [[ "$name" == *.pub ]]; then
				info "  $name  ($size)  [public key]"
			else
				info "  $name  ($size)  [private key]"
			fi
			key_count=$(( key_count + 1 ))
			;;
		config)
			info "  $name  ($size)  [ssh config]"
			;;
		known_hosts)
			info "  $name  ($size)  [known hosts]"
			;;
		*)
			info "  $name  ($size)"
			;;
	esac
done

if [[ $key_count -eq 0 ]]; then
	warn "no SSH keys found in $SSH_DIR"
	exit 0
fi

echo ""

# -----------------------------------------------------------------------
# Dry run
# -----------------------------------------------------------------------
if [[ $dry_run -eq 1 ]]; then
	warn "=== DRY RUN ==="
	warn "would encrypt $SSH_DIR into $SSH_BACKUP_DIR/"
	warn "encryption: age passphrase (you choose at backup time)"
	warn "no changes made"
	exit 0
fi

# -----------------------------------------------------------------------
# Create encrypted backup
# -----------------------------------------------------------------------
timestamp=$(date +%Y-%m-%d_%H-%M-%S)
hostname=$(hostname 2>/dev/null || echo "unknown")
backup_file="$SSH_BACKUP_DIR/ssh-keys_${hostname}_${timestamp}.tar.age"

mkdir -p "$SSH_BACKUP_DIR"

log "encrypting SSH keys..."
warn "choose a strong passphrase (you'll need it to restore)"
echo ""

# Tar + age encrypt with passphrase
tar -C "$HOME" -cf - .ssh | age -p -o "$backup_file"

if [[ -f "$backup_file" ]]; then
	backup_size=$(du -sh "$backup_file" 2>/dev/null | cut -f1)
	echo ""
	echo -e "${GREEN}================================${NC}"
	log "SSH backup complete"
	echo -e "${GREEN}================================${NC}"
	log "file: $backup_file"
	log "size: $backup_size"
	log "encryption: age passphrase"
	echo ""
	warn "remember your passphrase — it's the only way to restore"

	# Show all SSH backups
	echo ""
	log "all SSH backups on SSD:"
	mapfile -t all_backups < <(find "$SSH_BACKUP_DIR" -name "*.tar.age" -type f 2>/dev/null | sort)
	for b in "${all_backups[@]}"; do
		size=$(du -sh "$b" 2>/dev/null | cut -f1)
		echo -e "  ${BOLD}$(basename "$b")${NC}  $size"
	done
else
	err "backup failed — file not created"
	exit 1
fi
